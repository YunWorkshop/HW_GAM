// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gcs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gcs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gcs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "runtime_env_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gcs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gcs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[44]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gcs_2eproto;
namespace mcs {
namespace rpc {
class ActorTableData;
struct ActorTableDataDefaultTypeInternal;
extern ActorTableDataDefaultTypeInternal _ActorTableData_default_instance_;
class ActorTableData_RequiredResourcesEntry_DoNotUse;
struct ActorTableData_RequiredResourcesEntry_DoNotUseDefaultTypeInternal;
extern ActorTableData_RequiredResourcesEntry_DoNotUseDefaultTypeInternal _ActorTableData_RequiredResourcesEntry_DoNotUse_default_instance_;
class AvailableResources;
struct AvailableResourcesDefaultTypeInternal;
extern AvailableResourcesDefaultTypeInternal _AvailableResources_default_instance_;
class AvailableResources_ResourcesAvailableEntry_DoNotUse;
struct AvailableResources_ResourcesAvailableEntry_DoNotUseDefaultTypeInternal;
extern AvailableResources_ResourcesAvailableEntry_DoNotUseDefaultTypeInternal _AvailableResources_ResourcesAvailableEntry_DoNotUse_default_instance_;
class ErrorTableData;
struct ErrorTableDataDefaultTypeInternal;
extern ErrorTableDataDefaultTypeInternal _ErrorTableData_default_instance_;
class GcsEntry;
struct GcsEntryDefaultTypeInternal;
extern GcsEntryDefaultTypeInternal _GcsEntry_default_instance_;
class GcsNodeInfo;
struct GcsNodeInfoDefaultTypeInternal;
extern GcsNodeInfoDefaultTypeInternal _GcsNodeInfo_default_instance_;
class GcsNodeInfo_ResourcesTotalEntry_DoNotUse;
struct GcsNodeInfo_ResourcesTotalEntry_DoNotUseDefaultTypeInternal;
extern GcsNodeInfo_ResourcesTotalEntry_DoNotUseDefaultTypeInternal _GcsNodeInfo_ResourcesTotalEntry_DoNotUse_default_instance_;
class HeartbeatTableData;
struct HeartbeatTableDataDefaultTypeInternal;
extern HeartbeatTableDataDefaultTypeInternal _HeartbeatTableData_default_instance_;
class JobConfig;
struct JobConfigDefaultTypeInternal;
extern JobConfigDefaultTypeInternal _JobConfig_default_instance_;
class JobConfig_MetadataEntry_DoNotUse;
struct JobConfig_MetadataEntry_DoNotUseDefaultTypeInternal;
extern JobConfig_MetadataEntry_DoNotUseDefaultTypeInternal _JobConfig_MetadataEntry_DoNotUse_default_instance_;
class JobTableData;
struct JobTableDataDefaultTypeInternal;
extern JobTableDataDefaultTypeInternal _JobTableData_default_instance_;
class NodeResourceChange;
struct NodeResourceChangeDefaultTypeInternal;
extern NodeResourceChangeDefaultTypeInternal _NodeResourceChange_default_instance_;
class NodeResourceChange_UpdatedResourcesEntry_DoNotUse;
struct NodeResourceChange_UpdatedResourcesEntry_DoNotUseDefaultTypeInternal;
extern NodeResourceChange_UpdatedResourcesEntry_DoNotUseDefaultTypeInternal _NodeResourceChange_UpdatedResourcesEntry_DoNotUse_default_instance_;
class ObjectTableData;
struct ObjectTableDataDefaultTypeInternal;
extern ObjectTableDataDefaultTypeInternal _ObjectTableData_default_instance_;
class PlacementGroupLoad;
struct PlacementGroupLoadDefaultTypeInternal;
extern PlacementGroupLoadDefaultTypeInternal _PlacementGroupLoad_default_instance_;
class PlacementGroupStats;
struct PlacementGroupStatsDefaultTypeInternal;
extern PlacementGroupStatsDefaultTypeInternal _PlacementGroupStats_default_instance_;
class PlacementGroupTableData;
struct PlacementGroupTableDataDefaultTypeInternal;
extern PlacementGroupTableDataDefaultTypeInternal _PlacementGroupTableData_default_instance_;
class ProfileEventEntry;
struct ProfileEventEntryDefaultTypeInternal;
extern ProfileEventEntryDefaultTypeInternal _ProfileEventEntry_default_instance_;
class ProfileEvents;
struct ProfileEventsDefaultTypeInternal;
extern ProfileEventsDefaultTypeInternal _ProfileEvents_default_instance_;
class PubSubMessage;
struct PubSubMessageDefaultTypeInternal;
extern PubSubMessageDefaultTypeInternal _PubSubMessage_default_instance_;
class ResourceDemand;
struct ResourceDemandDefaultTypeInternal;
extern ResourceDemandDefaultTypeInternal _ResourceDemand_default_instance_;
class ResourceDemand_ShapeEntry_DoNotUse;
struct ResourceDemand_ShapeEntry_DoNotUseDefaultTypeInternal;
extern ResourceDemand_ShapeEntry_DoNotUseDefaultTypeInternal _ResourceDemand_ShapeEntry_DoNotUse_default_instance_;
class ResourceLoad;
struct ResourceLoadDefaultTypeInternal;
extern ResourceLoadDefaultTypeInternal _ResourceLoad_default_instance_;
class ResourceMap;
struct ResourceMapDefaultTypeInternal;
extern ResourceMapDefaultTypeInternal _ResourceMap_default_instance_;
class ResourceMap_ItemsEntry_DoNotUse;
struct ResourceMap_ItemsEntry_DoNotUseDefaultTypeInternal;
extern ResourceMap_ItemsEntry_DoNotUseDefaultTypeInternal _ResourceMap_ItemsEntry_DoNotUse_default_instance_;
class ResourceTableData;
struct ResourceTableDataDefaultTypeInternal;
extern ResourceTableDataDefaultTypeInternal _ResourceTableData_default_instance_;
class ResourceUpdate;
struct ResourceUpdateDefaultTypeInternal;
extern ResourceUpdateDefaultTypeInternal _ResourceUpdate_default_instance_;
class ResourceUsageBatchData;
struct ResourceUsageBatchDataDefaultTypeInternal;
extern ResourceUsageBatchDataDefaultTypeInternal _ResourceUsageBatchData_default_instance_;
class ResourceUsageBroadcastData;
struct ResourceUsageBroadcastDataDefaultTypeInternal;
extern ResourceUsageBroadcastDataDefaultTypeInternal _ResourceUsageBroadcastData_default_instance_;
class ResourcesData;
struct ResourcesDataDefaultTypeInternal;
extern ResourcesDataDefaultTypeInternal _ResourcesData_default_instance_;
class ResourcesData_ResourceLoadEntry_DoNotUse;
struct ResourcesData_ResourceLoadEntry_DoNotUseDefaultTypeInternal;
extern ResourcesData_ResourceLoadEntry_DoNotUseDefaultTypeInternal _ResourcesData_ResourceLoadEntry_DoNotUse_default_instance_;
class ResourcesData_ResourcesAvailableEntry_DoNotUse;
struct ResourcesData_ResourcesAvailableEntry_DoNotUseDefaultTypeInternal;
extern ResourcesData_ResourcesAvailableEntry_DoNotUseDefaultTypeInternal _ResourcesData_ResourcesAvailableEntry_DoNotUse_default_instance_;
class ResourcesData_ResourcesNormalTaskEntry_DoNotUse;
struct ResourcesData_ResourcesNormalTaskEntry_DoNotUseDefaultTypeInternal;
extern ResourcesData_ResourcesNormalTaskEntry_DoNotUseDefaultTypeInternal _ResourcesData_ResourcesNormalTaskEntry_DoNotUse_default_instance_;
class ResourcesData_ResourcesTotalEntry_DoNotUse;
struct ResourcesData_ResourcesTotalEntry_DoNotUseDefaultTypeInternal;
extern ResourcesData_ResourcesTotalEntry_DoNotUseDefaultTypeInternal _ResourcesData_ResourcesTotalEntry_DoNotUse_default_instance_;
class ScheduleData;
struct ScheduleDataDefaultTypeInternal;
extern ScheduleDataDefaultTypeInternal _ScheduleData_default_instance_;
class ScheduleData_SchedulePlanEntry_DoNotUse;
struct ScheduleData_SchedulePlanEntry_DoNotUseDefaultTypeInternal;
extern ScheduleData_SchedulePlanEntry_DoNotUseDefaultTypeInternal _ScheduleData_SchedulePlanEntry_DoNotUse_default_instance_;
class StoredConfig;
struct StoredConfigDefaultTypeInternal;
extern StoredConfigDefaultTypeInternal _StoredConfig_default_instance_;
class TaskEventData;
struct TaskEventDataDefaultTypeInternal;
extern TaskEventDataDefaultTypeInternal _TaskEventData_default_instance_;
class TaskEvents;
struct TaskEventsDefaultTypeInternal;
extern TaskEventsDefaultTypeInternal _TaskEvents_default_instance_;
class TaskStateUpdate;
struct TaskStateUpdateDefaultTypeInternal;
extern TaskStateUpdateDefaultTypeInternal _TaskStateUpdate_default_instance_;
class WorkerDeltaData;
struct WorkerDeltaDataDefaultTypeInternal;
extern WorkerDeltaDataDefaultTypeInternal _WorkerDeltaData_default_instance_;
class WorkerTableData;
struct WorkerTableDataDefaultTypeInternal;
extern WorkerTableDataDefaultTypeInternal _WorkerTableData_default_instance_;
class WorkerTableData_WorkerInfoEntry_DoNotUse;
struct WorkerTableData_WorkerInfoEntry_DoNotUseDefaultTypeInternal;
extern WorkerTableData_WorkerInfoEntry_DoNotUseDefaultTypeInternal _WorkerTableData_WorkerInfoEntry_DoNotUse_default_instance_;
}  // namespace rpc
}  // namespace mcs
PROTOBUF_NAMESPACE_OPEN
template<> ::mcs::rpc::ActorTableData* Arena::CreateMaybeMessage<::mcs::rpc::ActorTableData>(Arena*);
template<> ::mcs::rpc::ActorTableData_RequiredResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ActorTableData_RequiredResourcesEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::AvailableResources* Arena::CreateMaybeMessage<::mcs::rpc::AvailableResources>(Arena*);
template<> ::mcs::rpc::AvailableResources_ResourcesAvailableEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::AvailableResources_ResourcesAvailableEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ErrorTableData* Arena::CreateMaybeMessage<::mcs::rpc::ErrorTableData>(Arena*);
template<> ::mcs::rpc::GcsEntry* Arena::CreateMaybeMessage<::mcs::rpc::GcsEntry>(Arena*);
template<> ::mcs::rpc::GcsNodeInfo* Arena::CreateMaybeMessage<::mcs::rpc::GcsNodeInfo>(Arena*);
template<> ::mcs::rpc::GcsNodeInfo_ResourcesTotalEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::GcsNodeInfo_ResourcesTotalEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::HeartbeatTableData* Arena::CreateMaybeMessage<::mcs::rpc::HeartbeatTableData>(Arena*);
template<> ::mcs::rpc::JobConfig* Arena::CreateMaybeMessage<::mcs::rpc::JobConfig>(Arena*);
template<> ::mcs::rpc::JobConfig_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::JobConfig_MetadataEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::JobTableData* Arena::CreateMaybeMessage<::mcs::rpc::JobTableData>(Arena*);
template<> ::mcs::rpc::NodeResourceChange* Arena::CreateMaybeMessage<::mcs::rpc::NodeResourceChange>(Arena*);
template<> ::mcs::rpc::NodeResourceChange_UpdatedResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::NodeResourceChange_UpdatedResourcesEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ObjectTableData* Arena::CreateMaybeMessage<::mcs::rpc::ObjectTableData>(Arena*);
template<> ::mcs::rpc::PlacementGroupLoad* Arena::CreateMaybeMessage<::mcs::rpc::PlacementGroupLoad>(Arena*);
template<> ::mcs::rpc::PlacementGroupStats* Arena::CreateMaybeMessage<::mcs::rpc::PlacementGroupStats>(Arena*);
template<> ::mcs::rpc::PlacementGroupTableData* Arena::CreateMaybeMessage<::mcs::rpc::PlacementGroupTableData>(Arena*);
template<> ::mcs::rpc::ProfileEventEntry* Arena::CreateMaybeMessage<::mcs::rpc::ProfileEventEntry>(Arena*);
template<> ::mcs::rpc::ProfileEvents* Arena::CreateMaybeMessage<::mcs::rpc::ProfileEvents>(Arena*);
template<> ::mcs::rpc::PubSubMessage* Arena::CreateMaybeMessage<::mcs::rpc::PubSubMessage>(Arena*);
template<> ::mcs::rpc::ResourceDemand* Arena::CreateMaybeMessage<::mcs::rpc::ResourceDemand>(Arena*);
template<> ::mcs::rpc::ResourceDemand_ShapeEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ResourceDemand_ShapeEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ResourceLoad* Arena::CreateMaybeMessage<::mcs::rpc::ResourceLoad>(Arena*);
template<> ::mcs::rpc::ResourceMap* Arena::CreateMaybeMessage<::mcs::rpc::ResourceMap>(Arena*);
template<> ::mcs::rpc::ResourceMap_ItemsEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ResourceMap_ItemsEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ResourceTableData* Arena::CreateMaybeMessage<::mcs::rpc::ResourceTableData>(Arena*);
template<> ::mcs::rpc::ResourceUpdate* Arena::CreateMaybeMessage<::mcs::rpc::ResourceUpdate>(Arena*);
template<> ::mcs::rpc::ResourceUsageBatchData* Arena::CreateMaybeMessage<::mcs::rpc::ResourceUsageBatchData>(Arena*);
template<> ::mcs::rpc::ResourceUsageBroadcastData* Arena::CreateMaybeMessage<::mcs::rpc::ResourceUsageBroadcastData>(Arena*);
template<> ::mcs::rpc::ResourcesData* Arena::CreateMaybeMessage<::mcs::rpc::ResourcesData>(Arena*);
template<> ::mcs::rpc::ResourcesData_ResourceLoadEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ResourcesData_ResourceLoadEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ResourcesData_ResourcesAvailableEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ResourcesData_ResourcesAvailableEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ResourcesData_ResourcesNormalTaskEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ResourcesData_ResourcesNormalTaskEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ResourcesData_ResourcesTotalEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ResourcesData_ResourcesTotalEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ScheduleData* Arena::CreateMaybeMessage<::mcs::rpc::ScheduleData>(Arena*);
template<> ::mcs::rpc::ScheduleData_SchedulePlanEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::ScheduleData_SchedulePlanEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::StoredConfig* Arena::CreateMaybeMessage<::mcs::rpc::StoredConfig>(Arena*);
template<> ::mcs::rpc::TaskEventData* Arena::CreateMaybeMessage<::mcs::rpc::TaskEventData>(Arena*);
template<> ::mcs::rpc::TaskEvents* Arena::CreateMaybeMessage<::mcs::rpc::TaskEvents>(Arena*);
template<> ::mcs::rpc::TaskStateUpdate* Arena::CreateMaybeMessage<::mcs::rpc::TaskStateUpdate>(Arena*);
template<> ::mcs::rpc::WorkerDeltaData* Arena::CreateMaybeMessage<::mcs::rpc::WorkerDeltaData>(Arena*);
template<> ::mcs::rpc::WorkerTableData* Arena::CreateMaybeMessage<::mcs::rpc::WorkerTableData>(Arena*);
template<> ::mcs::rpc::WorkerTableData_WorkerInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::WorkerTableData_WorkerInfoEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mcs {
namespace rpc {

enum ActorTableData_ActorState : int {
  ActorTableData_ActorState_DEPENDENCIES_UNREADY = 0,
  ActorTableData_ActorState_PENDING_CREATION = 1,
  ActorTableData_ActorState_ALIVE = 2,
  ActorTableData_ActorState_RESTARTING = 3,
  ActorTableData_ActorState_DEAD = 4,
  ActorTableData_ActorState_ActorTableData_ActorState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActorTableData_ActorState_ActorTableData_ActorState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActorTableData_ActorState_IsValid(int value);
constexpr ActorTableData_ActorState ActorTableData_ActorState_ActorState_MIN = ActorTableData_ActorState_DEPENDENCIES_UNREADY;
constexpr ActorTableData_ActorState ActorTableData_ActorState_ActorState_MAX = ActorTableData_ActorState_DEAD;
constexpr int ActorTableData_ActorState_ActorState_ARRAYSIZE = ActorTableData_ActorState_ActorState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActorTableData_ActorState_descriptor();
template<typename T>
inline const std::string& ActorTableData_ActorState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActorTableData_ActorState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActorTableData_ActorState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActorTableData_ActorState_descriptor(), enum_t_value);
}
inline bool ActorTableData_ActorState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActorTableData_ActorState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActorTableData_ActorState>(
    ActorTableData_ActorState_descriptor(), name, value);
}
enum GcsNodeInfo_GcsNodeState : int {
  GcsNodeInfo_GcsNodeState_ALIVE = 0,
  GcsNodeInfo_GcsNodeState_DEAD = 1,
  GcsNodeInfo_GcsNodeState_GcsNodeInfo_GcsNodeState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GcsNodeInfo_GcsNodeState_GcsNodeInfo_GcsNodeState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GcsNodeInfo_GcsNodeState_IsValid(int value);
constexpr GcsNodeInfo_GcsNodeState GcsNodeInfo_GcsNodeState_GcsNodeState_MIN = GcsNodeInfo_GcsNodeState_ALIVE;
constexpr GcsNodeInfo_GcsNodeState GcsNodeInfo_GcsNodeState_GcsNodeState_MAX = GcsNodeInfo_GcsNodeState_DEAD;
constexpr int GcsNodeInfo_GcsNodeState_GcsNodeState_ARRAYSIZE = GcsNodeInfo_GcsNodeState_GcsNodeState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GcsNodeInfo_GcsNodeState_descriptor();
template<typename T>
inline const std::string& GcsNodeInfo_GcsNodeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GcsNodeInfo_GcsNodeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GcsNodeInfo_GcsNodeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GcsNodeInfo_GcsNodeState_descriptor(), enum_t_value);
}
inline bool GcsNodeInfo_GcsNodeState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GcsNodeInfo_GcsNodeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GcsNodeInfo_GcsNodeState>(
    GcsNodeInfo_GcsNodeState_descriptor(), name, value);
}
enum JobConfig_ActorLifetime : int {
  JobConfig_ActorLifetime_DETACHED = 0,
  JobConfig_ActorLifetime_NON_DETACHED = 1,
  JobConfig_ActorLifetime_JobConfig_ActorLifetime_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JobConfig_ActorLifetime_JobConfig_ActorLifetime_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JobConfig_ActorLifetime_IsValid(int value);
constexpr JobConfig_ActorLifetime JobConfig_ActorLifetime_ActorLifetime_MIN = JobConfig_ActorLifetime_DETACHED;
constexpr JobConfig_ActorLifetime JobConfig_ActorLifetime_ActorLifetime_MAX = JobConfig_ActorLifetime_NON_DETACHED;
constexpr int JobConfig_ActorLifetime_ActorLifetime_ARRAYSIZE = JobConfig_ActorLifetime_ActorLifetime_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobConfig_ActorLifetime_descriptor();
template<typename T>
inline const std::string& JobConfig_ActorLifetime_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobConfig_ActorLifetime>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobConfig_ActorLifetime_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobConfig_ActorLifetime_descriptor(), enum_t_value);
}
inline bool JobConfig_ActorLifetime_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobConfig_ActorLifetime* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobConfig_ActorLifetime>(
    JobConfig_ActorLifetime_descriptor(), name, value);
}
enum PlacementGroupStats_SchedulingState : int {
  PlacementGroupStats_SchedulingState_QUEUED = 0,
  PlacementGroupStats_SchedulingState_REMOVED = 1,
  PlacementGroupStats_SchedulingState_SCHEDULING_STARTED = 2,
  PlacementGroupStats_SchedulingState_NO_RESOURCES = 3,
  PlacementGroupStats_SchedulingState_INFEASIBLE = 4,
  PlacementGroupStats_SchedulingState_FAILED_TO_COMMIT_RESOURCES = 5,
  PlacementGroupStats_SchedulingState_FINISHED = 6,
  PlacementGroupStats_SchedulingState_PlacementGroupStats_SchedulingState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlacementGroupStats_SchedulingState_PlacementGroupStats_SchedulingState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlacementGroupStats_SchedulingState_IsValid(int value);
constexpr PlacementGroupStats_SchedulingState PlacementGroupStats_SchedulingState_SchedulingState_MIN = PlacementGroupStats_SchedulingState_QUEUED;
constexpr PlacementGroupStats_SchedulingState PlacementGroupStats_SchedulingState_SchedulingState_MAX = PlacementGroupStats_SchedulingState_FINISHED;
constexpr int PlacementGroupStats_SchedulingState_SchedulingState_ARRAYSIZE = PlacementGroupStats_SchedulingState_SchedulingState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlacementGroupStats_SchedulingState_descriptor();
template<typename T>
inline const std::string& PlacementGroupStats_SchedulingState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlacementGroupStats_SchedulingState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlacementGroupStats_SchedulingState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlacementGroupStats_SchedulingState_descriptor(), enum_t_value);
}
inline bool PlacementGroupStats_SchedulingState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlacementGroupStats_SchedulingState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlacementGroupStats_SchedulingState>(
    PlacementGroupStats_SchedulingState_descriptor(), name, value);
}
enum PlacementGroupTableData_PlacementGroupState : int {
  PlacementGroupTableData_PlacementGroupState_PENDING = 0,
  PlacementGroupTableData_PlacementGroupState_CREATED = 1,
  PlacementGroupTableData_PlacementGroupState_REMOVED = 2,
  PlacementGroupTableData_PlacementGroupState_RESCHEDULING = 3,
  PlacementGroupTableData_PlacementGroupState_PlacementGroupTableData_PlacementGroupState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlacementGroupTableData_PlacementGroupState_PlacementGroupTableData_PlacementGroupState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlacementGroupTableData_PlacementGroupState_IsValid(int value);
constexpr PlacementGroupTableData_PlacementGroupState PlacementGroupTableData_PlacementGroupState_PlacementGroupState_MIN = PlacementGroupTableData_PlacementGroupState_PENDING;
constexpr PlacementGroupTableData_PlacementGroupState PlacementGroupTableData_PlacementGroupState_PlacementGroupState_MAX = PlacementGroupTableData_PlacementGroupState_RESCHEDULING;
constexpr int PlacementGroupTableData_PlacementGroupState_PlacementGroupState_ARRAYSIZE = PlacementGroupTableData_PlacementGroupState_PlacementGroupState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlacementGroupTableData_PlacementGroupState_descriptor();
template<typename T>
inline const std::string& PlacementGroupTableData_PlacementGroupState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlacementGroupTableData_PlacementGroupState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlacementGroupTableData_PlacementGroupState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlacementGroupTableData_PlacementGroupState_descriptor(), enum_t_value);
}
inline bool PlacementGroupTableData_PlacementGroupState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlacementGroupTableData_PlacementGroupState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlacementGroupTableData_PlacementGroupState>(
    PlacementGroupTableData_PlacementGroupState_descriptor(), name, value);
}
enum TablePrefix : int {
  TABLE_PREFIX_MIN = 0,
  UNUSED = 1,
  TASK = 2,
  MCSLET_TASK = 3,
  NODE = 4,
  OBJECT = 5,
  ACTOR = 6,
  FUNCTION = 7,
  TASK_RECONSTRUCTION = 8,
  RESOURCE_USAGE_BATCH = 9,
  JOB = 10,
  TASK_LEASE = 12,
  NODE_RESOURCE = 13,
  DIRECT_ACTOR = 14,
  WORKERS = 15,
  INTERNAL_CONFIG = 16,
  PLACEMENT_GROUP_SCHEDULE = 17,
  PLACEMENT_GROUP = 18,
  KV = 19,
  ACTOR_TASK_SPEC = 20,
  TablePrefix_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TablePrefix_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TablePrefix_IsValid(int value);
constexpr TablePrefix TablePrefix_MIN = TABLE_PREFIX_MIN;
constexpr TablePrefix TablePrefix_MAX = ACTOR_TASK_SPEC;
constexpr int TablePrefix_ARRAYSIZE = TablePrefix_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TablePrefix_descriptor();
template<typename T>
inline const std::string& TablePrefix_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TablePrefix>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TablePrefix_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TablePrefix_descriptor(), enum_t_value);
}
inline bool TablePrefix_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TablePrefix* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TablePrefix>(
    TablePrefix_descriptor(), name, value);
}
enum TablePubsub : int {
  TABLE_PUBSUB_MIN = 0,
  NO_PUBLISH = 1,
  TASK_PUBSUB = 2,
  MCSLET_TASK_PUBSUB = 3,
  NODE_PUBSUB = 4,
  OBJECT_PUBSUB = 5,
  ACTOR_PUBSUB = 6,
  RESOURCE_USAGE_BATCH_PUBSUB = 7,
  TASK_LEASE_PUBSUB = 8,
  JOB_PUBSUB = 9,
  NODE_RESOURCE_PUBSUB = 10,
  DIRECT_ACTOR_PUBSUB = 11,
  WORKER_FAILURE_PUBSUB = 12,
  TABLE_PUBSUB_MAX = 13,
  TablePubsub_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TablePubsub_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TablePubsub_IsValid(int value);
constexpr TablePubsub TablePubsub_MIN = TABLE_PUBSUB_MIN;
constexpr TablePubsub TablePubsub_MAX = TABLE_PUBSUB_MAX;
constexpr int TablePubsub_ARRAYSIZE = TablePubsub_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TablePubsub_descriptor();
template<typename T>
inline const std::string& TablePubsub_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TablePubsub>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TablePubsub_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TablePubsub_descriptor(), enum_t_value);
}
inline bool TablePubsub_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TablePubsub* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TablePubsub>(
    TablePubsub_descriptor(), name, value);
}
enum GcsChangeMode : int {
  APPEND_OR_ADD = 0,
  REMOVE = 1,
  GcsChangeMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GcsChangeMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GcsChangeMode_IsValid(int value);
constexpr GcsChangeMode GcsChangeMode_MIN = APPEND_OR_ADD;
constexpr GcsChangeMode GcsChangeMode_MAX = REMOVE;
constexpr int GcsChangeMode_ARRAYSIZE = GcsChangeMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GcsChangeMode_descriptor();
template<typename T>
inline const std::string& GcsChangeMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GcsChangeMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GcsChangeMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GcsChangeMode_descriptor(), enum_t_value);
}
inline bool GcsChangeMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GcsChangeMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GcsChangeMode>(
    GcsChangeMode_descriptor(), name, value);
}
// ===================================================================

class GcsEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.GcsEntry) */ {
 public:
  inline GcsEntry() : GcsEntry(nullptr) {}
  ~GcsEntry() override;
  explicit constexpr GcsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcsEntry(const GcsEntry& from);
  GcsEntry(GcsEntry&& from) noexcept
    : GcsEntry() {
    *this = ::std::move(from);
  }

  inline GcsEntry& operator=(const GcsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcsEntry& operator=(GcsEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GcsEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const GcsEntry* internal_default_instance() {
    return reinterpret_cast<const GcsEntry*>(
               &_GcsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GcsEntry& a, GcsEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(GcsEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcsEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GcsEntry* New() const final {
    return new GcsEntry();
  }

  GcsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GcsEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GcsEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GcsEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GcsEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.GcsEntry";
  }
  protected:
  explicit GcsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kIdFieldNumber = 2,
    kChangeModeFieldNumber = 1,
  };
  // repeated bytes entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  const std::string& entries(int index) const;
  std::string* mutable_entries(int index);
  void set_entries(int index, const std::string& value);
  void set_entries(int index, std::string&& value);
  void set_entries(int index, const char* value);
  void set_entries(int index, const void* value, size_t size);
  std::string* add_entries();
  void add_entries(const std::string& value);
  void add_entries(std::string&& value);
  void add_entries(const char* value);
  void add_entries(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& entries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_entries();
  private:
  const std::string& _internal_entries(int index) const;
  std::string* _internal_add_entries();
  public:

  // bytes id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .mcs.rpc.GcsChangeMode change_mode = 1;
  void clear_change_mode();
  ::mcs::rpc::GcsChangeMode change_mode() const;
  void set_change_mode(::mcs::rpc::GcsChangeMode value);
  private:
  ::mcs::rpc::GcsChangeMode _internal_change_mode() const;
  void _internal_set_change_mode(::mcs::rpc::GcsChangeMode value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.GcsEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int change_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ObjectTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ObjectTableData) */ {
 public:
  inline ObjectTableData() : ObjectTableData(nullptr) {}
  ~ObjectTableData() override;
  explicit constexpr ObjectTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectTableData(const ObjectTableData& from);
  ObjectTableData(ObjectTableData&& from) noexcept
    : ObjectTableData() {
    *this = ::std::move(from);
  }

  inline ObjectTableData& operator=(const ObjectTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectTableData& operator=(ObjectTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectTableData* internal_default_instance() {
    return reinterpret_cast<const ObjectTableData*>(
               &_ObjectTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ObjectTableData& a, ObjectTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectTableData* New() const final {
    return new ObjectTableData();
  }

  ObjectTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ObjectTableData";
  }
  protected:
  explicit ObjectTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManagerFieldNumber = 1,
  };
  // bytes manager = 1;
  void clear_manager();
  const std::string& manager() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manager(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manager();
  PROTOBUF_MUST_USE_RESULT std::string* release_manager();
  void set_allocated_manager(std::string* manager);
  private:
  const std::string& _internal_manager() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manager(const std::string& value);
  std::string* _internal_mutable_manager();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ObjectTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manager_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ActorTableData_RequiredResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ActorTableData_RequiredResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ActorTableData_RequiredResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ActorTableData_RequiredResourcesEntry_DoNotUse();
  explicit constexpr ActorTableData_RequiredResourcesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ActorTableData_RequiredResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ActorTableData_RequiredResourcesEntry_DoNotUse& other);
  static const ActorTableData_RequiredResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ActorTableData_RequiredResourcesEntry_DoNotUse*>(&_ActorTableData_RequiredResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ActorTableData.RequiredResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ActorTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ActorTableData) */ {
 public:
  inline ActorTableData() : ActorTableData(nullptr) {}
  ~ActorTableData() override;
  explicit constexpr ActorTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActorTableData(const ActorTableData& from);
  ActorTableData(ActorTableData&& from) noexcept
    : ActorTableData() {
    *this = ::std::move(from);
  }

  inline ActorTableData& operator=(const ActorTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorTableData& operator=(ActorTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActorTableData* internal_default_instance() {
    return reinterpret_cast<const ActorTableData*>(
               &_ActorTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ActorTableData& a, ActorTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorTableData* New() const final {
    return new ActorTableData();
  }

  ActorTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActorTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActorTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ActorTableData";
  }
  protected:
  explicit ActorTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ActorTableData_ActorState ActorState;
  static constexpr ActorState DEPENDENCIES_UNREADY =
    ActorTableData_ActorState_DEPENDENCIES_UNREADY;
  static constexpr ActorState PENDING_CREATION =
    ActorTableData_ActorState_PENDING_CREATION;
  static constexpr ActorState ALIVE =
    ActorTableData_ActorState_ALIVE;
  static constexpr ActorState RESTARTING =
    ActorTableData_ActorState_RESTARTING;
  static constexpr ActorState DEAD =
    ActorTableData_ActorState_DEAD;
  static inline bool ActorState_IsValid(int value) {
    return ActorTableData_ActorState_IsValid(value);
  }
  static constexpr ActorState ActorState_MIN =
    ActorTableData_ActorState_ActorState_MIN;
  static constexpr ActorState ActorState_MAX =
    ActorTableData_ActorState_ActorState_MAX;
  static constexpr int ActorState_ARRAYSIZE =
    ActorTableData_ActorState_ActorState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ActorState_descriptor() {
    return ActorTableData_ActorState_descriptor();
  }
  template<typename T>
  static inline const std::string& ActorState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActorState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActorState_Name.");
    return ActorTableData_ActorState_Name(enum_t_value);
  }
  static inline bool ActorState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ActorState* value) {
    return ActorTableData_ActorState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResourceMappingFieldNumber = 15,
    kRequiredResourcesFieldNumber = 28,
    kActorIdFieldNumber = 1,
    kParentIdFieldNumber = 2,
    kActorCreationDummyObjectIdFieldNumber = 3,
    kJobIdFieldNumber = 4,
    kNameFieldNumber = 12,
    kMcsNamespaceFieldNumber = 19,
    kSerializedRuntimeEnvFieldNumber = 22,
    kClassNameFieldNumber = 23,
    kNodeIdFieldNumber = 29,
    kAddressFieldNumber = 9,
    kOwnerAddressFieldNumber = 10,
    kFunctionDescriptorFieldNumber = 17,
    kDeathCauseFieldNumber = 24,
    kMaxRestartsFieldNumber = 7,
    kNumRestartsFieldNumber = 8,
    kStateFieldNumber = 6,
    kIsDetachedFieldNumber = 11,
    kTimestampFieldNumber = 13,
    kStartTimeFieldNumber = 20,
    kEndTimeFieldNumber = 21,
    kPidFieldNumber = 16,
  };
  // repeated .mcs.rpc.ResourceMapEntry resource_mapping = 15;
  int resource_mapping_size() const;
  private:
  int _internal_resource_mapping_size() const;
  public:
  void clear_resource_mapping();
  ::mcs::rpc::ResourceMapEntry* mutable_resource_mapping(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceMapEntry >*
      mutable_resource_mapping();
  private:
  const ::mcs::rpc::ResourceMapEntry& _internal_resource_mapping(int index) const;
  ::mcs::rpc::ResourceMapEntry* _internal_add_resource_mapping();
  public:
  const ::mcs::rpc::ResourceMapEntry& resource_mapping(int index) const;
  ::mcs::rpc::ResourceMapEntry* add_resource_mapping();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceMapEntry >&
      resource_mapping() const;

  // map<string, double> required_resources = 28;
  int required_resources_size() const;
  private:
  int _internal_required_resources_size() const;
  public:
  void clear_required_resources();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_required_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_required_resources();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      required_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_required_resources();

  // bytes actor_id = 1;
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // bytes parent_id = 2;
  void clear_parent_id();
  const std::string& parent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // bytes actor_creation_dummy_object_id = 3;
  void clear_actor_creation_dummy_object_id();
  const std::string& actor_creation_dummy_object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_creation_dummy_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_creation_dummy_object_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_creation_dummy_object_id();
  void set_allocated_actor_creation_dummy_object_id(std::string* actor_creation_dummy_object_id);
  private:
  const std::string& _internal_actor_creation_dummy_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_creation_dummy_object_id(const std::string& value);
  std::string* _internal_mutable_actor_creation_dummy_object_id();
  public:

  // bytes job_id = 4;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string name = 12;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mcs_namespace = 19;
  void clear_mcs_namespace();
  const std::string& mcs_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcs_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcs_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcs_namespace();
  void set_allocated_mcs_namespace(std::string* mcs_namespace);
  private:
  const std::string& _internal_mcs_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcs_namespace(const std::string& value);
  std::string* _internal_mutable_mcs_namespace();
  public:

  // string serialized_runtime_env = 22;
  void clear_serialized_runtime_env();
  const std::string& serialized_runtime_env() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_runtime_env(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_runtime_env();
  PROTOBUF_MUST_USE_RESULT std::string* release_serialized_runtime_env();
  void set_allocated_serialized_runtime_env(std::string* serialized_runtime_env);
  private:
  const std::string& _internal_serialized_runtime_env() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_runtime_env(const std::string& value);
  std::string* _internal_mutable_serialized_runtime_env();
  public:

  // string class_name = 23;
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // optional bytes node_id = 29;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // .mcs.rpc.Address address = 9;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::mcs::rpc::Address& address() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::Address* release_address();
  ::mcs::rpc::Address* mutable_address();
  void set_allocated_address(::mcs::rpc::Address* address);
  private:
  const ::mcs::rpc::Address& _internal_address() const;
  ::mcs::rpc::Address* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::mcs::rpc::Address* address);
  ::mcs::rpc::Address* unsafe_arena_release_address();

  // .mcs.rpc.Address owner_address = 10;
  bool has_owner_address() const;
  private:
  bool _internal_has_owner_address() const;
  public:
  void clear_owner_address();
  const ::mcs::rpc::Address& owner_address() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::Address* release_owner_address();
  ::mcs::rpc::Address* mutable_owner_address();
  void set_allocated_owner_address(::mcs::rpc::Address* owner_address);
  private:
  const ::mcs::rpc::Address& _internal_owner_address() const;
  ::mcs::rpc::Address* _internal_mutable_owner_address();
  public:
  void unsafe_arena_set_allocated_owner_address(
      ::mcs::rpc::Address* owner_address);
  ::mcs::rpc::Address* unsafe_arena_release_owner_address();

  // .mcs.rpc.FunctionDescriptor function_descriptor = 17;
  bool has_function_descriptor() const;
  private:
  bool _internal_has_function_descriptor() const;
  public:
  void clear_function_descriptor();
  const ::mcs::rpc::FunctionDescriptor& function_descriptor() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::FunctionDescriptor* release_function_descriptor();
  ::mcs::rpc::FunctionDescriptor* mutable_function_descriptor();
  void set_allocated_function_descriptor(::mcs::rpc::FunctionDescriptor* function_descriptor);
  private:
  const ::mcs::rpc::FunctionDescriptor& _internal_function_descriptor() const;
  ::mcs::rpc::FunctionDescriptor* _internal_mutable_function_descriptor();
  public:
  void unsafe_arena_set_allocated_function_descriptor(
      ::mcs::rpc::FunctionDescriptor* function_descriptor);
  ::mcs::rpc::FunctionDescriptor* unsafe_arena_release_function_descriptor();

  // .mcs.rpc.ActorDeathCause death_cause = 24;
  bool has_death_cause() const;
  private:
  bool _internal_has_death_cause() const;
  public:
  void clear_death_cause();
  const ::mcs::rpc::ActorDeathCause& death_cause() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ActorDeathCause* release_death_cause();
  ::mcs::rpc::ActorDeathCause* mutable_death_cause();
  void set_allocated_death_cause(::mcs::rpc::ActorDeathCause* death_cause);
  private:
  const ::mcs::rpc::ActorDeathCause& _internal_death_cause() const;
  ::mcs::rpc::ActorDeathCause* _internal_mutable_death_cause();
  public:
  void unsafe_arena_set_allocated_death_cause(
      ::mcs::rpc::ActorDeathCause* death_cause);
  ::mcs::rpc::ActorDeathCause* unsafe_arena_release_death_cause();

  // int64 max_restarts = 7;
  void clear_max_restarts();
  ::PROTOBUF_NAMESPACE_ID::int64 max_restarts() const;
  void set_max_restarts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_restarts() const;
  void _internal_set_max_restarts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint64 num_restarts = 8;
  void clear_num_restarts();
  ::PROTOBUF_NAMESPACE_ID::uint64 num_restarts() const;
  void set_num_restarts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_num_restarts() const;
  void _internal_set_num_restarts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .mcs.rpc.ActorTableData.ActorState state = 6;
  void clear_state();
  ::mcs::rpc::ActorTableData_ActorState state() const;
  void set_state(::mcs::rpc::ActorTableData_ActorState value);
  private:
  ::mcs::rpc::ActorTableData_ActorState _internal_state() const;
  void _internal_set_state(::mcs::rpc::ActorTableData_ActorState value);
  public:

  // bool is_detached = 11;
  void clear_is_detached();
  bool is_detached() const;
  void set_is_detached(bool value);
  private:
  bool _internal_is_detached() const;
  void _internal_set_is_detached(bool value);
  public:

  // double timestamp = 13;
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // uint64 start_time = 20;
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 end_time = 21;
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_time() const;
  void _internal_set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 pid = 16;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ActorTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceMapEntry > resource_mapping_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ActorTableData_RequiredResourcesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> required_resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_creation_dummy_object_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcs_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_runtime_env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::mcs::rpc::Address* address_;
  ::mcs::rpc::Address* owner_address_;
  ::mcs::rpc::FunctionDescriptor* function_descriptor_;
  ::mcs::rpc::ActorDeathCause* death_cause_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_restarts_;
  ::PROTOBUF_NAMESPACE_ID::uint64 num_restarts_;
  int state_;
  bool is_detached_;
  double timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ErrorTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ErrorTableData) */ {
 public:
  inline ErrorTableData() : ErrorTableData(nullptr) {}
  ~ErrorTableData() override;
  explicit constexpr ErrorTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorTableData(const ErrorTableData& from);
  ErrorTableData(ErrorTableData&& from) noexcept
    : ErrorTableData() {
    *this = ::std::move(from);
  }

  inline ErrorTableData& operator=(const ErrorTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorTableData& operator=(ErrorTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorTableData* internal_default_instance() {
    return reinterpret_cast<const ErrorTableData*>(
               &_ErrorTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ErrorTableData& a, ErrorTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorTableData* New() const final {
    return new ErrorTableData();
  }

  ErrorTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ErrorTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ErrorTableData";
  }
  protected:
  explicit ErrorTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kTimestampFieldNumber = 4,
  };
  // bytes job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // double timestamp = 4;
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ErrorTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  double timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ScheduleData_SchedulePlanEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ScheduleData_SchedulePlanEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ScheduleData_SchedulePlanEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ScheduleData_SchedulePlanEntry_DoNotUse();
  explicit constexpr ScheduleData_SchedulePlanEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ScheduleData_SchedulePlanEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ScheduleData_SchedulePlanEntry_DoNotUse& other);
  static const ScheduleData_SchedulePlanEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ScheduleData_SchedulePlanEntry_DoNotUse*>(&_ScheduleData_SchedulePlanEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ScheduleData.SchedulePlanEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ScheduleData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ScheduleData) */ {
 public:
  inline ScheduleData() : ScheduleData(nullptr) {}
  ~ScheduleData() override;
  explicit constexpr ScheduleData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleData(const ScheduleData& from);
  ScheduleData(ScheduleData&& from) noexcept
    : ScheduleData() {
    *this = ::std::move(from);
  }

  inline ScheduleData& operator=(const ScheduleData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleData& operator=(ScheduleData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleData* internal_default_instance() {
    return reinterpret_cast<const ScheduleData*>(
               &_ScheduleData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ScheduleData& a, ScheduleData& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScheduleData* New() const final {
    return new ScheduleData();
  }

  ScheduleData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScheduleData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScheduleData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ScheduleData";
  }
  protected:
  explicit ScheduleData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSchedulePlanFieldNumber = 1,
  };
  // map<string, bytes> schedule_plan = 1;
  int schedule_plan_size() const;
  private:
  int _internal_schedule_plan_size() const;
  public:
  void clear_schedule_plan();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_schedule_plan() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_schedule_plan();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      schedule_plan() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_schedule_plan();

  // @@protoc_insertion_point(class_scope:mcs.rpc.ScheduleData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ScheduleData_SchedulePlanEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> schedule_plan_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ProfileEventEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ProfileEventEntry) */ {
 public:
  inline ProfileEventEntry() : ProfileEventEntry(nullptr) {}
  ~ProfileEventEntry() override;
  explicit constexpr ProfileEventEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileEventEntry(const ProfileEventEntry& from);
  ProfileEventEntry(ProfileEventEntry&& from) noexcept
    : ProfileEventEntry() {
    *this = ::std::move(from);
  }

  inline ProfileEventEntry& operator=(const ProfileEventEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileEventEntry& operator=(ProfileEventEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProfileEventEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileEventEntry* internal_default_instance() {
    return reinterpret_cast<const ProfileEventEntry*>(
               &_ProfileEventEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProfileEventEntry& a, ProfileEventEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileEventEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileEventEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProfileEventEntry* New() const final {
    return new ProfileEventEntry();
  }

  ProfileEventEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileEventEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProfileEventEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProfileEventEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileEventEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ProfileEventEntry";
  }
  protected:
  explicit ProfileEventEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 3,
    kEventNameFieldNumber = 4,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // optional string extra_data = 3;
  bool has_extra_data() const;
  private:
  bool _internal_has_extra_data() const;
  public:
  void clear_extra_data();
  const std::string& extra_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_extra_data();
  void set_allocated_extra_data(std::string* extra_data);
  private:
  const std::string& _internal_extra_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_data(const std::string& value);
  std::string* _internal_mutable_extra_data();
  public:

  // string event_name = 4;
  void clear_event_name();
  const std::string& event_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_event_name();
  void set_allocated_event_name(std::string* event_name);
  private:
  const std::string& _internal_event_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_name(const std::string& value);
  std::string* _internal_mutable_event_name();
  public:

  // int64 start_time = 1;
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end_time = 2;
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::int64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_time() const;
  void _internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ProfileEventEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_time_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ProfileEvents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ProfileEvents) */ {
 public:
  inline ProfileEvents() : ProfileEvents(nullptr) {}
  ~ProfileEvents() override;
  explicit constexpr ProfileEvents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileEvents(const ProfileEvents& from);
  ProfileEvents(ProfileEvents&& from) noexcept
    : ProfileEvents() {
    *this = ::std::move(from);
  }

  inline ProfileEvents& operator=(const ProfileEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileEvents& operator=(ProfileEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProfileEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileEvents* internal_default_instance() {
    return reinterpret_cast<const ProfileEvents*>(
               &_ProfileEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProfileEvents& a, ProfileEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileEvents* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileEvents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProfileEvents* New() const final {
    return new ProfileEvents();
  }

  ProfileEvents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileEvents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProfileEvents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProfileEvents& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileEvents* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ProfileEvents";
  }
  protected:
  explicit ProfileEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 4,
    kComponentTypeFieldNumber = 1,
    kComponentIdFieldNumber = 2,
    kNodeIpAddressFieldNumber = 3,
  };
  // repeated .mcs.rpc.ProfileEventEntry events = 4;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::mcs::rpc::ProfileEventEntry* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ProfileEventEntry >*
      mutable_events();
  private:
  const ::mcs::rpc::ProfileEventEntry& _internal_events(int index) const;
  ::mcs::rpc::ProfileEventEntry* _internal_add_events();
  public:
  const ::mcs::rpc::ProfileEventEntry& events(int index) const;
  ::mcs::rpc::ProfileEventEntry* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ProfileEventEntry >&
      events() const;

  // string component_type = 1;
  void clear_component_type();
  const std::string& component_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_component_type();
  void set_allocated_component_type(std::string* component_type);
  private:
  const std::string& _internal_component_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_type(const std::string& value);
  std::string* _internal_mutable_component_type();
  public:

  // bytes component_id = 2;
  void clear_component_id();
  const std::string& component_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_component_id();
  void set_allocated_component_id(std::string* component_id);
  private:
  const std::string& _internal_component_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_id(const std::string& value);
  std::string* _internal_mutable_component_id();
  public:

  // string node_ip_address = 3;
  void clear_node_ip_address();
  const std::string& node_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_ip_address();
  void set_allocated_node_ip_address(std::string* node_ip_address);
  private:
  const std::string& _internal_node_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_ip_address(const std::string& value);
  std::string* _internal_mutable_node_ip_address();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ProfileEvents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ProfileEventEntry > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_ip_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class TaskStateUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.TaskStateUpdate) */ {
 public:
  inline TaskStateUpdate() : TaskStateUpdate(nullptr) {}
  ~TaskStateUpdate() override;
  explicit constexpr TaskStateUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskStateUpdate(const TaskStateUpdate& from);
  TaskStateUpdate(TaskStateUpdate&& from) noexcept
    : TaskStateUpdate() {
    *this = ::std::move(from);
  }

  inline TaskStateUpdate& operator=(const TaskStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskStateUpdate& operator=(TaskStateUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskStateUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskStateUpdate* internal_default_instance() {
    return reinterpret_cast<const TaskStateUpdate*>(
               &_TaskStateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TaskStateUpdate& a, TaskStateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskStateUpdate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskStateUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskStateUpdate* New() const final {
    return new TaskStateUpdate();
  }

  TaskStateUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskStateUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskStateUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskStateUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskStateUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.TaskStateUpdate";
  }
  protected:
  explicit TaskStateUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kPendingArgsAvailTsFieldNumber = 2,
    kPendingNodeAssignmentTsFieldNumber = 3,
    kSubmittedToWorkerTsFieldNumber = 4,
    kRunningTsFieldNumber = 5,
    kFinishedTsFieldNumber = 6,
    kFailedTsFieldNumber = 7,
  };
  // optional bytes node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // optional int64 pending_args_avail_ts = 2;
  bool has_pending_args_avail_ts() const;
  private:
  bool _internal_has_pending_args_avail_ts() const;
  public:
  void clear_pending_args_avail_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 pending_args_avail_ts() const;
  void set_pending_args_avail_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pending_args_avail_ts() const;
  void _internal_set_pending_args_avail_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 pending_node_assignment_ts = 3;
  bool has_pending_node_assignment_ts() const;
  private:
  bool _internal_has_pending_node_assignment_ts() const;
  public:
  void clear_pending_node_assignment_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 pending_node_assignment_ts() const;
  void set_pending_node_assignment_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pending_node_assignment_ts() const;
  void _internal_set_pending_node_assignment_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 submitted_to_worker_ts = 4;
  bool has_submitted_to_worker_ts() const;
  private:
  bool _internal_has_submitted_to_worker_ts() const;
  public:
  void clear_submitted_to_worker_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 submitted_to_worker_ts() const;
  void set_submitted_to_worker_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_submitted_to_worker_ts() const;
  void _internal_set_submitted_to_worker_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 running_ts = 5;
  bool has_running_ts() const;
  private:
  bool _internal_has_running_ts() const;
  public:
  void clear_running_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 running_ts() const;
  void set_running_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_running_ts() const;
  void _internal_set_running_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 finished_ts = 6;
  bool has_finished_ts() const;
  private:
  bool _internal_has_finished_ts() const;
  public:
  void clear_finished_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 finished_ts() const;
  void set_finished_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_finished_ts() const;
  void _internal_set_finished_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 failed_ts = 7;
  bool has_failed_ts() const;
  private:
  bool _internal_has_failed_ts() const;
  public:
  void clear_failed_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 failed_ts() const;
  void set_failed_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_failed_ts() const;
  void _internal_set_failed_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.TaskStateUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 pending_args_avail_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 pending_node_assignment_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 submitted_to_worker_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 running_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 finished_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 failed_ts_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class TaskEvents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.TaskEvents) */ {
 public:
  inline TaskEvents() : TaskEvents(nullptr) {}
  ~TaskEvents() override;
  explicit constexpr TaskEvents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskEvents(const TaskEvents& from);
  TaskEvents(TaskEvents&& from) noexcept
    : TaskEvents() {
    *this = ::std::move(from);
  }

  inline TaskEvents& operator=(const TaskEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskEvents& operator=(TaskEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskEvents* internal_default_instance() {
    return reinterpret_cast<const TaskEvents*>(
               &_TaskEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TaskEvents& a, TaskEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskEvents* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskEvents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskEvents* New() const final {
    return new TaskEvents();
  }

  TaskEvents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskEvents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskEvents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskEvents& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskEvents* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.TaskEvents";
  }
  protected:
  explicit TaskEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kJobIdFieldNumber = 6,
    kTaskInfoFieldNumber = 3,
    kStateUpdatesFieldNumber = 4,
    kProfileEventsFieldNumber = 5,
    kAttemptNumberFieldNumber = 2,
  };
  // bytes task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // bytes job_id = 6;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // optional .mcs.rpc.TaskInfoEntry task_info = 3;
  bool has_task_info() const;
  private:
  bool _internal_has_task_info() const;
  public:
  void clear_task_info();
  const ::mcs::rpc::TaskInfoEntry& task_info() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::TaskInfoEntry* release_task_info();
  ::mcs::rpc::TaskInfoEntry* mutable_task_info();
  void set_allocated_task_info(::mcs::rpc::TaskInfoEntry* task_info);
  private:
  const ::mcs::rpc::TaskInfoEntry& _internal_task_info() const;
  ::mcs::rpc::TaskInfoEntry* _internal_mutable_task_info();
  public:
  void unsafe_arena_set_allocated_task_info(
      ::mcs::rpc::TaskInfoEntry* task_info);
  ::mcs::rpc::TaskInfoEntry* unsafe_arena_release_task_info();

  // optional .mcs.rpc.TaskStateUpdate state_updates = 4;
  bool has_state_updates() const;
  private:
  bool _internal_has_state_updates() const;
  public:
  void clear_state_updates();
  const ::mcs::rpc::TaskStateUpdate& state_updates() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::TaskStateUpdate* release_state_updates();
  ::mcs::rpc::TaskStateUpdate* mutable_state_updates();
  void set_allocated_state_updates(::mcs::rpc::TaskStateUpdate* state_updates);
  private:
  const ::mcs::rpc::TaskStateUpdate& _internal_state_updates() const;
  ::mcs::rpc::TaskStateUpdate* _internal_mutable_state_updates();
  public:
  void unsafe_arena_set_allocated_state_updates(
      ::mcs::rpc::TaskStateUpdate* state_updates);
  ::mcs::rpc::TaskStateUpdate* unsafe_arena_release_state_updates();

  // optional .mcs.rpc.ProfileEvents profile_events = 5;
  bool has_profile_events() const;
  private:
  bool _internal_has_profile_events() const;
  public:
  void clear_profile_events();
  const ::mcs::rpc::ProfileEvents& profile_events() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ProfileEvents* release_profile_events();
  ::mcs::rpc::ProfileEvents* mutable_profile_events();
  void set_allocated_profile_events(::mcs::rpc::ProfileEvents* profile_events);
  private:
  const ::mcs::rpc::ProfileEvents& _internal_profile_events() const;
  ::mcs::rpc::ProfileEvents* _internal_mutable_profile_events();
  public:
  void unsafe_arena_set_allocated_profile_events(
      ::mcs::rpc::ProfileEvents* profile_events);
  ::mcs::rpc::ProfileEvents* unsafe_arena_release_profile_events();

  // int32 attempt_number = 2;
  void clear_attempt_number();
  ::PROTOBUF_NAMESPACE_ID::int32 attempt_number() const;
  void set_attempt_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attempt_number() const;
  void _internal_set_attempt_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.TaskEvents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::mcs::rpc::TaskInfoEntry* task_info_;
  ::mcs::rpc::TaskStateUpdate* state_updates_;
  ::mcs::rpc::ProfileEvents* profile_events_;
  ::PROTOBUF_NAMESPACE_ID::int32 attempt_number_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class TaskEventData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.TaskEventData) */ {
 public:
  inline TaskEventData() : TaskEventData(nullptr) {}
  ~TaskEventData() override;
  explicit constexpr TaskEventData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskEventData(const TaskEventData& from);
  TaskEventData(TaskEventData&& from) noexcept
    : TaskEventData() {
    *this = ::std::move(from);
  }

  inline TaskEventData& operator=(const TaskEventData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskEventData& operator=(TaskEventData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskEventData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskEventData* internal_default_instance() {
    return reinterpret_cast<const TaskEventData*>(
               &_TaskEventData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TaskEventData& a, TaskEventData& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskEventData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskEventData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskEventData* New() const final {
    return new TaskEventData();
  }

  TaskEventData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskEventData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskEventData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskEventData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskEventData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.TaskEventData";
  }
  protected:
  explicit TaskEventData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsByTaskFieldNumber = 1,
    kNumProfileTaskEventsDroppedFieldNumber = 3,
    kNumStatusTaskEventsDroppedFieldNumber = 4,
  };
  // repeated .mcs.rpc.TaskEvents events_by_task = 1;
  int events_by_task_size() const;
  private:
  int _internal_events_by_task_size() const;
  public:
  void clear_events_by_task();
  ::mcs::rpc::TaskEvents* mutable_events_by_task(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskEvents >*
      mutable_events_by_task();
  private:
  const ::mcs::rpc::TaskEvents& _internal_events_by_task(int index) const;
  ::mcs::rpc::TaskEvents* _internal_add_events_by_task();
  public:
  const ::mcs::rpc::TaskEvents& events_by_task(int index) const;
  ::mcs::rpc::TaskEvents* add_events_by_task();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskEvents >&
      events_by_task() const;

  // int32 num_profile_task_events_dropped = 3;
  void clear_num_profile_task_events_dropped();
  ::PROTOBUF_NAMESPACE_ID::int32 num_profile_task_events_dropped() const;
  void set_num_profile_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_profile_task_events_dropped() const;
  void _internal_set_num_profile_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_status_task_events_dropped = 4;
  void clear_num_status_task_events_dropped();
  ::PROTOBUF_NAMESPACE_ID::int32 num_status_task_events_dropped() const;
  void set_num_status_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_status_task_events_dropped() const;
  void _internal_set_num_status_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.TaskEventData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskEvents > events_by_task_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_profile_task_events_dropped_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_status_task_events_dropped_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourceTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceTableData) */ {
 public:
  inline ResourceTableData() : ResourceTableData(nullptr) {}
  ~ResourceTableData() override;
  explicit constexpr ResourceTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceTableData(const ResourceTableData& from);
  ResourceTableData(ResourceTableData&& from) noexcept
    : ResourceTableData() {
    *this = ::std::move(from);
  }

  inline ResourceTableData& operator=(const ResourceTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceTableData& operator=(ResourceTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceTableData* internal_default_instance() {
    return reinterpret_cast<const ResourceTableData*>(
               &_ResourceTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResourceTableData& a, ResourceTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceTableData* New() const final {
    return new ResourceTableData();
  }

  ResourceTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceTableData";
  }
  protected:
  explicit ResourceTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceCapacityFieldNumber = 1,
  };
  // double resource_capacity = 1;
  void clear_resource_capacity();
  double resource_capacity() const;
  void set_resource_capacity(double value);
  private:
  double _internal_resource_capacity() const;
  void _internal_set_resource_capacity(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double resource_capacity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class AvailableResources_ResourcesAvailableEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AvailableResources_ResourcesAvailableEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AvailableResources_ResourcesAvailableEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  AvailableResources_ResourcesAvailableEntry_DoNotUse();
  explicit constexpr AvailableResources_ResourcesAvailableEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AvailableResources_ResourcesAvailableEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AvailableResources_ResourcesAvailableEntry_DoNotUse& other);
  static const AvailableResources_ResourcesAvailableEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AvailableResources_ResourcesAvailableEntry_DoNotUse*>(&_AvailableResources_ResourcesAvailableEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.AvailableResources.ResourcesAvailableEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AvailableResources final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.AvailableResources) */ {
 public:
  inline AvailableResources() : AvailableResources(nullptr) {}
  ~AvailableResources() override;
  explicit constexpr AvailableResources(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailableResources(const AvailableResources& from);
  AvailableResources(AvailableResources&& from) noexcept
    : AvailableResources() {
    *this = ::std::move(from);
  }

  inline AvailableResources& operator=(const AvailableResources& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailableResources& operator=(AvailableResources&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailableResources& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailableResources* internal_default_instance() {
    return reinterpret_cast<const AvailableResources*>(
               &_AvailableResources_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AvailableResources& a, AvailableResources& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailableResources* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailableResources* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AvailableResources* New() const final {
    return new AvailableResources();
  }

  AvailableResources* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AvailableResources>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvailableResources& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AvailableResources& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvailableResources* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.AvailableResources";
  }
  protected:
  explicit AvailableResources(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResourcesAvailableFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // map<string, double> resources_available = 2;
  int resources_available_size() const;
  private:
  int _internal_resources_available_size() const;
  public:
  void clear_resources_available();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_resources_available() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_resources_available();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      resources_available() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_resources_available();

  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.AvailableResources)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AvailableResources_ResourcesAvailableEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> resources_available_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class GcsNodeInfo_ResourcesTotalEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GcsNodeInfo_ResourcesTotalEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GcsNodeInfo_ResourcesTotalEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  GcsNodeInfo_ResourcesTotalEntry_DoNotUse();
  explicit constexpr GcsNodeInfo_ResourcesTotalEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GcsNodeInfo_ResourcesTotalEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GcsNodeInfo_ResourcesTotalEntry_DoNotUse& other);
  static const GcsNodeInfo_ResourcesTotalEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GcsNodeInfo_ResourcesTotalEntry_DoNotUse*>(&_GcsNodeInfo_ResourcesTotalEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.GcsNodeInfo.ResourcesTotalEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GcsNodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.GcsNodeInfo) */ {
 public:
  inline GcsNodeInfo() : GcsNodeInfo(nullptr) {}
  ~GcsNodeInfo() override;
  explicit constexpr GcsNodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcsNodeInfo(const GcsNodeInfo& from);
  GcsNodeInfo(GcsNodeInfo&& from) noexcept
    : GcsNodeInfo() {
    *this = ::std::move(from);
  }

  inline GcsNodeInfo& operator=(const GcsNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcsNodeInfo& operator=(GcsNodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GcsNodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GcsNodeInfo* internal_default_instance() {
    return reinterpret_cast<const GcsNodeInfo*>(
               &_GcsNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GcsNodeInfo& a, GcsNodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GcsNodeInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcsNodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GcsNodeInfo* New() const final {
    return new GcsNodeInfo();
  }

  GcsNodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GcsNodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GcsNodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GcsNodeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GcsNodeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.GcsNodeInfo";
  }
  protected:
  explicit GcsNodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef GcsNodeInfo_GcsNodeState GcsNodeState;
  static constexpr GcsNodeState ALIVE =
    GcsNodeInfo_GcsNodeState_ALIVE;
  static constexpr GcsNodeState DEAD =
    GcsNodeInfo_GcsNodeState_DEAD;
  static inline bool GcsNodeState_IsValid(int value) {
    return GcsNodeInfo_GcsNodeState_IsValid(value);
  }
  static constexpr GcsNodeState GcsNodeState_MIN =
    GcsNodeInfo_GcsNodeState_GcsNodeState_MIN;
  static constexpr GcsNodeState GcsNodeState_MAX =
    GcsNodeInfo_GcsNodeState_GcsNodeState_MAX;
  static constexpr int GcsNodeState_ARRAYSIZE =
    GcsNodeInfo_GcsNodeState_GcsNodeState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GcsNodeState_descriptor() {
    return GcsNodeInfo_GcsNodeState_descriptor();
  }
  template<typename T>
  static inline const std::string& GcsNodeState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GcsNodeState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GcsNodeState_Name.");
    return GcsNodeInfo_GcsNodeState_Name(enum_t_value);
  }
  static inline bool GcsNodeState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GcsNodeState* value) {
    return GcsNodeInfo_GcsNodeState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesTotalFieldNumber = 11,
    kNodeIdFieldNumber = 1,
    kNodeManagerAddressFieldNumber = 2,
    kMcsletSocketNameFieldNumber = 3,
    kObjectStoreSocketNameFieldNumber = 4,
    kNodeManagerHostnameFieldNumber = 8,
    kNodeNameFieldNumber = 12,
    kNodeManagerPortFieldNumber = 5,
    kObjectManagerPortFieldNumber = 6,
    kStateFieldNumber = 7,
    kMetricsExportPortFieldNumber = 9,
    kTimestampFieldNumber = 10,
  };
  // map<string, double> resources_total = 11;
  int resources_total_size() const;
  private:
  int _internal_resources_total_size() const;
  public:
  void clear_resources_total();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_resources_total() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_resources_total();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      resources_total() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_resources_total();

  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // string node_manager_address = 2;
  void clear_node_manager_address();
  const std::string& node_manager_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_manager_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_manager_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_manager_address();
  void set_allocated_node_manager_address(std::string* node_manager_address);
  private:
  const std::string& _internal_node_manager_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_manager_address(const std::string& value);
  std::string* _internal_mutable_node_manager_address();
  public:

  // string mcslet_socket_name = 3;
  void clear_mcslet_socket_name();
  const std::string& mcslet_socket_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcslet_socket_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcslet_socket_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcslet_socket_name();
  void set_allocated_mcslet_socket_name(std::string* mcslet_socket_name);
  private:
  const std::string& _internal_mcslet_socket_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcslet_socket_name(const std::string& value);
  std::string* _internal_mutable_mcslet_socket_name();
  public:

  // string object_store_socket_name = 4;
  void clear_object_store_socket_name();
  const std::string& object_store_socket_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_store_socket_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_store_socket_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_object_store_socket_name();
  void set_allocated_object_store_socket_name(std::string* object_store_socket_name);
  private:
  const std::string& _internal_object_store_socket_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_store_socket_name(const std::string& value);
  std::string* _internal_mutable_object_store_socket_name();
  public:

  // string node_manager_hostname = 8;
  void clear_node_manager_hostname();
  const std::string& node_manager_hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_manager_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_manager_hostname();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_manager_hostname();
  void set_allocated_node_manager_hostname(std::string* node_manager_hostname);
  private:
  const std::string& _internal_node_manager_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_manager_hostname(const std::string& value);
  std::string* _internal_mutable_node_manager_hostname();
  public:

  // string node_name = 12;
  void clear_node_name();
  const std::string& node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // int32 node_manager_port = 5;
  void clear_node_manager_port();
  ::PROTOBUF_NAMESPACE_ID::int32 node_manager_port() const;
  void set_node_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_manager_port() const;
  void _internal_set_node_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 object_manager_port = 6;
  void clear_object_manager_port();
  ::PROTOBUF_NAMESPACE_ID::int32 object_manager_port() const;
  void set_object_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_object_manager_port() const;
  void _internal_set_object_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .mcs.rpc.GcsNodeInfo.GcsNodeState state = 7;
  void clear_state();
  ::mcs::rpc::GcsNodeInfo_GcsNodeState state() const;
  void set_state(::mcs::rpc::GcsNodeInfo_GcsNodeState value);
  private:
  ::mcs::rpc::GcsNodeInfo_GcsNodeState _internal_state() const;
  void _internal_set_state(::mcs::rpc::GcsNodeInfo_GcsNodeState value);
  public:

  // int32 metrics_export_port = 9;
  void clear_metrics_export_port();
  ::PROTOBUF_NAMESPACE_ID::int32 metrics_export_port() const;
  void set_metrics_export_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_metrics_export_port() const;
  void _internal_set_metrics_export_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 timestamp = 10;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.GcsNodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GcsNodeInfo_ResourcesTotalEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> resources_total_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_manager_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcslet_socket_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_store_socket_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_manager_hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_manager_port_;
  ::PROTOBUF_NAMESPACE_ID::int32 object_manager_port_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::int32 metrics_export_port_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.HeartbeatTableData) */ {
 public:
  inline HeartbeatTableData() : HeartbeatTableData(nullptr) {}
  ~HeartbeatTableData() override;
  explicit constexpr HeartbeatTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatTableData(const HeartbeatTableData& from);
  HeartbeatTableData(HeartbeatTableData&& from) noexcept
    : HeartbeatTableData() {
    *this = ::std::move(from);
  }

  inline HeartbeatTableData& operator=(const HeartbeatTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatTableData& operator=(HeartbeatTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatTableData* internal_default_instance() {
    return reinterpret_cast<const HeartbeatTableData*>(
               &_HeartbeatTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(HeartbeatTableData& a, HeartbeatTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatTableData* New() const final {
    return new HeartbeatTableData();
  }

  HeartbeatTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartbeatTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.HeartbeatTableData";
  }
  protected:
  explicit HeartbeatTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
  };
  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.HeartbeatTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class JobConfig_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobConfig_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JobConfig_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  JobConfig_MetadataEntry_DoNotUse();
  explicit constexpr JobConfig_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JobConfig_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JobConfig_MetadataEntry_DoNotUse& other);
  static const JobConfig_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JobConfig_MetadataEntry_DoNotUse*>(&_JobConfig_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.JobConfig.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.JobConfig.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class JobConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.JobConfig) */ {
 public:
  inline JobConfig() : JobConfig(nullptr) {}
  ~JobConfig() override;
  explicit constexpr JobConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobConfig(const JobConfig& from);
  JobConfig(JobConfig&& from) noexcept
    : JobConfig() {
    *this = ::std::move(from);
  }

  inline JobConfig& operator=(const JobConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobConfig& operator=(JobConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobConfig* internal_default_instance() {
    return reinterpret_cast<const JobConfig*>(
               &_JobConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(JobConfig& a, JobConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(JobConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JobConfig* New() const final {
    return new JobConfig();
  }

  JobConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JobConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JobConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.JobConfig";
  }
  protected:
  explicit JobConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef JobConfig_ActorLifetime ActorLifetime;
  static constexpr ActorLifetime DETACHED =
    JobConfig_ActorLifetime_DETACHED;
  static constexpr ActorLifetime NON_DETACHED =
    JobConfig_ActorLifetime_NON_DETACHED;
  static inline bool ActorLifetime_IsValid(int value) {
    return JobConfig_ActorLifetime_IsValid(value);
  }
  static constexpr ActorLifetime ActorLifetime_MIN =
    JobConfig_ActorLifetime_ActorLifetime_MIN;
  static constexpr ActorLifetime ActorLifetime_MAX =
    JobConfig_ActorLifetime_ActorLifetime_MAX;
  static constexpr int ActorLifetime_ARRAYSIZE =
    JobConfig_ActorLifetime_ActorLifetime_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ActorLifetime_descriptor() {
    return JobConfig_ActorLifetime_descriptor();
  }
  template<typename T>
  static inline const std::string& ActorLifetime_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActorLifetime>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActorLifetime_Name.");
    return JobConfig_ActorLifetime_Name(enum_t_value);
  }
  static inline bool ActorLifetime_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ActorLifetime* value) {
    return JobConfig_ActorLifetime_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJvmOptionsFieldNumber = 2,
    kCodeSearchPathFieldNumber = 3,
    kMetadataFieldNumber = 6,
    kMcsNamespaceFieldNumber = 5,
    kRuntimeEnvInfoFieldNumber = 4,
    kDefaultActorLifetimeFieldNumber = 7,
  };
  // repeated string jvm_options = 2;
  int jvm_options_size() const;
  private:
  int _internal_jvm_options_size() const;
  public:
  void clear_jvm_options();
  const std::string& jvm_options(int index) const;
  std::string* mutable_jvm_options(int index);
  void set_jvm_options(int index, const std::string& value);
  void set_jvm_options(int index, std::string&& value);
  void set_jvm_options(int index, const char* value);
  void set_jvm_options(int index, const char* value, size_t size);
  std::string* add_jvm_options();
  void add_jvm_options(const std::string& value);
  void add_jvm_options(std::string&& value);
  void add_jvm_options(const char* value);
  void add_jvm_options(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& jvm_options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_jvm_options();
  private:
  const std::string& _internal_jvm_options(int index) const;
  std::string* _internal_add_jvm_options();
  public:

  // repeated string code_search_path = 3;
  int code_search_path_size() const;
  private:
  int _internal_code_search_path_size() const;
  public:
  void clear_code_search_path();
  const std::string& code_search_path(int index) const;
  std::string* mutable_code_search_path(int index);
  void set_code_search_path(int index, const std::string& value);
  void set_code_search_path(int index, std::string&& value);
  void set_code_search_path(int index, const char* value);
  void set_code_search_path(int index, const char* value, size_t size);
  std::string* add_code_search_path();
  void add_code_search_path(const std::string& value);
  void add_code_search_path(std::string&& value);
  void add_code_search_path(const char* value);
  void add_code_search_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& code_search_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_code_search_path();
  private:
  const std::string& _internal_code_search_path(int index) const;
  std::string* _internal_add_code_search_path();
  public:

  // map<string, string> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string mcs_namespace = 5;
  void clear_mcs_namespace();
  const std::string& mcs_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcs_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcs_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcs_namespace();
  void set_allocated_mcs_namespace(std::string* mcs_namespace);
  private:
  const std::string& _internal_mcs_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcs_namespace(const std::string& value);
  std::string* _internal_mutable_mcs_namespace();
  public:

  // .mcs.rpc.RuntimeEnvInfo runtime_env_info = 4;
  bool has_runtime_env_info() const;
  private:
  bool _internal_has_runtime_env_info() const;
  public:
  void clear_runtime_env_info();
  const ::mcs::rpc::RuntimeEnvInfo& runtime_env_info() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::RuntimeEnvInfo* release_runtime_env_info();
  ::mcs::rpc::RuntimeEnvInfo* mutable_runtime_env_info();
  void set_allocated_runtime_env_info(::mcs::rpc::RuntimeEnvInfo* runtime_env_info);
  private:
  const ::mcs::rpc::RuntimeEnvInfo& _internal_runtime_env_info() const;
  ::mcs::rpc::RuntimeEnvInfo* _internal_mutable_runtime_env_info();
  public:
  void unsafe_arena_set_allocated_runtime_env_info(
      ::mcs::rpc::RuntimeEnvInfo* runtime_env_info);
  ::mcs::rpc::RuntimeEnvInfo* unsafe_arena_release_runtime_env_info();

  // .mcs.rpc.JobConfig.ActorLifetime default_actor_lifetime = 7;
  void clear_default_actor_lifetime();
  ::mcs::rpc::JobConfig_ActorLifetime default_actor_lifetime() const;
  void set_default_actor_lifetime(::mcs::rpc::JobConfig_ActorLifetime value);
  private:
  ::mcs::rpc::JobConfig_ActorLifetime _internal_default_actor_lifetime() const;
  void _internal_set_default_actor_lifetime(::mcs::rpc::JobConfig_ActorLifetime value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.JobConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> jvm_options_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> code_search_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      JobConfig_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcs_namespace_;
  ::mcs::rpc::RuntimeEnvInfo* runtime_env_info_;
  int default_actor_lifetime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class JobTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.JobTableData) */ {
 public:
  inline JobTableData() : JobTableData(nullptr) {}
  ~JobTableData() override;
  explicit constexpr JobTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobTableData(const JobTableData& from);
  JobTableData(JobTableData&& from) noexcept
    : JobTableData() {
    *this = ::std::move(from);
  }

  inline JobTableData& operator=(const JobTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobTableData& operator=(JobTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobTableData* internal_default_instance() {
    return reinterpret_cast<const JobTableData*>(
               &_JobTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(JobTableData& a, JobTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(JobTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JobTableData* New() const final {
    return new JobTableData();
  }

  JobTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JobTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JobTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.JobTableData";
  }
  protected:
  explicit JobTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kDriverIpAddressFieldNumber = 4,
    kEntrypointFieldNumber = 9,
    kConfigFieldNumber = 6,
    kTimestampFieldNumber = 3,
    kDriverPidFieldNumber = 5,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kIsDeadFieldNumber = 2,
  };
  // bytes job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string driver_ip_address = 4;
  void clear_driver_ip_address();
  const std::string& driver_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_driver_ip_address();
  void set_allocated_driver_ip_address(std::string* driver_ip_address);
  private:
  const std::string& _internal_driver_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_ip_address(const std::string& value);
  std::string* _internal_mutable_driver_ip_address();
  public:

  // string entrypoint = 9;
  void clear_entrypoint();
  const std::string& entrypoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entrypoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entrypoint();
  PROTOBUF_MUST_USE_RESULT std::string* release_entrypoint();
  void set_allocated_entrypoint(std::string* entrypoint);
  private:
  const std::string& _internal_entrypoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entrypoint(const std::string& value);
  std::string* _internal_mutable_entrypoint();
  public:

  // .mcs.rpc.JobConfig config = 6;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::mcs::rpc::JobConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::JobConfig* release_config();
  ::mcs::rpc::JobConfig* mutable_config();
  void set_allocated_config(::mcs::rpc::JobConfig* config);
  private:
  const ::mcs::rpc::JobConfig& _internal_config() const;
  ::mcs::rpc::JobConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::mcs::rpc::JobConfig* config);
  ::mcs::rpc::JobConfig* unsafe_arena_release_config();

  // int64 timestamp = 3;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 driver_pid = 5;
  void clear_driver_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 driver_pid() const;
  void set_driver_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_driver_pid() const;
  void _internal_set_driver_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint64 start_time = 7;
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 end_time = 8;
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_time() const;
  void _internal_set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_dead = 2;
  void clear_is_dead();
  bool is_dead() const;
  void set_is_dead(bool value);
  private:
  bool _internal_is_dead() const;
  void _internal_set_is_dead(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.JobTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entrypoint_;
  ::mcs::rpc::JobConfig* config_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 driver_pid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_time_;
  bool is_dead_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class WorkerTableData_WorkerInfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorkerTableData_WorkerInfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorkerTableData_WorkerInfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  WorkerTableData_WorkerInfoEntry_DoNotUse();
  explicit constexpr WorkerTableData_WorkerInfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WorkerTableData_WorkerInfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WorkerTableData_WorkerInfoEntry_DoNotUse& other);
  static const WorkerTableData_WorkerInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorkerTableData_WorkerInfoEntry_DoNotUse*>(&_WorkerTableData_WorkerInfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.WorkerTableData.WorkerInfoEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class WorkerTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.WorkerTableData) */ {
 public:
  inline WorkerTableData() : WorkerTableData(nullptr) {}
  ~WorkerTableData() override;
  explicit constexpr WorkerTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerTableData(const WorkerTableData& from);
  WorkerTableData(WorkerTableData&& from) noexcept
    : WorkerTableData() {
    *this = ::std::move(from);
  }

  inline WorkerTableData& operator=(const WorkerTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerTableData& operator=(WorkerTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerTableData* internal_default_instance() {
    return reinterpret_cast<const WorkerTableData*>(
               &_WorkerTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(WorkerTableData& a, WorkerTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerTableData* New() const final {
    return new WorkerTableData();
  }

  WorkerTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.WorkerTableData";
  }
  protected:
  explicit WorkerTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWorkerInfoFieldNumber = 6,
    kExitDetailFieldNumber = 20,
    kWorkerAddressFieldNumber = 2,
    kCreationTaskExceptionFieldNumber = 18,
    kTimestampFieldNumber = 3,
    kIsAliveFieldNumber = 1,
    kWorkerTypeFieldNumber = 5,
    kExitTypeFieldNumber = 19,
    kPidFieldNumber = 21,
  };
  // map<string, bytes> worker_info = 6;
  int worker_info_size() const;
  private:
  int _internal_worker_info_size() const;
  public:
  void clear_worker_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_worker_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_worker_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      worker_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_worker_info();

  // optional string exit_detail = 20;
  bool has_exit_detail() const;
  private:
  bool _internal_has_exit_detail() const;
  public:
  void clear_exit_detail();
  const std::string& exit_detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exit_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exit_detail();
  PROTOBUF_MUST_USE_RESULT std::string* release_exit_detail();
  void set_allocated_exit_detail(std::string* exit_detail);
  private:
  const std::string& _internal_exit_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exit_detail(const std::string& value);
  std::string* _internal_mutable_exit_detail();
  public:

  // .mcs.rpc.Address worker_address = 2;
  bool has_worker_address() const;
  private:
  bool _internal_has_worker_address() const;
  public:
  void clear_worker_address();
  const ::mcs::rpc::Address& worker_address() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::Address* release_worker_address();
  ::mcs::rpc::Address* mutable_worker_address();
  void set_allocated_worker_address(::mcs::rpc::Address* worker_address);
  private:
  const ::mcs::rpc::Address& _internal_worker_address() const;
  ::mcs::rpc::Address* _internal_mutable_worker_address();
  public:
  void unsafe_arena_set_allocated_worker_address(
      ::mcs::rpc::Address* worker_address);
  ::mcs::rpc::Address* unsafe_arena_release_worker_address();

  // .mcs.rpc.McsException creation_task_exception = 18;
  bool has_creation_task_exception() const;
  private:
  bool _internal_has_creation_task_exception() const;
  public:
  void clear_creation_task_exception();
  const ::mcs::rpc::McsException& creation_task_exception() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::McsException* release_creation_task_exception();
  ::mcs::rpc::McsException* mutable_creation_task_exception();
  void set_allocated_creation_task_exception(::mcs::rpc::McsException* creation_task_exception);
  private:
  const ::mcs::rpc::McsException& _internal_creation_task_exception() const;
  ::mcs::rpc::McsException* _internal_mutable_creation_task_exception();
  public:
  void unsafe_arena_set_allocated_creation_task_exception(
      ::mcs::rpc::McsException* creation_task_exception);
  ::mcs::rpc::McsException* unsafe_arena_release_creation_task_exception();

  // int64 timestamp = 3;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool is_alive = 1;
  void clear_is_alive();
  bool is_alive() const;
  void set_is_alive(bool value);
  private:
  bool _internal_is_alive() const;
  void _internal_set_is_alive(bool value);
  public:

  // .mcs.rpc.WorkerType worker_type = 5;
  void clear_worker_type();
  ::mcs::rpc::WorkerType worker_type() const;
  void set_worker_type(::mcs::rpc::WorkerType value);
  private:
  ::mcs::rpc::WorkerType _internal_worker_type() const;
  void _internal_set_worker_type(::mcs::rpc::WorkerType value);
  public:

  // optional .mcs.rpc.WorkerExitType exit_type = 19;
  bool has_exit_type() const;
  private:
  bool _internal_has_exit_type() const;
  public:
  void clear_exit_type();
  ::mcs::rpc::WorkerExitType exit_type() const;
  void set_exit_type(::mcs::rpc::WorkerExitType value);
  private:
  ::mcs::rpc::WorkerExitType _internal_exit_type() const;
  void _internal_set_exit_type(::mcs::rpc::WorkerExitType value);
  public:

  // uint32 pid = 21;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.WorkerTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      WorkerTableData_WorkerInfoEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> worker_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exit_detail_;
  ::mcs::rpc::Address* worker_address_;
  ::mcs::rpc::McsException* creation_task_exception_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  bool is_alive_;
  int worker_type_;
  int exit_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class WorkerDeltaData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.WorkerDeltaData) */ {
 public:
  inline WorkerDeltaData() : WorkerDeltaData(nullptr) {}
  ~WorkerDeltaData() override;
  explicit constexpr WorkerDeltaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerDeltaData(const WorkerDeltaData& from);
  WorkerDeltaData(WorkerDeltaData&& from) noexcept
    : WorkerDeltaData() {
    *this = ::std::move(from);
  }

  inline WorkerDeltaData& operator=(const WorkerDeltaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerDeltaData& operator=(WorkerDeltaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerDeltaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerDeltaData* internal_default_instance() {
    return reinterpret_cast<const WorkerDeltaData*>(
               &_WorkerDeltaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WorkerDeltaData& a, WorkerDeltaData& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerDeltaData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerDeltaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerDeltaData* New() const final {
    return new WorkerDeltaData();
  }

  WorkerDeltaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerDeltaData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerDeltaData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WorkerDeltaData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerDeltaData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.WorkerDeltaData";
  }
  protected:
  explicit WorkerDeltaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMcsletIdFieldNumber = 1,
    kWorkerIdFieldNumber = 2,
  };
  // bytes mcslet_id = 1;
  void clear_mcslet_id();
  const std::string& mcslet_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcslet_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcslet_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcslet_id();
  void set_allocated_mcslet_id(std::string* mcslet_id);
  private:
  const std::string& _internal_mcslet_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcslet_id(const std::string& value);
  std::string* _internal_mutable_mcslet_id();
  public:

  // bytes worker_id = 2;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.WorkerDeltaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcslet_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourceMap_ItemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourceMap_ItemsEntry_DoNotUse, 
    std::string, ::mcs::rpc::ResourceTableData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourceMap_ItemsEntry_DoNotUse, 
    std::string, ::mcs::rpc::ResourceTableData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ResourceMap_ItemsEntry_DoNotUse();
  explicit constexpr ResourceMap_ItemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ResourceMap_ItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ResourceMap_ItemsEntry_DoNotUse& other);
  static const ResourceMap_ItemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResourceMap_ItemsEntry_DoNotUse*>(&_ResourceMap_ItemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ResourceMap.ItemsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ResourceMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceMap) */ {
 public:
  inline ResourceMap() : ResourceMap(nullptr) {}
  ~ResourceMap() override;
  explicit constexpr ResourceMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceMap(const ResourceMap& from);
  ResourceMap(ResourceMap&& from) noexcept
    : ResourceMap() {
    *this = ::std::move(from);
  }

  inline ResourceMap& operator=(const ResourceMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceMap& operator=(ResourceMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceMap* internal_default_instance() {
    return reinterpret_cast<const ResourceMap*>(
               &_ResourceMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ResourceMap& a, ResourceMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceMap* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceMap* New() const final {
    return new ResourceMap();
  }

  ResourceMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceMap";
  }
  protected:
  explicit ResourceMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // map<string, .mcs.rpc.ResourceTableData> items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >&
      _internal_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >*
      _internal_mutable_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >&
      items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ResourceMap_ItemsEntry_DoNotUse,
      std::string, ::mcs::rpc::ResourceTableData,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class StoredConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.StoredConfig) */ {
 public:
  inline StoredConfig() : StoredConfig(nullptr) {}
  ~StoredConfig() override;
  explicit constexpr StoredConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoredConfig(const StoredConfig& from);
  StoredConfig(StoredConfig&& from) noexcept
    : StoredConfig() {
    *this = ::std::move(from);
  }

  inline StoredConfig& operator=(const StoredConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoredConfig& operator=(StoredConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoredConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoredConfig* internal_default_instance() {
    return reinterpret_cast<const StoredConfig*>(
               &_StoredConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(StoredConfig& a, StoredConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StoredConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoredConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoredConfig* New() const final {
    return new StoredConfig();
  }

  StoredConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoredConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoredConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoredConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoredConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.StoredConfig";
  }
  protected:
  explicit StoredConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // string config = 1;
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_MUST_USE_RESULT std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.StoredConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class NodeResourceChange_UpdatedResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeResourceChange_UpdatedResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeResourceChange_UpdatedResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  NodeResourceChange_UpdatedResourcesEntry_DoNotUse();
  explicit constexpr NodeResourceChange_UpdatedResourcesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NodeResourceChange_UpdatedResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodeResourceChange_UpdatedResourcesEntry_DoNotUse& other);
  static const NodeResourceChange_UpdatedResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodeResourceChange_UpdatedResourcesEntry_DoNotUse*>(&_NodeResourceChange_UpdatedResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.NodeResourceChange.UpdatedResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class NodeResourceChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.NodeResourceChange) */ {
 public:
  inline NodeResourceChange() : NodeResourceChange(nullptr) {}
  ~NodeResourceChange() override;
  explicit constexpr NodeResourceChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeResourceChange(const NodeResourceChange& from);
  NodeResourceChange(NodeResourceChange&& from) noexcept
    : NodeResourceChange() {
    *this = ::std::move(from);
  }

  inline NodeResourceChange& operator=(const NodeResourceChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeResourceChange& operator=(NodeResourceChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeResourceChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeResourceChange* internal_default_instance() {
    return reinterpret_cast<const NodeResourceChange*>(
               &_NodeResourceChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NodeResourceChange& a, NodeResourceChange& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeResourceChange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeResourceChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeResourceChange* New() const final {
    return new NodeResourceChange();
  }

  NodeResourceChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeResourceChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeResourceChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeResourceChange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeResourceChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.NodeResourceChange";
  }
  protected:
  explicit NodeResourceChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kUpdatedResourcesFieldNumber = 2,
    kDeletedResourcesFieldNumber = 3,
    kNodeIdFieldNumber = 1,
  };
  // map<string, double> updated_resources = 2;
  int updated_resources_size() const;
  private:
  int _internal_updated_resources_size() const;
  public:
  void clear_updated_resources();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_updated_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_updated_resources();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      updated_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_updated_resources();

  // repeated string deleted_resources = 3;
  int deleted_resources_size() const;
  private:
  int _internal_deleted_resources_size() const;
  public:
  void clear_deleted_resources();
  const std::string& deleted_resources(int index) const;
  std::string* mutable_deleted_resources(int index);
  void set_deleted_resources(int index, const std::string& value);
  void set_deleted_resources(int index, std::string&& value);
  void set_deleted_resources(int index, const char* value);
  void set_deleted_resources(int index, const char* value, size_t size);
  std::string* add_deleted_resources();
  void add_deleted_resources(const std::string& value);
  void add_deleted_resources(std::string&& value);
  void add_deleted_resources(const char* value);
  void add_deleted_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& deleted_resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_deleted_resources();
  private:
  const std::string& _internal_deleted_resources(int index) const;
  std::string* _internal_add_deleted_resources();
  public:

  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.NodeResourceChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodeResourceChange_UpdatedResourcesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> updated_resources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> deleted_resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class PubSubMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.PubSubMessage) */ {
 public:
  inline PubSubMessage() : PubSubMessage(nullptr) {}
  ~PubSubMessage() override;
  explicit constexpr PubSubMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PubSubMessage(const PubSubMessage& from);
  PubSubMessage(PubSubMessage&& from) noexcept
    : PubSubMessage() {
    *this = ::std::move(from);
  }

  inline PubSubMessage& operator=(const PubSubMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubSubMessage& operator=(PubSubMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubSubMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PubSubMessage* internal_default_instance() {
    return reinterpret_cast<const PubSubMessage*>(
               &_PubSubMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PubSubMessage& a, PubSubMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PubSubMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubSubMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PubSubMessage* New() const final {
    return new PubSubMessage();
  }

  PubSubMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PubSubMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PubSubMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PubSubMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubSubMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.PubSubMessage";
  }
  protected:
  explicit PubSubMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.PubSubMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourceUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceUpdate) */ {
 public:
  inline ResourceUpdate() : ResourceUpdate(nullptr) {}
  ~ResourceUpdate() override;
  explicit constexpr ResourceUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceUpdate(const ResourceUpdate& from);
  ResourceUpdate(ResourceUpdate&& from) noexcept
    : ResourceUpdate() {
    *this = ::std::move(from);
  }

  inline ResourceUpdate& operator=(const ResourceUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceUpdate& operator=(ResourceUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceUpdate& default_instance() {
    return *internal_default_instance();
  }
  enum ResourceChangeOrDataCase {
    kChange = 1,
    kData = 2,
    RESOURCE_CHANGE_OR_DATA_NOT_SET = 0,
  };

  static inline const ResourceUpdate* internal_default_instance() {
    return reinterpret_cast<const ResourceUpdate*>(
               &_ResourceUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResourceUpdate& a, ResourceUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceUpdate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceUpdate* New() const final {
    return new ResourceUpdate();
  }

  ResourceUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceUpdate";
  }
  protected:
  explicit ResourceUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .mcs.rpc.NodeResourceChange change = 1;
  bool has_change() const;
  private:
  bool _internal_has_change() const;
  public:
  void clear_change();
  const ::mcs::rpc::NodeResourceChange& change() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::NodeResourceChange* release_change();
  ::mcs::rpc::NodeResourceChange* mutable_change();
  void set_allocated_change(::mcs::rpc::NodeResourceChange* change);
  private:
  const ::mcs::rpc::NodeResourceChange& _internal_change() const;
  ::mcs::rpc::NodeResourceChange* _internal_mutable_change();
  public:
  void unsafe_arena_set_allocated_change(
      ::mcs::rpc::NodeResourceChange* change);
  ::mcs::rpc::NodeResourceChange* unsafe_arena_release_change();

  // .mcs.rpc.ResourcesData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::mcs::rpc::ResourcesData& data() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ResourcesData* release_data();
  ::mcs::rpc::ResourcesData* mutable_data();
  void set_allocated_data(::mcs::rpc::ResourcesData* data);
  private:
  const ::mcs::rpc::ResourcesData& _internal_data() const;
  ::mcs::rpc::ResourcesData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::mcs::rpc::ResourcesData* data);
  ::mcs::rpc::ResourcesData* unsafe_arena_release_data();

  void clear_resource_change_or_data();
  ResourceChangeOrDataCase resource_change_or_data_case() const;
  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceUpdate)
 private:
  class _Internal;
  void set_has_change();
  void set_has_data();

  inline bool has_resource_change_or_data() const;
  inline void clear_has_resource_change_or_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResourceChangeOrDataUnion {
    constexpr ResourceChangeOrDataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::mcs::rpc::NodeResourceChange* change_;
    ::mcs::rpc::ResourcesData* data_;
  } resource_change_or_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourceUsageBroadcastData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceUsageBroadcastData) */ {
 public:
  inline ResourceUsageBroadcastData() : ResourceUsageBroadcastData(nullptr) {}
  ~ResourceUsageBroadcastData() override;
  explicit constexpr ResourceUsageBroadcastData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceUsageBroadcastData(const ResourceUsageBroadcastData& from);
  ResourceUsageBroadcastData(ResourceUsageBroadcastData&& from) noexcept
    : ResourceUsageBroadcastData() {
    *this = ::std::move(from);
  }

  inline ResourceUsageBroadcastData& operator=(const ResourceUsageBroadcastData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceUsageBroadcastData& operator=(ResourceUsageBroadcastData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceUsageBroadcastData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceUsageBroadcastData* internal_default_instance() {
    return reinterpret_cast<const ResourceUsageBroadcastData*>(
               &_ResourceUsageBroadcastData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ResourceUsageBroadcastData& a, ResourceUsageBroadcastData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceUsageBroadcastData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceUsageBroadcastData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceUsageBroadcastData* New() const final {
    return new ResourceUsageBroadcastData();
  }

  ResourceUsageBroadcastData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceUsageBroadcastData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceUsageBroadcastData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceUsageBroadcastData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceUsageBroadcastData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceUsageBroadcastData";
  }
  protected:
  explicit ResourceUsageBroadcastData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchFieldNumber = 2,
    kSeqNoFieldNumber = 1,
  };
  // repeated .mcs.rpc.ResourceUpdate batch = 2;
  int batch_size() const;
  private:
  int _internal_batch_size() const;
  public:
  void clear_batch();
  ::mcs::rpc::ResourceUpdate* mutable_batch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceUpdate >*
      mutable_batch();
  private:
  const ::mcs::rpc::ResourceUpdate& _internal_batch(int index) const;
  ::mcs::rpc::ResourceUpdate* _internal_add_batch();
  public:
  const ::mcs::rpc::ResourceUpdate& batch(int index) const;
  ::mcs::rpc::ResourceUpdate* add_batch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceUpdate >&
      batch() const;

  // int64 seq_no = 1;
  void clear_seq_no();
  ::PROTOBUF_NAMESPACE_ID::int64 seq_no() const;
  void set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seq_no() const;
  void _internal_set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceUsageBroadcastData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceUpdate > batch_;
  ::PROTOBUF_NAMESPACE_ID::int64 seq_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourceDemand_ShapeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourceDemand_ShapeEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourceDemand_ShapeEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ResourceDemand_ShapeEntry_DoNotUse();
  explicit constexpr ResourceDemand_ShapeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ResourceDemand_ShapeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ResourceDemand_ShapeEntry_DoNotUse& other);
  static const ResourceDemand_ShapeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResourceDemand_ShapeEntry_DoNotUse*>(&_ResourceDemand_ShapeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ResourceDemand.ShapeEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ResourceDemand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceDemand) */ {
 public:
  inline ResourceDemand() : ResourceDemand(nullptr) {}
  ~ResourceDemand() override;
  explicit constexpr ResourceDemand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceDemand(const ResourceDemand& from);
  ResourceDemand(ResourceDemand&& from) noexcept
    : ResourceDemand() {
    *this = ::std::move(from);
  }

  inline ResourceDemand& operator=(const ResourceDemand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceDemand& operator=(ResourceDemand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceDemand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceDemand* internal_default_instance() {
    return reinterpret_cast<const ResourceDemand*>(
               &_ResourceDemand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ResourceDemand& a, ResourceDemand& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceDemand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceDemand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceDemand* New() const final {
    return new ResourceDemand();
  }

  ResourceDemand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceDemand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceDemand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceDemand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceDemand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceDemand";
  }
  protected:
  explicit ResourceDemand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
    kNumReadyRequestsQueuedFieldNumber = 2,
    kNumInfeasibleRequestsQueuedFieldNumber = 3,
    kBacklogSizeFieldNumber = 4,
  };
  // map<string, double> shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_shape() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_shape();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_shape();

  // uint64 num_ready_requests_queued = 2;
  void clear_num_ready_requests_queued();
  ::PROTOBUF_NAMESPACE_ID::uint64 num_ready_requests_queued() const;
  void set_num_ready_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_num_ready_requests_queued() const;
  void _internal_set_num_ready_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 num_infeasible_requests_queued = 3;
  void clear_num_infeasible_requests_queued();
  ::PROTOBUF_NAMESPACE_ID::uint64 num_infeasible_requests_queued() const;
  void set_num_infeasible_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_num_infeasible_requests_queued() const;
  void _internal_set_num_infeasible_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 backlog_size = 4;
  void clear_backlog_size();
  ::PROTOBUF_NAMESPACE_ID::int64 backlog_size() const;
  void set_backlog_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_backlog_size() const;
  void _internal_set_backlog_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceDemand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ResourceDemand_ShapeEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> shape_;
  ::PROTOBUF_NAMESPACE_ID::uint64 num_ready_requests_queued_;
  ::PROTOBUF_NAMESPACE_ID::uint64 num_infeasible_requests_queued_;
  ::PROTOBUF_NAMESPACE_ID::int64 backlog_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourceLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceLoad) */ {
 public:
  inline ResourceLoad() : ResourceLoad(nullptr) {}
  ~ResourceLoad() override;
  explicit constexpr ResourceLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceLoad(const ResourceLoad& from);
  ResourceLoad(ResourceLoad&& from) noexcept
    : ResourceLoad() {
    *this = ::std::move(from);
  }

  inline ResourceLoad& operator=(const ResourceLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceLoad& operator=(ResourceLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceLoad* internal_default_instance() {
    return reinterpret_cast<const ResourceLoad*>(
               &_ResourceLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ResourceLoad& a, ResourceLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceLoad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceLoad* New() const final {
    return new ResourceLoad();
  }

  ResourceLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceLoad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceLoad";
  }
  protected:
  explicit ResourceLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceDemandsFieldNumber = 1,
  };
  // repeated .mcs.rpc.ResourceDemand resource_demands = 1;
  int resource_demands_size() const;
  private:
  int _internal_resource_demands_size() const;
  public:
  void clear_resource_demands();
  ::mcs::rpc::ResourceDemand* mutable_resource_demands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceDemand >*
      mutable_resource_demands();
  private:
  const ::mcs::rpc::ResourceDemand& _internal_resource_demands(int index) const;
  ::mcs::rpc::ResourceDemand* _internal_add_resource_demands();
  public:
  const ::mcs::rpc::ResourceDemand& resource_demands(int index) const;
  ::mcs::rpc::ResourceDemand* add_resource_demands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceDemand >&
      resource_demands() const;

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceDemand > resource_demands_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourcesData_ResourcesAvailableEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourcesAvailableEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourcesAvailableEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ResourcesData_ResourcesAvailableEntry_DoNotUse();
  explicit constexpr ResourcesData_ResourcesAvailableEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ResourcesData_ResourcesAvailableEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ResourcesData_ResourcesAvailableEntry_DoNotUse& other);
  static const ResourcesData_ResourcesAvailableEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResourcesData_ResourcesAvailableEntry_DoNotUse*>(&_ResourcesData_ResourcesAvailableEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ResourcesData.ResourcesAvailableEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ResourcesData_ResourcesTotalEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourcesTotalEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourcesTotalEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ResourcesData_ResourcesTotalEntry_DoNotUse();
  explicit constexpr ResourcesData_ResourcesTotalEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ResourcesData_ResourcesTotalEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ResourcesData_ResourcesTotalEntry_DoNotUse& other);
  static const ResourcesData_ResourcesTotalEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResourcesData_ResourcesTotalEntry_DoNotUse*>(&_ResourcesData_ResourcesTotalEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ResourcesData.ResourcesTotalEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ResourcesData_ResourceLoadEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourceLoadEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourceLoadEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ResourcesData_ResourceLoadEntry_DoNotUse();
  explicit constexpr ResourcesData_ResourceLoadEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ResourcesData_ResourceLoadEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ResourcesData_ResourceLoadEntry_DoNotUse& other);
  static const ResourcesData_ResourceLoadEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResourcesData_ResourceLoadEntry_DoNotUse*>(&_ResourcesData_ResourceLoadEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ResourcesData.ResourceLoadEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ResourcesData_ResourcesNormalTaskEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourcesNormalTaskEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ResourcesData_ResourcesNormalTaskEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ResourcesData_ResourcesNormalTaskEntry_DoNotUse();
  explicit constexpr ResourcesData_ResourcesNormalTaskEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ResourcesData_ResourcesNormalTaskEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ResourcesData_ResourcesNormalTaskEntry_DoNotUse& other);
  static const ResourcesData_ResourcesNormalTaskEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResourcesData_ResourcesNormalTaskEntry_DoNotUse*>(&_ResourcesData_ResourcesNormalTaskEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.ResourcesData.ResourcesNormalTaskEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ResourcesData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourcesData) */ {
 public:
  inline ResourcesData() : ResourcesData(nullptr) {}
  ~ResourcesData() override;
  explicit constexpr ResourcesData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourcesData(const ResourcesData& from);
  ResourcesData(ResourcesData&& from) noexcept
    : ResourcesData() {
    *this = ::std::move(from);
  }

  inline ResourcesData& operator=(const ResourcesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourcesData& operator=(ResourcesData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourcesData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourcesData* internal_default_instance() {
    return reinterpret_cast<const ResourcesData*>(
               &_ResourcesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ResourcesData& a, ResourcesData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourcesData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourcesData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourcesData* New() const final {
    return new ResourcesData();
  }

  ResourcesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourcesData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourcesData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourcesData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourcesData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourcesData";
  }
  protected:
  explicit ResourcesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResourcesAvailableFieldNumber = 2,
    kResourcesTotalFieldNumber = 4,
    kResourceLoadFieldNumber = 5,
    kResourcesNormalTaskFieldNumber = 11,
    kNodeIdFieldNumber = 1,
    kNodeManagerAddressFieldNumber = 9,
    kResourceLoadByShapeFieldNumber = 7,
    kResourcesAvailableChangedFieldNumber = 3,
    kResourceLoadChangedFieldNumber = 6,
    kShouldGlobalGcFieldNumber = 8,
    kObjectPullsQueuedFieldNumber = 10,
    kResourcesNormalTaskChangedFieldNumber = 12,
    kClusterFullOfActorsDetectedFieldNumber = 14,
    kResourcesNormalTaskTimestampFieldNumber = 13,
  };
  // map<string, double> resources_available = 2;
  int resources_available_size() const;
  private:
  int _internal_resources_available_size() const;
  public:
  void clear_resources_available();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_resources_available() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_resources_available();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      resources_available() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_resources_available();

  // map<string, double> resources_total = 4;
  int resources_total_size() const;
  private:
  int _internal_resources_total_size() const;
  public:
  void clear_resources_total();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_resources_total() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_resources_total();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      resources_total() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_resources_total();

  // map<string, double> resource_load = 5;
  int resource_load_size() const;
  private:
  int _internal_resource_load_size() const;
  public:
  void clear_resource_load();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_resource_load() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_resource_load();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      resource_load() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_resource_load();

  // map<string, double> resources_normal_task = 11;
  int resources_normal_task_size() const;
  private:
  int _internal_resources_normal_task_size() const;
  public:
  void clear_resources_normal_task();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_resources_normal_task() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_resources_normal_task();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      resources_normal_task() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_resources_normal_task();

  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // string node_manager_address = 9;
  void clear_node_manager_address();
  const std::string& node_manager_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_manager_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_manager_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_manager_address();
  void set_allocated_node_manager_address(std::string* node_manager_address);
  private:
  const std::string& _internal_node_manager_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_manager_address(const std::string& value);
  std::string* _internal_mutable_node_manager_address();
  public:

  // .mcs.rpc.ResourceLoad resource_load_by_shape = 7;
  bool has_resource_load_by_shape() const;
  private:
  bool _internal_has_resource_load_by_shape() const;
  public:
  void clear_resource_load_by_shape();
  const ::mcs::rpc::ResourceLoad& resource_load_by_shape() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ResourceLoad* release_resource_load_by_shape();
  ::mcs::rpc::ResourceLoad* mutable_resource_load_by_shape();
  void set_allocated_resource_load_by_shape(::mcs::rpc::ResourceLoad* resource_load_by_shape);
  private:
  const ::mcs::rpc::ResourceLoad& _internal_resource_load_by_shape() const;
  ::mcs::rpc::ResourceLoad* _internal_mutable_resource_load_by_shape();
  public:
  void unsafe_arena_set_allocated_resource_load_by_shape(
      ::mcs::rpc::ResourceLoad* resource_load_by_shape);
  ::mcs::rpc::ResourceLoad* unsafe_arena_release_resource_load_by_shape();

  // bool resources_available_changed = 3;
  void clear_resources_available_changed();
  bool resources_available_changed() const;
  void set_resources_available_changed(bool value);
  private:
  bool _internal_resources_available_changed() const;
  void _internal_set_resources_available_changed(bool value);
  public:

  // bool resource_load_changed = 6;
  void clear_resource_load_changed();
  bool resource_load_changed() const;
  void set_resource_load_changed(bool value);
  private:
  bool _internal_resource_load_changed() const;
  void _internal_set_resource_load_changed(bool value);
  public:

  // bool should_global_gc = 8;
  void clear_should_global_gc();
  bool should_global_gc() const;
  void set_should_global_gc(bool value);
  private:
  bool _internal_should_global_gc() const;
  void _internal_set_should_global_gc(bool value);
  public:

  // bool object_pulls_queued = 10;
  void clear_object_pulls_queued();
  bool object_pulls_queued() const;
  void set_object_pulls_queued(bool value);
  private:
  bool _internal_object_pulls_queued() const;
  void _internal_set_object_pulls_queued(bool value);
  public:

  // bool resources_normal_task_changed = 12;
  void clear_resources_normal_task_changed();
  bool resources_normal_task_changed() const;
  void set_resources_normal_task_changed(bool value);
  private:
  bool _internal_resources_normal_task_changed() const;
  void _internal_set_resources_normal_task_changed(bool value);
  public:

  // bool cluster_full_of_actors_detected = 14;
  void clear_cluster_full_of_actors_detected();
  bool cluster_full_of_actors_detected() const;
  void set_cluster_full_of_actors_detected(bool value);
  private:
  bool _internal_cluster_full_of_actors_detected() const;
  void _internal_set_cluster_full_of_actors_detected(bool value);
  public:

  // int64 resources_normal_task_timestamp = 13;
  void clear_resources_normal_task_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 resources_normal_task_timestamp() const;
  void set_resources_normal_task_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_resources_normal_task_timestamp() const;
  void _internal_set_resources_normal_task_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourcesData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ResourcesData_ResourcesAvailableEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> resources_available_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ResourcesData_ResourcesTotalEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> resources_total_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ResourcesData_ResourceLoadEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> resource_load_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ResourcesData_ResourcesNormalTaskEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> resources_normal_task_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_manager_address_;
  ::mcs::rpc::ResourceLoad* resource_load_by_shape_;
  bool resources_available_changed_;
  bool resource_load_changed_;
  bool should_global_gc_;
  bool object_pulls_queued_;
  bool resources_normal_task_changed_;
  bool cluster_full_of_actors_detected_;
  ::PROTOBUF_NAMESPACE_ID::int64 resources_normal_task_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class ResourceUsageBatchData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceUsageBatchData) */ {
 public:
  inline ResourceUsageBatchData() : ResourceUsageBatchData(nullptr) {}
  ~ResourceUsageBatchData() override;
  explicit constexpr ResourceUsageBatchData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceUsageBatchData(const ResourceUsageBatchData& from);
  ResourceUsageBatchData(ResourceUsageBatchData&& from) noexcept
    : ResourceUsageBatchData() {
    *this = ::std::move(from);
  }

  inline ResourceUsageBatchData& operator=(const ResourceUsageBatchData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceUsageBatchData& operator=(ResourceUsageBatchData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceUsageBatchData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceUsageBatchData* internal_default_instance() {
    return reinterpret_cast<const ResourceUsageBatchData*>(
               &_ResourceUsageBatchData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ResourceUsageBatchData& a, ResourceUsageBatchData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceUsageBatchData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceUsageBatchData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceUsageBatchData* New() const final {
    return new ResourceUsageBatchData();
  }

  ResourceUsageBatchData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceUsageBatchData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceUsageBatchData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceUsageBatchData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceUsageBatchData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceUsageBatchData";
  }
  protected:
  explicit ResourceUsageBatchData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchFieldNumber = 1,
    kResourceLoadByShapeFieldNumber = 2,
    kPlacementGroupLoadFieldNumber = 3,
  };
  // repeated .mcs.rpc.ResourcesData batch = 1;
  int batch_size() const;
  private:
  int _internal_batch_size() const;
  public:
  void clear_batch();
  ::mcs::rpc::ResourcesData* mutable_batch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourcesData >*
      mutable_batch();
  private:
  const ::mcs::rpc::ResourcesData& _internal_batch(int index) const;
  ::mcs::rpc::ResourcesData* _internal_add_batch();
  public:
  const ::mcs::rpc::ResourcesData& batch(int index) const;
  ::mcs::rpc::ResourcesData* add_batch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourcesData >&
      batch() const;

  // .mcs.rpc.ResourceLoad resource_load_by_shape = 2;
  bool has_resource_load_by_shape() const;
  private:
  bool _internal_has_resource_load_by_shape() const;
  public:
  void clear_resource_load_by_shape();
  const ::mcs::rpc::ResourceLoad& resource_load_by_shape() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ResourceLoad* release_resource_load_by_shape();
  ::mcs::rpc::ResourceLoad* mutable_resource_load_by_shape();
  void set_allocated_resource_load_by_shape(::mcs::rpc::ResourceLoad* resource_load_by_shape);
  private:
  const ::mcs::rpc::ResourceLoad& _internal_resource_load_by_shape() const;
  ::mcs::rpc::ResourceLoad* _internal_mutable_resource_load_by_shape();
  public:
  void unsafe_arena_set_allocated_resource_load_by_shape(
      ::mcs::rpc::ResourceLoad* resource_load_by_shape);
  ::mcs::rpc::ResourceLoad* unsafe_arena_release_resource_load_by_shape();

  // .mcs.rpc.PlacementGroupLoad placement_group_load = 3;
  bool has_placement_group_load() const;
  private:
  bool _internal_has_placement_group_load() const;
  public:
  void clear_placement_group_load();
  const ::mcs::rpc::PlacementGroupLoad& placement_group_load() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::PlacementGroupLoad* release_placement_group_load();
  ::mcs::rpc::PlacementGroupLoad* mutable_placement_group_load();
  void set_allocated_placement_group_load(::mcs::rpc::PlacementGroupLoad* placement_group_load);
  private:
  const ::mcs::rpc::PlacementGroupLoad& _internal_placement_group_load() const;
  ::mcs::rpc::PlacementGroupLoad* _internal_mutable_placement_group_load();
  public:
  void unsafe_arena_set_allocated_placement_group_load(
      ::mcs::rpc::PlacementGroupLoad* placement_group_load);
  ::mcs::rpc::PlacementGroupLoad* unsafe_arena_release_placement_group_load();

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceUsageBatchData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourcesData > batch_;
  ::mcs::rpc::ResourceLoad* resource_load_by_shape_;
  ::mcs::rpc::PlacementGroupLoad* placement_group_load_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class PlacementGroupLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.PlacementGroupLoad) */ {
 public:
  inline PlacementGroupLoad() : PlacementGroupLoad(nullptr) {}
  ~PlacementGroupLoad() override;
  explicit constexpr PlacementGroupLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlacementGroupLoad(const PlacementGroupLoad& from);
  PlacementGroupLoad(PlacementGroupLoad&& from) noexcept
    : PlacementGroupLoad() {
    *this = ::std::move(from);
  }

  inline PlacementGroupLoad& operator=(const PlacementGroupLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlacementGroupLoad& operator=(PlacementGroupLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlacementGroupLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlacementGroupLoad* internal_default_instance() {
    return reinterpret_cast<const PlacementGroupLoad*>(
               &_PlacementGroupLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(PlacementGroupLoad& a, PlacementGroupLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(PlacementGroupLoad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlacementGroupLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlacementGroupLoad* New() const final {
    return new PlacementGroupLoad();
  }

  PlacementGroupLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlacementGroupLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlacementGroupLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlacementGroupLoad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlacementGroupLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.PlacementGroupLoad";
  }
  protected:
  explicit PlacementGroupLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlacementGroupDataFieldNumber = 1,
  };
  // repeated .mcs.rpc.PlacementGroupTableData placement_group_data = 1;
  int placement_group_data_size() const;
  private:
  int _internal_placement_group_data_size() const;
  public:
  void clear_placement_group_data();
  ::mcs::rpc::PlacementGroupTableData* mutable_placement_group_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::PlacementGroupTableData >*
      mutable_placement_group_data();
  private:
  const ::mcs::rpc::PlacementGroupTableData& _internal_placement_group_data(int index) const;
  ::mcs::rpc::PlacementGroupTableData* _internal_add_placement_group_data();
  public:
  const ::mcs::rpc::PlacementGroupTableData& placement_group_data(int index) const;
  ::mcs::rpc::PlacementGroupTableData* add_placement_group_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::PlacementGroupTableData >&
      placement_group_data() const;

  // @@protoc_insertion_point(class_scope:mcs.rpc.PlacementGroupLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::PlacementGroupTableData > placement_group_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class PlacementGroupStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.PlacementGroupStats) */ {
 public:
  inline PlacementGroupStats() : PlacementGroupStats(nullptr) {}
  ~PlacementGroupStats() override;
  explicit constexpr PlacementGroupStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlacementGroupStats(const PlacementGroupStats& from);
  PlacementGroupStats(PlacementGroupStats&& from) noexcept
    : PlacementGroupStats() {
    *this = ::std::move(from);
  }

  inline PlacementGroupStats& operator=(const PlacementGroupStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlacementGroupStats& operator=(PlacementGroupStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlacementGroupStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlacementGroupStats* internal_default_instance() {
    return reinterpret_cast<const PlacementGroupStats*>(
               &_PlacementGroupStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PlacementGroupStats& a, PlacementGroupStats& b) {
    a.Swap(&b);
  }
  inline void Swap(PlacementGroupStats* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlacementGroupStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlacementGroupStats* New() const final {
    return new PlacementGroupStats();
  }

  PlacementGroupStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlacementGroupStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlacementGroupStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlacementGroupStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlacementGroupStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.PlacementGroupStats";
  }
  protected:
  explicit PlacementGroupStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PlacementGroupStats_SchedulingState SchedulingState;
  static constexpr SchedulingState QUEUED =
    PlacementGroupStats_SchedulingState_QUEUED;
  static constexpr SchedulingState REMOVED =
    PlacementGroupStats_SchedulingState_REMOVED;
  static constexpr SchedulingState SCHEDULING_STARTED =
    PlacementGroupStats_SchedulingState_SCHEDULING_STARTED;
  static constexpr SchedulingState NO_RESOURCES =
    PlacementGroupStats_SchedulingState_NO_RESOURCES;
  static constexpr SchedulingState INFEASIBLE =
    PlacementGroupStats_SchedulingState_INFEASIBLE;
  static constexpr SchedulingState FAILED_TO_COMMIT_RESOURCES =
    PlacementGroupStats_SchedulingState_FAILED_TO_COMMIT_RESOURCES;
  static constexpr SchedulingState FINISHED =
    PlacementGroupStats_SchedulingState_FINISHED;
  static inline bool SchedulingState_IsValid(int value) {
    return PlacementGroupStats_SchedulingState_IsValid(value);
  }
  static constexpr SchedulingState SchedulingState_MIN =
    PlacementGroupStats_SchedulingState_SchedulingState_MIN;
  static constexpr SchedulingState SchedulingState_MAX =
    PlacementGroupStats_SchedulingState_SchedulingState_MAX;
  static constexpr int SchedulingState_ARRAYSIZE =
    PlacementGroupStats_SchedulingState_SchedulingState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SchedulingState_descriptor() {
    return PlacementGroupStats_SchedulingState_descriptor();
  }
  template<typename T>
  static inline const std::string& SchedulingState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SchedulingState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SchedulingState_Name.");
    return PlacementGroupStats_SchedulingState_Name(enum_t_value);
  }
  static inline bool SchedulingState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SchedulingState* value) {
    return PlacementGroupStats_SchedulingState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCreationRequestReceivedNsFieldNumber = 2,
    kSchedulingStartedTimeNsFieldNumber = 3,
    kSchedulingLatencyUsFieldNumber = 4,
    kEndToEndCreationLatencyUsFieldNumber = 5,
    kHighestRetryDelayMsFieldNumber = 7,
    kSchedulingAttemptFieldNumber = 6,
    kSchedulingStateFieldNumber = 8,
  };
  // int64 creation_request_received_ns = 2;
  void clear_creation_request_received_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 creation_request_received_ns() const;
  void set_creation_request_received_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_creation_request_received_ns() const;
  void _internal_set_creation_request_received_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 scheduling_started_time_ns = 3;
  void clear_scheduling_started_time_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 scheduling_started_time_ns() const;
  void set_scheduling_started_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_scheduling_started_time_ns() const;
  void _internal_set_scheduling_started_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 scheduling_latency_us = 4;
  void clear_scheduling_latency_us();
  ::PROTOBUF_NAMESPACE_ID::int64 scheduling_latency_us() const;
  void set_scheduling_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_scheduling_latency_us() const;
  void _internal_set_scheduling_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end_to_end_creation_latency_us = 5;
  void clear_end_to_end_creation_latency_us();
  ::PROTOBUF_NAMESPACE_ID::int64 end_to_end_creation_latency_us() const;
  void set_end_to_end_creation_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_to_end_creation_latency_us() const;
  void _internal_set_end_to_end_creation_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double highest_retry_delay_ms = 7;
  void clear_highest_retry_delay_ms();
  double highest_retry_delay_ms() const;
  void set_highest_retry_delay_ms(double value);
  private:
  double _internal_highest_retry_delay_ms() const;
  void _internal_set_highest_retry_delay_ms(double value);
  public:

  // uint32 scheduling_attempt = 6;
  void clear_scheduling_attempt();
  ::PROTOBUF_NAMESPACE_ID::uint32 scheduling_attempt() const;
  void set_scheduling_attempt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_scheduling_attempt() const;
  void _internal_set_scheduling_attempt(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .mcs.rpc.PlacementGroupStats.SchedulingState scheduling_state = 8;
  void clear_scheduling_state();
  ::mcs::rpc::PlacementGroupStats_SchedulingState scheduling_state() const;
  void set_scheduling_state(::mcs::rpc::PlacementGroupStats_SchedulingState value);
  private:
  ::mcs::rpc::PlacementGroupStats_SchedulingState _internal_scheduling_state() const;
  void _internal_set_scheduling_state(::mcs::rpc::PlacementGroupStats_SchedulingState value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.PlacementGroupStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 creation_request_received_ns_;
  ::PROTOBUF_NAMESPACE_ID::int64 scheduling_started_time_ns_;
  ::PROTOBUF_NAMESPACE_ID::int64 scheduling_latency_us_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_to_end_creation_latency_us_;
  double highest_retry_delay_ms_;
  ::PROTOBUF_NAMESPACE_ID::uint32 scheduling_attempt_;
  int scheduling_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// -------------------------------------------------------------------

class PlacementGroupTableData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.PlacementGroupTableData) */ {
 public:
  inline PlacementGroupTableData() : PlacementGroupTableData(nullptr) {}
  ~PlacementGroupTableData() override;
  explicit constexpr PlacementGroupTableData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlacementGroupTableData(const PlacementGroupTableData& from);
  PlacementGroupTableData(PlacementGroupTableData&& from) noexcept
    : PlacementGroupTableData() {
    *this = ::std::move(from);
  }

  inline PlacementGroupTableData& operator=(const PlacementGroupTableData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlacementGroupTableData& operator=(PlacementGroupTableData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlacementGroupTableData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlacementGroupTableData* internal_default_instance() {
    return reinterpret_cast<const PlacementGroupTableData*>(
               &_PlacementGroupTableData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(PlacementGroupTableData& a, PlacementGroupTableData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlacementGroupTableData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlacementGroupTableData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlacementGroupTableData* New() const final {
    return new PlacementGroupTableData();
  }

  PlacementGroupTableData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlacementGroupTableData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlacementGroupTableData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlacementGroupTableData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlacementGroupTableData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.PlacementGroupTableData";
  }
  protected:
  explicit PlacementGroupTableData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PlacementGroupTableData_PlacementGroupState PlacementGroupState;
  static constexpr PlacementGroupState PENDING =
    PlacementGroupTableData_PlacementGroupState_PENDING;
  static constexpr PlacementGroupState CREATED =
    PlacementGroupTableData_PlacementGroupState_CREATED;
  static constexpr PlacementGroupState REMOVED =
    PlacementGroupTableData_PlacementGroupState_REMOVED;
  static constexpr PlacementGroupState RESCHEDULING =
    PlacementGroupTableData_PlacementGroupState_RESCHEDULING;
  static inline bool PlacementGroupState_IsValid(int value) {
    return PlacementGroupTableData_PlacementGroupState_IsValid(value);
  }
  static constexpr PlacementGroupState PlacementGroupState_MIN =
    PlacementGroupTableData_PlacementGroupState_PlacementGroupState_MIN;
  static constexpr PlacementGroupState PlacementGroupState_MAX =
    PlacementGroupTableData_PlacementGroupState_PlacementGroupState_MAX;
  static constexpr int PlacementGroupState_ARRAYSIZE =
    PlacementGroupTableData_PlacementGroupState_PlacementGroupState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PlacementGroupState_descriptor() {
    return PlacementGroupTableData_PlacementGroupState_descriptor();
  }
  template<typename T>
  static inline const std::string& PlacementGroupState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlacementGroupState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlacementGroupState_Name.");
    return PlacementGroupTableData_PlacementGroupState_Name(enum_t_value);
  }
  static inline bool PlacementGroupState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlacementGroupState* value) {
    return PlacementGroupTableData_PlacementGroupState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBundlesFieldNumber = 3,
    kPlacementGroupIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatorJobIdFieldNumber = 6,
    kCreatorActorIdFieldNumber = 7,
    kMcsNamespaceFieldNumber = 11,
    kStatsFieldNumber = 12,
    kStrategyFieldNumber = 4,
    kStateFieldNumber = 5,
    kMaxCpuFractionPerNodeFieldNumber = 13,
    kCreatorJobDeadFieldNumber = 8,
    kCreatorActorDeadFieldNumber = 9,
    kIsDetachedFieldNumber = 10,
  };
  // repeated .mcs.rpc.Bundle bundles = 3;
  int bundles_size() const;
  private:
  int _internal_bundles_size() const;
  public:
  void clear_bundles();
  ::mcs::rpc::Bundle* mutable_bundles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >*
      mutable_bundles();
  private:
  const ::mcs::rpc::Bundle& _internal_bundles(int index) const;
  ::mcs::rpc::Bundle* _internal_add_bundles();
  public:
  const ::mcs::rpc::Bundle& bundles(int index) const;
  ::mcs::rpc::Bundle* add_bundles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >&
      bundles() const;

  // bytes placement_group_id = 1;
  void clear_placement_group_id();
  const std::string& placement_group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_placement_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_placement_group_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_placement_group_id();
  void set_allocated_placement_group_id(std::string* placement_group_id);
  private:
  const std::string& _internal_placement_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placement_group_id(const std::string& value);
  std::string* _internal_mutable_placement_group_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes creator_job_id = 6;
  void clear_creator_job_id();
  const std::string& creator_job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_creator_job_id();
  void set_allocated_creator_job_id(std::string* creator_job_id);
  private:
  const std::string& _internal_creator_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_job_id(const std::string& value);
  std::string* _internal_mutable_creator_job_id();
  public:

  // bytes creator_actor_id = 7;
  void clear_creator_actor_id();
  const std::string& creator_actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_creator_actor_id();
  void set_allocated_creator_actor_id(std::string* creator_actor_id);
  private:
  const std::string& _internal_creator_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_actor_id(const std::string& value);
  std::string* _internal_mutable_creator_actor_id();
  public:

  // string mcs_namespace = 11;
  void clear_mcs_namespace();
  const std::string& mcs_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcs_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcs_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcs_namespace();
  void set_allocated_mcs_namespace(std::string* mcs_namespace);
  private:
  const std::string& _internal_mcs_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcs_namespace(const std::string& value);
  std::string* _internal_mutable_mcs_namespace();
  public:

  // .mcs.rpc.PlacementGroupStats stats = 12;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::mcs::rpc::PlacementGroupStats& stats() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::PlacementGroupStats* release_stats();
  ::mcs::rpc::PlacementGroupStats* mutable_stats();
  void set_allocated_stats(::mcs::rpc::PlacementGroupStats* stats);
  private:
  const ::mcs::rpc::PlacementGroupStats& _internal_stats() const;
  ::mcs::rpc::PlacementGroupStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::mcs::rpc::PlacementGroupStats* stats);
  ::mcs::rpc::PlacementGroupStats* unsafe_arena_release_stats();

  // .mcs.rpc.PlacementStrategy strategy = 4;
  void clear_strategy();
  ::mcs::rpc::PlacementStrategy strategy() const;
  void set_strategy(::mcs::rpc::PlacementStrategy value);
  private:
  ::mcs::rpc::PlacementStrategy _internal_strategy() const;
  void _internal_set_strategy(::mcs::rpc::PlacementStrategy value);
  public:

  // .mcs.rpc.PlacementGroupTableData.PlacementGroupState state = 5;
  void clear_state();
  ::mcs::rpc::PlacementGroupTableData_PlacementGroupState state() const;
  void set_state(::mcs::rpc::PlacementGroupTableData_PlacementGroupState value);
  private:
  ::mcs::rpc::PlacementGroupTableData_PlacementGroupState _internal_state() const;
  void _internal_set_state(::mcs::rpc::PlacementGroupTableData_PlacementGroupState value);
  public:

  // double max_cpu_fraction_per_node = 13;
  void clear_max_cpu_fraction_per_node();
  double max_cpu_fraction_per_node() const;
  void set_max_cpu_fraction_per_node(double value);
  private:
  double _internal_max_cpu_fraction_per_node() const;
  void _internal_set_max_cpu_fraction_per_node(double value);
  public:

  // bool creator_job_dead = 8;
  void clear_creator_job_dead();
  bool creator_job_dead() const;
  void set_creator_job_dead(bool value);
  private:
  bool _internal_creator_job_dead() const;
  void _internal_set_creator_job_dead(bool value);
  public:

  // bool creator_actor_dead = 9;
  void clear_creator_actor_dead();
  bool creator_actor_dead() const;
  void set_creator_actor_dead(bool value);
  private:
  bool _internal_creator_actor_dead() const;
  void _internal_set_creator_actor_dead(bool value);
  public:

  // bool is_detached = 10;
  void clear_is_detached();
  bool is_detached() const;
  void set_is_detached(bool value);
  private:
  bool _internal_is_detached() const;
  void _internal_set_is_detached(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.PlacementGroupTableData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle > bundles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placement_group_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_actor_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcs_namespace_;
  ::mcs::rpc::PlacementGroupStats* stats_;
  int strategy_;
  int state_;
  double max_cpu_fraction_per_node_;
  bool creator_job_dead_;
  bool creator_actor_dead_;
  bool is_detached_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gcs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GcsEntry

// .mcs.rpc.GcsChangeMode change_mode = 1;
inline void GcsEntry::clear_change_mode() {
  change_mode_ = 0;
}
inline ::mcs::rpc::GcsChangeMode GcsEntry::_internal_change_mode() const {
  return static_cast< ::mcs::rpc::GcsChangeMode >(change_mode_);
}
inline ::mcs::rpc::GcsChangeMode GcsEntry::change_mode() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsEntry.change_mode)
  return _internal_change_mode();
}
inline void GcsEntry::_internal_set_change_mode(::mcs::rpc::GcsChangeMode value) {
  
  change_mode_ = value;
}
inline void GcsEntry::set_change_mode(::mcs::rpc::GcsChangeMode value) {
  _internal_set_change_mode(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsEntry.change_mode)
}

// bytes id = 2;
inline void GcsEntry::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GcsEntry::id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsEntry.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcsEntry::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsEntry.id)
}
inline std::string* GcsEntry::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsEntry.id)
  return _s;
}
inline const std::string& GcsEntry::_internal_id() const {
  return id_.Get();
}
inline void GcsEntry::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GcsEntry::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GcsEntry::release_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.GcsEntry.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GcsEntry::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.GcsEntry.id)
}

// repeated bytes entries = 3;
inline int GcsEntry::_internal_entries_size() const {
  return entries_.size();
}
inline int GcsEntry::entries_size() const {
  return _internal_entries_size();
}
inline void GcsEntry::clear_entries() {
  entries_.Clear();
}
inline std::string* GcsEntry::add_entries() {
  std::string* _s = _internal_add_entries();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.GcsEntry.entries)
  return _s;
}
inline const std::string& GcsEntry::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const std::string& GcsEntry::entries(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsEntry.entries)
  return _internal_entries(index);
}
inline std::string* GcsEntry::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsEntry.entries)
  return entries_.Mutable(index);
}
inline void GcsEntry::set_entries(int index, const std::string& value) {
  entries_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsEntry.entries)
}
inline void GcsEntry::set_entries(int index, std::string&& value) {
  entries_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsEntry.entries)
}
inline void GcsEntry::set_entries(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  entries_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.GcsEntry.entries)
}
inline void GcsEntry::set_entries(int index, const void* value, size_t size) {
  entries_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.GcsEntry.entries)
}
inline std::string* GcsEntry::_internal_add_entries() {
  return entries_.Add();
}
inline void GcsEntry::add_entries(const std::string& value) {
  entries_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.GcsEntry.entries)
}
inline void GcsEntry::add_entries(std::string&& value) {
  entries_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.GcsEntry.entries)
}
inline void GcsEntry::add_entries(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  entries_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.GcsEntry.entries)
}
inline void GcsEntry::add_entries(const void* value, size_t size) {
  entries_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.GcsEntry.entries)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GcsEntry::entries() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.GcsEntry.entries)
  return entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GcsEntry::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.GcsEntry.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// ObjectTableData

// bytes manager = 1;
inline void ObjectTableData::clear_manager() {
  manager_.ClearToEmpty();
}
inline const std::string& ObjectTableData::manager() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectTableData.manager)
  return _internal_manager();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectTableData::set_manager(ArgT0&& arg0, ArgT... args) {
 
 manager_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectTableData.manager)
}
inline std::string* ObjectTableData::mutable_manager() {
  std::string* _s = _internal_mutable_manager();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectTableData.manager)
  return _s;
}
inline const std::string& ObjectTableData::_internal_manager() const {
  return manager_.Get();
}
inline void ObjectTableData::_internal_set_manager(const std::string& value) {
  
  manager_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectTableData::_internal_mutable_manager() {
  
  return manager_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectTableData::release_manager() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ObjectTableData.manager)
  return manager_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectTableData::set_allocated_manager(std::string* manager) {
  if (manager != nullptr) {
    
  } else {
    
  }
  manager_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manager,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ObjectTableData.manager)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ActorTableData

// bytes actor_id = 1;
inline void ActorTableData::clear_actor_id() {
  actor_id_.ClearToEmpty();
}
inline const std::string& ActorTableData::actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_actor_id(ArgT0&& arg0, ArgT... args) {
 
 actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.actor_id)
}
inline std::string* ActorTableData::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.actor_id)
  return _s;
}
inline const std::string& ActorTableData::_internal_actor_id() const {
  return actor_id_.Get();
}
inline void ActorTableData::_internal_set_actor_id(const std::string& value) {
  
  actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_actor_id() {
  
  return actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.actor_id)
  return actor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.actor_id)
}

// bytes parent_id = 2;
inline void ActorTableData::clear_parent_id() {
  parent_id_.ClearToEmpty();
}
inline const std::string& ActorTableData::parent_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.parent_id)
  return _internal_parent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_parent_id(ArgT0&& arg0, ArgT... args) {
 
 parent_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.parent_id)
}
inline std::string* ActorTableData::mutable_parent_id() {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.parent_id)
  return _s;
}
inline const std::string& ActorTableData::_internal_parent_id() const {
  return parent_id_.Get();
}
inline void ActorTableData::_internal_set_parent_id(const std::string& value) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_parent_id() {
  
  return parent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_parent_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.parent_id)
  return parent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    
  } else {
    
  }
  parent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.parent_id)
}

// bytes actor_creation_dummy_object_id = 3;
inline void ActorTableData::clear_actor_creation_dummy_object_id() {
  actor_creation_dummy_object_id_.ClearToEmpty();
}
inline const std::string& ActorTableData::actor_creation_dummy_object_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.actor_creation_dummy_object_id)
  return _internal_actor_creation_dummy_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_actor_creation_dummy_object_id(ArgT0&& arg0, ArgT... args) {
 
 actor_creation_dummy_object_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.actor_creation_dummy_object_id)
}
inline std::string* ActorTableData::mutable_actor_creation_dummy_object_id() {
  std::string* _s = _internal_mutable_actor_creation_dummy_object_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.actor_creation_dummy_object_id)
  return _s;
}
inline const std::string& ActorTableData::_internal_actor_creation_dummy_object_id() const {
  return actor_creation_dummy_object_id_.Get();
}
inline void ActorTableData::_internal_set_actor_creation_dummy_object_id(const std::string& value) {
  
  actor_creation_dummy_object_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_actor_creation_dummy_object_id() {
  
  return actor_creation_dummy_object_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_actor_creation_dummy_object_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.actor_creation_dummy_object_id)
  return actor_creation_dummy_object_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_actor_creation_dummy_object_id(std::string* actor_creation_dummy_object_id) {
  if (actor_creation_dummy_object_id != nullptr) {
    
  } else {
    
  }
  actor_creation_dummy_object_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_creation_dummy_object_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.actor_creation_dummy_object_id)
}

// bytes job_id = 4;
inline void ActorTableData::clear_job_id() {
  job_id_.ClearToEmpty();
}
inline const std::string& ActorTableData::job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.job_id)
}
inline std::string* ActorTableData::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.job_id)
  return _s;
}
inline const std::string& ActorTableData::_internal_job_id() const {
  return job_id_.Get();
}
inline void ActorTableData::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_job_id() {
  
  return job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.job_id)
}

// .mcs.rpc.ActorTableData.ActorState state = 6;
inline void ActorTableData::clear_state() {
  state_ = 0;
}
inline ::mcs::rpc::ActorTableData_ActorState ActorTableData::_internal_state() const {
  return static_cast< ::mcs::rpc::ActorTableData_ActorState >(state_);
}
inline ::mcs::rpc::ActorTableData_ActorState ActorTableData::state() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.state)
  return _internal_state();
}
inline void ActorTableData::_internal_set_state(::mcs::rpc::ActorTableData_ActorState value) {
  
  state_ = value;
}
inline void ActorTableData::set_state(::mcs::rpc::ActorTableData_ActorState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.state)
}

// int64 max_restarts = 7;
inline void ActorTableData::clear_max_restarts() {
  max_restarts_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ActorTableData::_internal_max_restarts() const {
  return max_restarts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ActorTableData::max_restarts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.max_restarts)
  return _internal_max_restarts();
}
inline void ActorTableData::_internal_set_max_restarts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  max_restarts_ = value;
}
inline void ActorTableData::set_max_restarts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_restarts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.max_restarts)
}

// uint64 num_restarts = 8;
inline void ActorTableData::clear_num_restarts() {
  num_restarts_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTableData::_internal_num_restarts() const {
  return num_restarts_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTableData::num_restarts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.num_restarts)
  return _internal_num_restarts();
}
inline void ActorTableData::_internal_set_num_restarts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  num_restarts_ = value;
}
inline void ActorTableData::set_num_restarts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_num_restarts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.num_restarts)
}

// .mcs.rpc.Address address = 9;
inline bool ActorTableData::_internal_has_address() const {
  return this != internal_default_instance() && address_ != nullptr;
}
inline bool ActorTableData::has_address() const {
  return _internal_has_address();
}
inline const ::mcs::rpc::Address& ActorTableData::_internal_address() const {
  const ::mcs::rpc::Address* p = address_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::Address&>(
      ::mcs::rpc::_Address_default_instance_);
}
inline const ::mcs::rpc::Address& ActorTableData::address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.address)
  return _internal_address();
}
inline void ActorTableData::unsafe_arena_set_allocated_address(
    ::mcs::rpc::Address* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address_);
  }
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorTableData.address)
}
inline ::mcs::rpc::Address* ActorTableData::release_address() {
  
  ::mcs::rpc::Address* temp = address_;
  address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::Address* ActorTableData::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.address)
  
  ::mcs::rpc::Address* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::mcs::rpc::Address* ActorTableData::_internal_mutable_address() {
  
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::Address>(GetArenaForAllocation());
    address_ = p;
  }
  return address_;
}
inline ::mcs::rpc::Address* ActorTableData::mutable_address() {
  ::mcs::rpc::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.address)
  return _msg;
}
inline void ActorTableData::set_allocated_address(::mcs::rpc::Address* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(address_);
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address));
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.address)
}

// .mcs.rpc.Address owner_address = 10;
inline bool ActorTableData::_internal_has_owner_address() const {
  return this != internal_default_instance() && owner_address_ != nullptr;
}
inline bool ActorTableData::has_owner_address() const {
  return _internal_has_owner_address();
}
inline const ::mcs::rpc::Address& ActorTableData::_internal_owner_address() const {
  const ::mcs::rpc::Address* p = owner_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::Address&>(
      ::mcs::rpc::_Address_default_instance_);
}
inline const ::mcs::rpc::Address& ActorTableData::owner_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.owner_address)
  return _internal_owner_address();
}
inline void ActorTableData::unsafe_arena_set_allocated_owner_address(
    ::mcs::rpc::Address* owner_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_address_);
  }
  owner_address_ = owner_address;
  if (owner_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorTableData.owner_address)
}
inline ::mcs::rpc::Address* ActorTableData::release_owner_address() {
  
  ::mcs::rpc::Address* temp = owner_address_;
  owner_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::Address* ActorTableData::unsafe_arena_release_owner_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.owner_address)
  
  ::mcs::rpc::Address* temp = owner_address_;
  owner_address_ = nullptr;
  return temp;
}
inline ::mcs::rpc::Address* ActorTableData::_internal_mutable_owner_address() {
  
  if (owner_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::Address>(GetArenaForAllocation());
    owner_address_ = p;
  }
  return owner_address_;
}
inline ::mcs::rpc::Address* ActorTableData::mutable_owner_address() {
  ::mcs::rpc::Address* _msg = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.owner_address)
  return _msg;
}
inline void ActorTableData::set_allocated_owner_address(::mcs::rpc::Address* owner_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_address_);
  }
  if (owner_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_address));
    if (message_arena != submessage_arena) {
      owner_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_address, submessage_arena);
    }
    
  } else {
    
  }
  owner_address_ = owner_address;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.owner_address)
}

// bool is_detached = 11;
inline void ActorTableData::clear_is_detached() {
  is_detached_ = false;
}
inline bool ActorTableData::_internal_is_detached() const {
  return is_detached_;
}
inline bool ActorTableData::is_detached() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.is_detached)
  return _internal_is_detached();
}
inline void ActorTableData::_internal_set_is_detached(bool value) {
  
  is_detached_ = value;
}
inline void ActorTableData::set_is_detached(bool value) {
  _internal_set_is_detached(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.is_detached)
}

// string name = 12;
inline void ActorTableData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ActorTableData::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.name)
}
inline std::string* ActorTableData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.name)
  return _s;
}
inline const std::string& ActorTableData::_internal_name() const {
  return name_.Get();
}
inline void ActorTableData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.name)
}

// double timestamp = 13;
inline void ActorTableData::clear_timestamp() {
  timestamp_ = 0;
}
inline double ActorTableData::_internal_timestamp() const {
  return timestamp_;
}
inline double ActorTableData::timestamp() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.timestamp)
  return _internal_timestamp();
}
inline void ActorTableData::_internal_set_timestamp(double value) {
  
  timestamp_ = value;
}
inline void ActorTableData::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.timestamp)
}

// repeated .mcs.rpc.ResourceMapEntry resource_mapping = 15;
inline int ActorTableData::_internal_resource_mapping_size() const {
  return resource_mapping_.size();
}
inline int ActorTableData::resource_mapping_size() const {
  return _internal_resource_mapping_size();
}
inline ::mcs::rpc::ResourceMapEntry* ActorTableData::mutable_resource_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.resource_mapping)
  return resource_mapping_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceMapEntry >*
ActorTableData::mutable_resource_mapping() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ActorTableData.resource_mapping)
  return &resource_mapping_;
}
inline const ::mcs::rpc::ResourceMapEntry& ActorTableData::_internal_resource_mapping(int index) const {
  return resource_mapping_.Get(index);
}
inline const ::mcs::rpc::ResourceMapEntry& ActorTableData::resource_mapping(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.resource_mapping)
  return _internal_resource_mapping(index);
}
inline ::mcs::rpc::ResourceMapEntry* ActorTableData::_internal_add_resource_mapping() {
  return resource_mapping_.Add();
}
inline ::mcs::rpc::ResourceMapEntry* ActorTableData::add_resource_mapping() {
  ::mcs::rpc::ResourceMapEntry* _add = _internal_add_resource_mapping();
  // @@protoc_insertion_point(field_add:mcs.rpc.ActorTableData.resource_mapping)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceMapEntry >&
ActorTableData::resource_mapping() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ActorTableData.resource_mapping)
  return resource_mapping_;
}

// uint32 pid = 16;
inline void ActorTableData::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActorTableData::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActorTableData::pid() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.pid)
  return _internal_pid();
}
inline void ActorTableData::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void ActorTableData::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.pid)
}

// .mcs.rpc.FunctionDescriptor function_descriptor = 17;
inline bool ActorTableData::_internal_has_function_descriptor() const {
  return this != internal_default_instance() && function_descriptor_ != nullptr;
}
inline bool ActorTableData::has_function_descriptor() const {
  return _internal_has_function_descriptor();
}
inline const ::mcs::rpc::FunctionDescriptor& ActorTableData::_internal_function_descriptor() const {
  const ::mcs::rpc::FunctionDescriptor* p = function_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::FunctionDescriptor&>(
      ::mcs::rpc::_FunctionDescriptor_default_instance_);
}
inline const ::mcs::rpc::FunctionDescriptor& ActorTableData::function_descriptor() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.function_descriptor)
  return _internal_function_descriptor();
}
inline void ActorTableData::unsafe_arena_set_allocated_function_descriptor(
    ::mcs::rpc::FunctionDescriptor* function_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_descriptor_);
  }
  function_descriptor_ = function_descriptor;
  if (function_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorTableData.function_descriptor)
}
inline ::mcs::rpc::FunctionDescriptor* ActorTableData::release_function_descriptor() {
  
  ::mcs::rpc::FunctionDescriptor* temp = function_descriptor_;
  function_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::FunctionDescriptor* ActorTableData::unsafe_arena_release_function_descriptor() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.function_descriptor)
  
  ::mcs::rpc::FunctionDescriptor* temp = function_descriptor_;
  function_descriptor_ = nullptr;
  return temp;
}
inline ::mcs::rpc::FunctionDescriptor* ActorTableData::_internal_mutable_function_descriptor() {
  
  if (function_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::FunctionDescriptor>(GetArenaForAllocation());
    function_descriptor_ = p;
  }
  return function_descriptor_;
}
inline ::mcs::rpc::FunctionDescriptor* ActorTableData::mutable_function_descriptor() {
  ::mcs::rpc::FunctionDescriptor* _msg = _internal_mutable_function_descriptor();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.function_descriptor)
  return _msg;
}
inline void ActorTableData::set_allocated_function_descriptor(::mcs::rpc::FunctionDescriptor* function_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_descriptor_);
  }
  if (function_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_descriptor));
    if (message_arena != submessage_arena) {
      function_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  function_descriptor_ = function_descriptor;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.function_descriptor)
}

// string mcs_namespace = 19;
inline void ActorTableData::clear_mcs_namespace() {
  mcs_namespace_.ClearToEmpty();
}
inline const std::string& ActorTableData::mcs_namespace() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.mcs_namespace)
  return _internal_mcs_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_mcs_namespace(ArgT0&& arg0, ArgT... args) {
 
 mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.mcs_namespace)
}
inline std::string* ActorTableData::mutable_mcs_namespace() {
  std::string* _s = _internal_mutable_mcs_namespace();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.mcs_namespace)
  return _s;
}
inline const std::string& ActorTableData::_internal_mcs_namespace() const {
  return mcs_namespace_.Get();
}
inline void ActorTableData::_internal_set_mcs_namespace(const std::string& value) {
  
  mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_mcs_namespace() {
  
  return mcs_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_mcs_namespace() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.mcs_namespace)
  return mcs_namespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_mcs_namespace(std::string* mcs_namespace) {
  if (mcs_namespace != nullptr) {
    
  } else {
    
  }
  mcs_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcs_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.mcs_namespace)
}

// uint64 start_time = 20;
inline void ActorTableData::clear_start_time() {
  start_time_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTableData::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTableData::start_time() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.start_time)
  return _internal_start_time();
}
inline void ActorTableData::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_time_ = value;
}
inline void ActorTableData::set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.start_time)
}

// uint64 end_time = 21;
inline void ActorTableData::clear_end_time() {
  end_time_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTableData::_internal_end_time() const {
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTableData::end_time() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.end_time)
  return _internal_end_time();
}
inline void ActorTableData::_internal_set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_time_ = value;
}
inline void ActorTableData::set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.end_time)
}

// string serialized_runtime_env = 22;
inline void ActorTableData::clear_serialized_runtime_env() {
  serialized_runtime_env_.ClearToEmpty();
}
inline const std::string& ActorTableData::serialized_runtime_env() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.serialized_runtime_env)
  return _internal_serialized_runtime_env();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_serialized_runtime_env(ArgT0&& arg0, ArgT... args) {
 
 serialized_runtime_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.serialized_runtime_env)
}
inline std::string* ActorTableData::mutable_serialized_runtime_env() {
  std::string* _s = _internal_mutable_serialized_runtime_env();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.serialized_runtime_env)
  return _s;
}
inline const std::string& ActorTableData::_internal_serialized_runtime_env() const {
  return serialized_runtime_env_.Get();
}
inline void ActorTableData::_internal_set_serialized_runtime_env(const std::string& value) {
  
  serialized_runtime_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_serialized_runtime_env() {
  
  return serialized_runtime_env_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_serialized_runtime_env() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.serialized_runtime_env)
  return serialized_runtime_env_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_serialized_runtime_env(std::string* serialized_runtime_env) {
  if (serialized_runtime_env != nullptr) {
    
  } else {
    
  }
  serialized_runtime_env_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_runtime_env,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.serialized_runtime_env)
}

// string class_name = 23;
inline void ActorTableData::clear_class_name() {
  class_name_.ClearToEmpty();
}
inline const std::string& ActorTableData::class_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.class_name)
}
inline std::string* ActorTableData::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.class_name)
  return _s;
}
inline const std::string& ActorTableData::_internal_class_name() const {
  return class_name_.Get();
}
inline void ActorTableData::_internal_set_class_name(const std::string& value) {
  
  class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_class_name() {
  
  return class_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_class_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.class_name)
  return class_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  class_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), class_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.class_name)
}

// .mcs.rpc.ActorDeathCause death_cause = 24;
inline bool ActorTableData::_internal_has_death_cause() const {
  return this != internal_default_instance() && death_cause_ != nullptr;
}
inline bool ActorTableData::has_death_cause() const {
  return _internal_has_death_cause();
}
inline const ::mcs::rpc::ActorDeathCause& ActorTableData::_internal_death_cause() const {
  const ::mcs::rpc::ActorDeathCause* p = death_cause_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ActorDeathCause&>(
      ::mcs::rpc::_ActorDeathCause_default_instance_);
}
inline const ::mcs::rpc::ActorDeathCause& ActorTableData::death_cause() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.death_cause)
  return _internal_death_cause();
}
inline void ActorTableData::unsafe_arena_set_allocated_death_cause(
    ::mcs::rpc::ActorDeathCause* death_cause) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(death_cause_);
  }
  death_cause_ = death_cause;
  if (death_cause) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorTableData.death_cause)
}
inline ::mcs::rpc::ActorDeathCause* ActorTableData::release_death_cause() {
  
  ::mcs::rpc::ActorDeathCause* temp = death_cause_;
  death_cause_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ActorDeathCause* ActorTableData::unsafe_arena_release_death_cause() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.death_cause)
  
  ::mcs::rpc::ActorDeathCause* temp = death_cause_;
  death_cause_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ActorDeathCause* ActorTableData::_internal_mutable_death_cause() {
  
  if (death_cause_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ActorDeathCause>(GetArenaForAllocation());
    death_cause_ = p;
  }
  return death_cause_;
}
inline ::mcs::rpc::ActorDeathCause* ActorTableData::mutable_death_cause() {
  ::mcs::rpc::ActorDeathCause* _msg = _internal_mutable_death_cause();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.death_cause)
  return _msg;
}
inline void ActorTableData::set_allocated_death_cause(::mcs::rpc::ActorDeathCause* death_cause) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(death_cause_);
  }
  if (death_cause) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(death_cause));
    if (message_arena != submessage_arena) {
      death_cause = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, death_cause, submessage_arena);
    }
    
  } else {
    
  }
  death_cause_ = death_cause;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.death_cause)
}

// map<string, double> required_resources = 28;
inline int ActorTableData::_internal_required_resources_size() const {
  return required_resources_.size();
}
inline int ActorTableData::required_resources_size() const {
  return _internal_required_resources_size();
}
inline void ActorTableData::clear_required_resources() {
  required_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ActorTableData::_internal_required_resources() const {
  return required_resources_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ActorTableData::required_resources() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ActorTableData.required_resources)
  return _internal_required_resources();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ActorTableData::_internal_mutable_required_resources() {
  return required_resources_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ActorTableData::mutable_required_resources() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ActorTableData.required_resources)
  return _internal_mutable_required_resources();
}

// optional bytes node_id = 29;
inline bool ActorTableData::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActorTableData::has_node_id() const {
  return _internal_has_node_id();
}
inline void ActorTableData::clear_node_id() {
  node_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActorTableData::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTableData.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTableData::set_node_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTableData.node_id)
}
inline std::string* ActorTableData::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTableData.node_id)
  return _s;
}
inline const std::string& ActorTableData::_internal_node_id() const {
  return node_id_.Get();
}
inline void ActorTableData::_internal_set_node_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTableData::_internal_mutable_node_id() {
  _has_bits_[0] |= 0x00000001u;
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTableData::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTableData.node_id)
  if (!_internal_has_node_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return node_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTableData::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTableData.node_id)
}

// -------------------------------------------------------------------

// ErrorTableData

// bytes job_id = 1;
inline void ErrorTableData::clear_job_id() {
  job_id_.ClearToEmpty();
}
inline const std::string& ErrorTableData::job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ErrorTableData.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorTableData::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ErrorTableData.job_id)
}
inline std::string* ErrorTableData::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ErrorTableData.job_id)
  return _s;
}
inline const std::string& ErrorTableData::_internal_job_id() const {
  return job_id_.Get();
}
inline void ErrorTableData::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ErrorTableData::_internal_mutable_job_id() {
  
  return job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ErrorTableData::release_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ErrorTableData.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ErrorTableData::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ErrorTableData.job_id)
}

// string type = 2;
inline void ErrorTableData::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ErrorTableData::type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ErrorTableData.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorTableData::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ErrorTableData.type)
}
inline std::string* ErrorTableData::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ErrorTableData.type)
  return _s;
}
inline const std::string& ErrorTableData::_internal_type() const {
  return type_.Get();
}
inline void ErrorTableData::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ErrorTableData::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ErrorTableData::release_type() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ErrorTableData.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ErrorTableData::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ErrorTableData.type)
}

// string error_message = 3;
inline void ErrorTableData::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& ErrorTableData::error_message() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ErrorTableData.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorTableData::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ErrorTableData.error_message)
}
inline std::string* ErrorTableData::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ErrorTableData.error_message)
  return _s;
}
inline const std::string& ErrorTableData::_internal_error_message() const {
  return error_message_.Get();
}
inline void ErrorTableData::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ErrorTableData::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ErrorTableData::release_error_message() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ErrorTableData.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ErrorTableData::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ErrorTableData.error_message)
}

// double timestamp = 4;
inline void ErrorTableData::clear_timestamp() {
  timestamp_ = 0;
}
inline double ErrorTableData::_internal_timestamp() const {
  return timestamp_;
}
inline double ErrorTableData::timestamp() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ErrorTableData.timestamp)
  return _internal_timestamp();
}
inline void ErrorTableData::_internal_set_timestamp(double value) {
  
  timestamp_ = value;
}
inline void ErrorTableData::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ErrorTableData.timestamp)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ScheduleData

// map<string, bytes> schedule_plan = 1;
inline int ScheduleData::_internal_schedule_plan_size() const {
  return schedule_plan_.size();
}
inline int ScheduleData::schedule_plan_size() const {
  return _internal_schedule_plan_size();
}
inline void ScheduleData::clear_schedule_plan() {
  schedule_plan_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ScheduleData::_internal_schedule_plan() const {
  return schedule_plan_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ScheduleData::schedule_plan() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ScheduleData.schedule_plan)
  return _internal_schedule_plan();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ScheduleData::_internal_mutable_schedule_plan() {
  return schedule_plan_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ScheduleData::mutable_schedule_plan() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ScheduleData.schedule_plan)
  return _internal_mutable_schedule_plan();
}

// -------------------------------------------------------------------

// ProfileEventEntry

// int64 start_time = 1;
inline void ProfileEventEntry::clear_start_time() {
  start_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProfileEventEntry::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProfileEventEntry::start_time() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEventEntry.start_time)
  return _internal_start_time();
}
inline void ProfileEventEntry::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_time_ = value;
}
inline void ProfileEventEntry::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ProfileEventEntry.start_time)
}

// int64 end_time = 2;
inline void ProfileEventEntry::clear_end_time() {
  end_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProfileEventEntry::_internal_end_time() const {
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProfileEventEntry::end_time() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEventEntry.end_time)
  return _internal_end_time();
}
inline void ProfileEventEntry::_internal_set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_time_ = value;
}
inline void ProfileEventEntry::set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ProfileEventEntry.end_time)
}

// optional string extra_data = 3;
inline bool ProfileEventEntry::_internal_has_extra_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProfileEventEntry::has_extra_data() const {
  return _internal_has_extra_data();
}
inline void ProfileEventEntry::clear_extra_data() {
  extra_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProfileEventEntry::extra_data() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEventEntry.extra_data)
  return _internal_extra_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileEventEntry::set_extra_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 extra_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ProfileEventEntry.extra_data)
}
inline std::string* ProfileEventEntry::mutable_extra_data() {
  std::string* _s = _internal_mutable_extra_data();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ProfileEventEntry.extra_data)
  return _s;
}
inline const std::string& ProfileEventEntry::_internal_extra_data() const {
  return extra_data_.Get();
}
inline void ProfileEventEntry::_internal_set_extra_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileEventEntry::_internal_mutable_extra_data() {
  _has_bits_[0] |= 0x00000001u;
  return extra_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileEventEntry::release_extra_data() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ProfileEventEntry.extra_data)
  if (!_internal_has_extra_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return extra_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileEventEntry::set_allocated_extra_data(std::string* extra_data) {
  if (extra_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ProfileEventEntry.extra_data)
}

// string event_name = 4;
inline void ProfileEventEntry::clear_event_name() {
  event_name_.ClearToEmpty();
}
inline const std::string& ProfileEventEntry::event_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEventEntry.event_name)
  return _internal_event_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileEventEntry::set_event_name(ArgT0&& arg0, ArgT... args) {
 
 event_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ProfileEventEntry.event_name)
}
inline std::string* ProfileEventEntry::mutable_event_name() {
  std::string* _s = _internal_mutable_event_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ProfileEventEntry.event_name)
  return _s;
}
inline const std::string& ProfileEventEntry::_internal_event_name() const {
  return event_name_.Get();
}
inline void ProfileEventEntry::_internal_set_event_name(const std::string& value) {
  
  event_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileEventEntry::_internal_mutable_event_name() {
  
  return event_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileEventEntry::release_event_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ProfileEventEntry.event_name)
  return event_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileEventEntry::set_allocated_event_name(std::string* event_name) {
  if (event_name != nullptr) {
    
  } else {
    
  }
  event_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ProfileEventEntry.event_name)
}

// -------------------------------------------------------------------

// ProfileEvents

// string component_type = 1;
inline void ProfileEvents::clear_component_type() {
  component_type_.ClearToEmpty();
}
inline const std::string& ProfileEvents::component_type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEvents.component_type)
  return _internal_component_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileEvents::set_component_type(ArgT0&& arg0, ArgT... args) {
 
 component_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ProfileEvents.component_type)
}
inline std::string* ProfileEvents::mutable_component_type() {
  std::string* _s = _internal_mutable_component_type();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ProfileEvents.component_type)
  return _s;
}
inline const std::string& ProfileEvents::_internal_component_type() const {
  return component_type_.Get();
}
inline void ProfileEvents::_internal_set_component_type(const std::string& value) {
  
  component_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileEvents::_internal_mutable_component_type() {
  
  return component_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileEvents::release_component_type() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ProfileEvents.component_type)
  return component_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileEvents::set_allocated_component_type(std::string* component_type) {
  if (component_type != nullptr) {
    
  } else {
    
  }
  component_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), component_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ProfileEvents.component_type)
}

// bytes component_id = 2;
inline void ProfileEvents::clear_component_id() {
  component_id_.ClearToEmpty();
}
inline const std::string& ProfileEvents::component_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEvents.component_id)
  return _internal_component_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileEvents::set_component_id(ArgT0&& arg0, ArgT... args) {
 
 component_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ProfileEvents.component_id)
}
inline std::string* ProfileEvents::mutable_component_id() {
  std::string* _s = _internal_mutable_component_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ProfileEvents.component_id)
  return _s;
}
inline const std::string& ProfileEvents::_internal_component_id() const {
  return component_id_.Get();
}
inline void ProfileEvents::_internal_set_component_id(const std::string& value) {
  
  component_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileEvents::_internal_mutable_component_id() {
  
  return component_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileEvents::release_component_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ProfileEvents.component_id)
  return component_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileEvents::set_allocated_component_id(std::string* component_id) {
  if (component_id != nullptr) {
    
  } else {
    
  }
  component_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), component_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ProfileEvents.component_id)
}

// string node_ip_address = 3;
inline void ProfileEvents::clear_node_ip_address() {
  node_ip_address_.ClearToEmpty();
}
inline const std::string& ProfileEvents::node_ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEvents.node_ip_address)
  return _internal_node_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileEvents::set_node_ip_address(ArgT0&& arg0, ArgT... args) {
 
 node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ProfileEvents.node_ip_address)
}
inline std::string* ProfileEvents::mutable_node_ip_address() {
  std::string* _s = _internal_mutable_node_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ProfileEvents.node_ip_address)
  return _s;
}
inline const std::string& ProfileEvents::_internal_node_ip_address() const {
  return node_ip_address_.Get();
}
inline void ProfileEvents::_internal_set_node_ip_address(const std::string& value) {
  
  node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileEvents::_internal_mutable_node_ip_address() {
  
  return node_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileEvents::release_node_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ProfileEvents.node_ip_address)
  return node_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileEvents::set_allocated_node_ip_address(std::string* node_ip_address) {
  if (node_ip_address != nullptr) {
    
  } else {
    
  }
  node_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ProfileEvents.node_ip_address)
}

// repeated .mcs.rpc.ProfileEventEntry events = 4;
inline int ProfileEvents::_internal_events_size() const {
  return events_.size();
}
inline int ProfileEvents::events_size() const {
  return _internal_events_size();
}
inline void ProfileEvents::clear_events() {
  events_.Clear();
}
inline ::mcs::rpc::ProfileEventEntry* ProfileEvents::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ProfileEvents.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ProfileEventEntry >*
ProfileEvents::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ProfileEvents.events)
  return &events_;
}
inline const ::mcs::rpc::ProfileEventEntry& ProfileEvents::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::mcs::rpc::ProfileEventEntry& ProfileEvents::events(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ProfileEvents.events)
  return _internal_events(index);
}
inline ::mcs::rpc::ProfileEventEntry* ProfileEvents::_internal_add_events() {
  return events_.Add();
}
inline ::mcs::rpc::ProfileEventEntry* ProfileEvents::add_events() {
  ::mcs::rpc::ProfileEventEntry* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:mcs.rpc.ProfileEvents.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ProfileEventEntry >&
ProfileEvents::events() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ProfileEvents.events)
  return events_;
}

// -------------------------------------------------------------------

// TaskStateUpdate

// optional bytes node_id = 1;
inline bool TaskStateUpdate::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TaskStateUpdate::has_node_id() const {
  return _internal_has_node_id();
}
inline void TaskStateUpdate::clear_node_id() {
  node_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaskStateUpdate::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskStateUpdate.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskStateUpdate::set_node_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskStateUpdate.node_id)
}
inline std::string* TaskStateUpdate::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskStateUpdate.node_id)
  return _s;
}
inline const std::string& TaskStateUpdate::_internal_node_id() const {
  return node_id_.Get();
}
inline void TaskStateUpdate::_internal_set_node_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskStateUpdate::_internal_mutable_node_id() {
  _has_bits_[0] |= 0x00000001u;
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskStateUpdate::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskStateUpdate.node_id)
  if (!_internal_has_node_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return node_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskStateUpdate::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskStateUpdate.node_id)
}

// optional int64 pending_args_avail_ts = 2;
inline bool TaskStateUpdate::_internal_has_pending_args_avail_ts() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TaskStateUpdate::has_pending_args_avail_ts() const {
  return _internal_has_pending_args_avail_ts();
}
inline void TaskStateUpdate::clear_pending_args_avail_ts() {
  pending_args_avail_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::_internal_pending_args_avail_ts() const {
  return pending_args_avail_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::pending_args_avail_ts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskStateUpdate.pending_args_avail_ts)
  return _internal_pending_args_avail_ts();
}
inline void TaskStateUpdate::_internal_set_pending_args_avail_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  pending_args_avail_ts_ = value;
}
inline void TaskStateUpdate::set_pending_args_avail_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pending_args_avail_ts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskStateUpdate.pending_args_avail_ts)
}

// optional int64 pending_node_assignment_ts = 3;
inline bool TaskStateUpdate::_internal_has_pending_node_assignment_ts() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TaskStateUpdate::has_pending_node_assignment_ts() const {
  return _internal_has_pending_node_assignment_ts();
}
inline void TaskStateUpdate::clear_pending_node_assignment_ts() {
  pending_node_assignment_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::_internal_pending_node_assignment_ts() const {
  return pending_node_assignment_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::pending_node_assignment_ts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskStateUpdate.pending_node_assignment_ts)
  return _internal_pending_node_assignment_ts();
}
inline void TaskStateUpdate::_internal_set_pending_node_assignment_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  pending_node_assignment_ts_ = value;
}
inline void TaskStateUpdate::set_pending_node_assignment_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pending_node_assignment_ts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskStateUpdate.pending_node_assignment_ts)
}

// optional int64 submitted_to_worker_ts = 4;
inline bool TaskStateUpdate::_internal_has_submitted_to_worker_ts() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TaskStateUpdate::has_submitted_to_worker_ts() const {
  return _internal_has_submitted_to_worker_ts();
}
inline void TaskStateUpdate::clear_submitted_to_worker_ts() {
  submitted_to_worker_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::_internal_submitted_to_worker_ts() const {
  return submitted_to_worker_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::submitted_to_worker_ts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskStateUpdate.submitted_to_worker_ts)
  return _internal_submitted_to_worker_ts();
}
inline void TaskStateUpdate::_internal_set_submitted_to_worker_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  submitted_to_worker_ts_ = value;
}
inline void TaskStateUpdate::set_submitted_to_worker_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_submitted_to_worker_ts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskStateUpdate.submitted_to_worker_ts)
}

// optional int64 running_ts = 5;
inline bool TaskStateUpdate::_internal_has_running_ts() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TaskStateUpdate::has_running_ts() const {
  return _internal_has_running_ts();
}
inline void TaskStateUpdate::clear_running_ts() {
  running_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::_internal_running_ts() const {
  return running_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::running_ts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskStateUpdate.running_ts)
  return _internal_running_ts();
}
inline void TaskStateUpdate::_internal_set_running_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  running_ts_ = value;
}
inline void TaskStateUpdate::set_running_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_running_ts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskStateUpdate.running_ts)
}

// optional int64 finished_ts = 6;
inline bool TaskStateUpdate::_internal_has_finished_ts() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TaskStateUpdate::has_finished_ts() const {
  return _internal_has_finished_ts();
}
inline void TaskStateUpdate::clear_finished_ts() {
  finished_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::_internal_finished_ts() const {
  return finished_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::finished_ts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskStateUpdate.finished_ts)
  return _internal_finished_ts();
}
inline void TaskStateUpdate::_internal_set_finished_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  finished_ts_ = value;
}
inline void TaskStateUpdate::set_finished_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_finished_ts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskStateUpdate.finished_ts)
}

// optional int64 failed_ts = 7;
inline bool TaskStateUpdate::_internal_has_failed_ts() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TaskStateUpdate::has_failed_ts() const {
  return _internal_has_failed_ts();
}
inline void TaskStateUpdate::clear_failed_ts() {
  failed_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::_internal_failed_ts() const {
  return failed_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskStateUpdate::failed_ts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskStateUpdate.failed_ts)
  return _internal_failed_ts();
}
inline void TaskStateUpdate::_internal_set_failed_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  failed_ts_ = value;
}
inline void TaskStateUpdate::set_failed_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_failed_ts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskStateUpdate.failed_ts)
}

// -------------------------------------------------------------------

// TaskEvents

// bytes task_id = 1;
inline void TaskEvents::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& TaskEvents::task_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEvents.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskEvents::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskEvents.task_id)
}
inline std::string* TaskEvents::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskEvents.task_id)
  return _s;
}
inline const std::string& TaskEvents::_internal_task_id() const {
  return task_id_.Get();
}
inline void TaskEvents::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskEvents::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskEvents::release_task_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskEvents.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskEvents::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskEvents.task_id)
}

// int32 attempt_number = 2;
inline void TaskEvents::clear_attempt_number() {
  attempt_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskEvents::_internal_attempt_number() const {
  return attempt_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskEvents::attempt_number() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEvents.attempt_number)
  return _internal_attempt_number();
}
inline void TaskEvents::_internal_set_attempt_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attempt_number_ = value;
}
inline void TaskEvents::set_attempt_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attempt_number(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskEvents.attempt_number)
}

// optional .mcs.rpc.TaskInfoEntry task_info = 3;
inline bool TaskEvents::_internal_has_task_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || task_info_ != nullptr);
  return value;
}
inline bool TaskEvents::has_task_info() const {
  return _internal_has_task_info();
}
inline const ::mcs::rpc::TaskInfoEntry& TaskEvents::_internal_task_info() const {
  const ::mcs::rpc::TaskInfoEntry* p = task_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::TaskInfoEntry&>(
      ::mcs::rpc::_TaskInfoEntry_default_instance_);
}
inline const ::mcs::rpc::TaskInfoEntry& TaskEvents::task_info() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEvents.task_info)
  return _internal_task_info();
}
inline void TaskEvents::unsafe_arena_set_allocated_task_info(
    ::mcs::rpc::TaskInfoEntry* task_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_info_);
  }
  task_info_ = task_info;
  if (task_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskEvents.task_info)
}
inline ::mcs::rpc::TaskInfoEntry* TaskEvents::release_task_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::mcs::rpc::TaskInfoEntry* temp = task_info_;
  task_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::TaskInfoEntry* TaskEvents::unsafe_arena_release_task_info() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskEvents.task_info)
  _has_bits_[0] &= ~0x00000001u;
  ::mcs::rpc::TaskInfoEntry* temp = task_info_;
  task_info_ = nullptr;
  return temp;
}
inline ::mcs::rpc::TaskInfoEntry* TaskEvents::_internal_mutable_task_info() {
  _has_bits_[0] |= 0x00000001u;
  if (task_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::TaskInfoEntry>(GetArenaForAllocation());
    task_info_ = p;
  }
  return task_info_;
}
inline ::mcs::rpc::TaskInfoEntry* TaskEvents::mutable_task_info() {
  ::mcs::rpc::TaskInfoEntry* _msg = _internal_mutable_task_info();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskEvents.task_info)
  return _msg;
}
inline void TaskEvents::set_allocated_task_info(::mcs::rpc::TaskInfoEntry* task_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_info_);
  }
  if (task_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_info));
    if (message_arena != submessage_arena) {
      task_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  task_info_ = task_info;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskEvents.task_info)
}

// optional .mcs.rpc.TaskStateUpdate state_updates = 4;
inline bool TaskEvents::_internal_has_state_updates() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || state_updates_ != nullptr);
  return value;
}
inline bool TaskEvents::has_state_updates() const {
  return _internal_has_state_updates();
}
inline void TaskEvents::clear_state_updates() {
  if (state_updates_ != nullptr) state_updates_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mcs::rpc::TaskStateUpdate& TaskEvents::_internal_state_updates() const {
  const ::mcs::rpc::TaskStateUpdate* p = state_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::TaskStateUpdate&>(
      ::mcs::rpc::_TaskStateUpdate_default_instance_);
}
inline const ::mcs::rpc::TaskStateUpdate& TaskEvents::state_updates() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEvents.state_updates)
  return _internal_state_updates();
}
inline void TaskEvents::unsafe_arena_set_allocated_state_updates(
    ::mcs::rpc::TaskStateUpdate* state_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_updates_);
  }
  state_updates_ = state_updates;
  if (state_updates) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskEvents.state_updates)
}
inline ::mcs::rpc::TaskStateUpdate* TaskEvents::release_state_updates() {
  _has_bits_[0] &= ~0x00000002u;
  ::mcs::rpc::TaskStateUpdate* temp = state_updates_;
  state_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::TaskStateUpdate* TaskEvents::unsafe_arena_release_state_updates() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskEvents.state_updates)
  _has_bits_[0] &= ~0x00000002u;
  ::mcs::rpc::TaskStateUpdate* temp = state_updates_;
  state_updates_ = nullptr;
  return temp;
}
inline ::mcs::rpc::TaskStateUpdate* TaskEvents::_internal_mutable_state_updates() {
  _has_bits_[0] |= 0x00000002u;
  if (state_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::TaskStateUpdate>(GetArenaForAllocation());
    state_updates_ = p;
  }
  return state_updates_;
}
inline ::mcs::rpc::TaskStateUpdate* TaskEvents::mutable_state_updates() {
  ::mcs::rpc::TaskStateUpdate* _msg = _internal_mutable_state_updates();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskEvents.state_updates)
  return _msg;
}
inline void TaskEvents::set_allocated_state_updates(::mcs::rpc::TaskStateUpdate* state_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete state_updates_;
  }
  if (state_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::TaskStateUpdate>::GetOwningArena(state_updates);
    if (message_arena != submessage_arena) {
      state_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_updates, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  state_updates_ = state_updates;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskEvents.state_updates)
}

// optional .mcs.rpc.ProfileEvents profile_events = 5;
inline bool TaskEvents::_internal_has_profile_events() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || profile_events_ != nullptr);
  return value;
}
inline bool TaskEvents::has_profile_events() const {
  return _internal_has_profile_events();
}
inline void TaskEvents::clear_profile_events() {
  if (profile_events_ != nullptr) profile_events_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mcs::rpc::ProfileEvents& TaskEvents::_internal_profile_events() const {
  const ::mcs::rpc::ProfileEvents* p = profile_events_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ProfileEvents&>(
      ::mcs::rpc::_ProfileEvents_default_instance_);
}
inline const ::mcs::rpc::ProfileEvents& TaskEvents::profile_events() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEvents.profile_events)
  return _internal_profile_events();
}
inline void TaskEvents::unsafe_arena_set_allocated_profile_events(
    ::mcs::rpc::ProfileEvents* profile_events) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profile_events_);
  }
  profile_events_ = profile_events;
  if (profile_events) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskEvents.profile_events)
}
inline ::mcs::rpc::ProfileEvents* TaskEvents::release_profile_events() {
  _has_bits_[0] &= ~0x00000004u;
  ::mcs::rpc::ProfileEvents* temp = profile_events_;
  profile_events_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ProfileEvents* TaskEvents::unsafe_arena_release_profile_events() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskEvents.profile_events)
  _has_bits_[0] &= ~0x00000004u;
  ::mcs::rpc::ProfileEvents* temp = profile_events_;
  profile_events_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ProfileEvents* TaskEvents::_internal_mutable_profile_events() {
  _has_bits_[0] |= 0x00000004u;
  if (profile_events_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ProfileEvents>(GetArenaForAllocation());
    profile_events_ = p;
  }
  return profile_events_;
}
inline ::mcs::rpc::ProfileEvents* TaskEvents::mutable_profile_events() {
  ::mcs::rpc::ProfileEvents* _msg = _internal_mutable_profile_events();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskEvents.profile_events)
  return _msg;
}
inline void TaskEvents::set_allocated_profile_events(::mcs::rpc::ProfileEvents* profile_events) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete profile_events_;
  }
  if (profile_events) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::ProfileEvents>::GetOwningArena(profile_events);
    if (message_arena != submessage_arena) {
      profile_events = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile_events, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  profile_events_ = profile_events;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskEvents.profile_events)
}

// bytes job_id = 6;
inline void TaskEvents::clear_job_id() {
  job_id_.ClearToEmpty();
}
inline const std::string& TaskEvents::job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEvents.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskEvents::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskEvents.job_id)
}
inline std::string* TaskEvents::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskEvents.job_id)
  return _s;
}
inline const std::string& TaskEvents::_internal_job_id() const {
  return job_id_.Get();
}
inline void TaskEvents::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskEvents::_internal_mutable_job_id() {
  
  return job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskEvents::release_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskEvents.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskEvents::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskEvents.job_id)
}

// -------------------------------------------------------------------

// TaskEventData

// repeated .mcs.rpc.TaskEvents events_by_task = 1;
inline int TaskEventData::_internal_events_by_task_size() const {
  return events_by_task_.size();
}
inline int TaskEventData::events_by_task_size() const {
  return _internal_events_by_task_size();
}
inline void TaskEventData::clear_events_by_task() {
  events_by_task_.Clear();
}
inline ::mcs::rpc::TaskEvents* TaskEventData::mutable_events_by_task(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskEventData.events_by_task)
  return events_by_task_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskEvents >*
TaskEventData::mutable_events_by_task() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.TaskEventData.events_by_task)
  return &events_by_task_;
}
inline const ::mcs::rpc::TaskEvents& TaskEventData::_internal_events_by_task(int index) const {
  return events_by_task_.Get(index);
}
inline const ::mcs::rpc::TaskEvents& TaskEventData::events_by_task(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEventData.events_by_task)
  return _internal_events_by_task(index);
}
inline ::mcs::rpc::TaskEvents* TaskEventData::_internal_add_events_by_task() {
  return events_by_task_.Add();
}
inline ::mcs::rpc::TaskEvents* TaskEventData::add_events_by_task() {
  ::mcs::rpc::TaskEvents* _add = _internal_add_events_by_task();
  // @@protoc_insertion_point(field_add:mcs.rpc.TaskEventData.events_by_task)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskEvents >&
TaskEventData::events_by_task() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.TaskEventData.events_by_task)
  return events_by_task_;
}

// int32 num_profile_task_events_dropped = 3;
inline void TaskEventData::clear_num_profile_task_events_dropped() {
  num_profile_task_events_dropped_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskEventData::_internal_num_profile_task_events_dropped() const {
  return num_profile_task_events_dropped_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskEventData::num_profile_task_events_dropped() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEventData.num_profile_task_events_dropped)
  return _internal_num_profile_task_events_dropped();
}
inline void TaskEventData::_internal_set_num_profile_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_profile_task_events_dropped_ = value;
}
inline void TaskEventData::set_num_profile_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_profile_task_events_dropped(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskEventData.num_profile_task_events_dropped)
}

// int32 num_status_task_events_dropped = 4;
inline void TaskEventData::clear_num_status_task_events_dropped() {
  num_status_task_events_dropped_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskEventData::_internal_num_status_task_events_dropped() const {
  return num_status_task_events_dropped_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskEventData::num_status_task_events_dropped() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskEventData.num_status_task_events_dropped)
  return _internal_num_status_task_events_dropped();
}
inline void TaskEventData::_internal_set_num_status_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_status_task_events_dropped_ = value;
}
inline void TaskEventData::set_num_status_task_events_dropped(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_status_task_events_dropped(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskEventData.num_status_task_events_dropped)
}

// -------------------------------------------------------------------

// ResourceTableData

// double resource_capacity = 1;
inline void ResourceTableData::clear_resource_capacity() {
  resource_capacity_ = 0;
}
inline double ResourceTableData::_internal_resource_capacity() const {
  return resource_capacity_;
}
inline double ResourceTableData::resource_capacity() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceTableData.resource_capacity)
  return _internal_resource_capacity();
}
inline void ResourceTableData::_internal_set_resource_capacity(double value) {
  
  resource_capacity_ = value;
}
inline void ResourceTableData::set_resource_capacity(double value) {
  _internal_set_resource_capacity(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceTableData.resource_capacity)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AvailableResources

// bytes node_id = 1;
inline void AvailableResources::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& AvailableResources::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.AvailableResources.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvailableResources::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.AvailableResources.node_id)
}
inline std::string* AvailableResources::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.AvailableResources.node_id)
  return _s;
}
inline const std::string& AvailableResources::_internal_node_id() const {
  return node_id_.Get();
}
inline void AvailableResources::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AvailableResources::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AvailableResources::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.AvailableResources.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AvailableResources::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.AvailableResources.node_id)
}

// map<string, double> resources_available = 2;
inline int AvailableResources::_internal_resources_available_size() const {
  return resources_available_.size();
}
inline int AvailableResources::resources_available_size() const {
  return _internal_resources_available_size();
}
inline void AvailableResources::clear_resources_available() {
  resources_available_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AvailableResources::_internal_resources_available() const {
  return resources_available_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AvailableResources::resources_available() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.AvailableResources.resources_available)
  return _internal_resources_available();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AvailableResources::_internal_mutable_resources_available() {
  return resources_available_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AvailableResources::mutable_resources_available() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.AvailableResources.resources_available)
  return _internal_mutable_resources_available();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GcsNodeInfo

// bytes node_id = 1;
inline void GcsNodeInfo::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& GcsNodeInfo::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcsNodeInfo::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.node_id)
}
inline std::string* GcsNodeInfo::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsNodeInfo.node_id)
  return _s;
}
inline const std::string& GcsNodeInfo::_internal_node_id() const {
  return node_id_.Get();
}
inline void GcsNodeInfo::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.GcsNodeInfo.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GcsNodeInfo::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.GcsNodeInfo.node_id)
}

// string node_manager_address = 2;
inline void GcsNodeInfo::clear_node_manager_address() {
  node_manager_address_.ClearToEmpty();
}
inline const std::string& GcsNodeInfo::node_manager_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.node_manager_address)
  return _internal_node_manager_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcsNodeInfo::set_node_manager_address(ArgT0&& arg0, ArgT... args) {
 
 node_manager_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.node_manager_address)
}
inline std::string* GcsNodeInfo::mutable_node_manager_address() {
  std::string* _s = _internal_mutable_node_manager_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsNodeInfo.node_manager_address)
  return _s;
}
inline const std::string& GcsNodeInfo::_internal_node_manager_address() const {
  return node_manager_address_.Get();
}
inline void GcsNodeInfo::_internal_set_node_manager_address(const std::string& value) {
  
  node_manager_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::_internal_mutable_node_manager_address() {
  
  return node_manager_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::release_node_manager_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.GcsNodeInfo.node_manager_address)
  return node_manager_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GcsNodeInfo::set_allocated_node_manager_address(std::string* node_manager_address) {
  if (node_manager_address != nullptr) {
    
  } else {
    
  }
  node_manager_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_manager_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.GcsNodeInfo.node_manager_address)
}

// string mcslet_socket_name = 3;
inline void GcsNodeInfo::clear_mcslet_socket_name() {
  mcslet_socket_name_.ClearToEmpty();
}
inline const std::string& GcsNodeInfo::mcslet_socket_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.mcslet_socket_name)
  return _internal_mcslet_socket_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcsNodeInfo::set_mcslet_socket_name(ArgT0&& arg0, ArgT... args) {
 
 mcslet_socket_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.mcslet_socket_name)
}
inline std::string* GcsNodeInfo::mutable_mcslet_socket_name() {
  std::string* _s = _internal_mutable_mcslet_socket_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsNodeInfo.mcslet_socket_name)
  return _s;
}
inline const std::string& GcsNodeInfo::_internal_mcslet_socket_name() const {
  return mcslet_socket_name_.Get();
}
inline void GcsNodeInfo::_internal_set_mcslet_socket_name(const std::string& value) {
  
  mcslet_socket_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::_internal_mutable_mcslet_socket_name() {
  
  return mcslet_socket_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::release_mcslet_socket_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.GcsNodeInfo.mcslet_socket_name)
  return mcslet_socket_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GcsNodeInfo::set_allocated_mcslet_socket_name(std::string* mcslet_socket_name) {
  if (mcslet_socket_name != nullptr) {
    
  } else {
    
  }
  mcslet_socket_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcslet_socket_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.GcsNodeInfo.mcslet_socket_name)
}

// string object_store_socket_name = 4;
inline void GcsNodeInfo::clear_object_store_socket_name() {
  object_store_socket_name_.ClearToEmpty();
}
inline const std::string& GcsNodeInfo::object_store_socket_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.object_store_socket_name)
  return _internal_object_store_socket_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcsNodeInfo::set_object_store_socket_name(ArgT0&& arg0, ArgT... args) {
 
 object_store_socket_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.object_store_socket_name)
}
inline std::string* GcsNodeInfo::mutable_object_store_socket_name() {
  std::string* _s = _internal_mutable_object_store_socket_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsNodeInfo.object_store_socket_name)
  return _s;
}
inline const std::string& GcsNodeInfo::_internal_object_store_socket_name() const {
  return object_store_socket_name_.Get();
}
inline void GcsNodeInfo::_internal_set_object_store_socket_name(const std::string& value) {
  
  object_store_socket_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::_internal_mutable_object_store_socket_name() {
  
  return object_store_socket_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::release_object_store_socket_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.GcsNodeInfo.object_store_socket_name)
  return object_store_socket_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GcsNodeInfo::set_allocated_object_store_socket_name(std::string* object_store_socket_name) {
  if (object_store_socket_name != nullptr) {
    
  } else {
    
  }
  object_store_socket_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), object_store_socket_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.GcsNodeInfo.object_store_socket_name)
}

// int32 node_manager_port = 5;
inline void GcsNodeInfo::clear_node_manager_port() {
  node_manager_port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GcsNodeInfo::_internal_node_manager_port() const {
  return node_manager_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GcsNodeInfo::node_manager_port() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.node_manager_port)
  return _internal_node_manager_port();
}
inline void GcsNodeInfo::_internal_set_node_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_manager_port_ = value;
}
inline void GcsNodeInfo::set_node_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_manager_port(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.node_manager_port)
}

// int32 object_manager_port = 6;
inline void GcsNodeInfo::clear_object_manager_port() {
  object_manager_port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GcsNodeInfo::_internal_object_manager_port() const {
  return object_manager_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GcsNodeInfo::object_manager_port() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.object_manager_port)
  return _internal_object_manager_port();
}
inline void GcsNodeInfo::_internal_set_object_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  object_manager_port_ = value;
}
inline void GcsNodeInfo::set_object_manager_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_object_manager_port(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.object_manager_port)
}

// .mcs.rpc.GcsNodeInfo.GcsNodeState state = 7;
inline void GcsNodeInfo::clear_state() {
  state_ = 0;
}
inline ::mcs::rpc::GcsNodeInfo_GcsNodeState GcsNodeInfo::_internal_state() const {
  return static_cast< ::mcs::rpc::GcsNodeInfo_GcsNodeState >(state_);
}
inline ::mcs::rpc::GcsNodeInfo_GcsNodeState GcsNodeInfo::state() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.state)
  return _internal_state();
}
inline void GcsNodeInfo::_internal_set_state(::mcs::rpc::GcsNodeInfo_GcsNodeState value) {
  
  state_ = value;
}
inline void GcsNodeInfo::set_state(::mcs::rpc::GcsNodeInfo_GcsNodeState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.state)
}

// string node_manager_hostname = 8;
inline void GcsNodeInfo::clear_node_manager_hostname() {
  node_manager_hostname_.ClearToEmpty();
}
inline const std::string& GcsNodeInfo::node_manager_hostname() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.node_manager_hostname)
  return _internal_node_manager_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcsNodeInfo::set_node_manager_hostname(ArgT0&& arg0, ArgT... args) {
 
 node_manager_hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.node_manager_hostname)
}
inline std::string* GcsNodeInfo::mutable_node_manager_hostname() {
  std::string* _s = _internal_mutable_node_manager_hostname();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsNodeInfo.node_manager_hostname)
  return _s;
}
inline const std::string& GcsNodeInfo::_internal_node_manager_hostname() const {
  return node_manager_hostname_.Get();
}
inline void GcsNodeInfo::_internal_set_node_manager_hostname(const std::string& value) {
  
  node_manager_hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::_internal_mutable_node_manager_hostname() {
  
  return node_manager_hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::release_node_manager_hostname() {
  // @@protoc_insertion_point(field_release:mcs.rpc.GcsNodeInfo.node_manager_hostname)
  return node_manager_hostname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GcsNodeInfo::set_allocated_node_manager_hostname(std::string* node_manager_hostname) {
  if (node_manager_hostname != nullptr) {
    
  } else {
    
  }
  node_manager_hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_manager_hostname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.GcsNodeInfo.node_manager_hostname)
}

// int32 metrics_export_port = 9;
inline void GcsNodeInfo::clear_metrics_export_port() {
  metrics_export_port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GcsNodeInfo::_internal_metrics_export_port() const {
  return metrics_export_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GcsNodeInfo::metrics_export_port() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.metrics_export_port)
  return _internal_metrics_export_port();
}
inline void GcsNodeInfo::_internal_set_metrics_export_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  metrics_export_port_ = value;
}
inline void GcsNodeInfo::set_metrics_export_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_metrics_export_port(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.metrics_export_port)
}

// int64 timestamp = 10;
inline void GcsNodeInfo::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GcsNodeInfo::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GcsNodeInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.timestamp)
  return _internal_timestamp();
}
inline void GcsNodeInfo::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void GcsNodeInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.timestamp)
}

// map<string, double> resources_total = 11;
inline int GcsNodeInfo::_internal_resources_total_size() const {
  return resources_total_.size();
}
inline int GcsNodeInfo::resources_total_size() const {
  return _internal_resources_total_size();
}
inline void GcsNodeInfo::clear_resources_total() {
  resources_total_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
GcsNodeInfo::_internal_resources_total() const {
  return resources_total_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
GcsNodeInfo::resources_total() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.GcsNodeInfo.resources_total)
  return _internal_resources_total();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
GcsNodeInfo::_internal_mutable_resources_total() {
  return resources_total_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
GcsNodeInfo::mutable_resources_total() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.GcsNodeInfo.resources_total)
  return _internal_mutable_resources_total();
}

// string node_name = 12;
inline void GcsNodeInfo::clear_node_name() {
  node_name_.ClearToEmpty();
}
inline const std::string& GcsNodeInfo::node_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.GcsNodeInfo.node_name)
  return _internal_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GcsNodeInfo::set_node_name(ArgT0&& arg0, ArgT... args) {
 
 node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.GcsNodeInfo.node_name)
}
inline std::string* GcsNodeInfo::mutable_node_name() {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.GcsNodeInfo.node_name)
  return _s;
}
inline const std::string& GcsNodeInfo::_internal_node_name() const {
  return node_name_.Get();
}
inline void GcsNodeInfo::_internal_set_node_name(const std::string& value) {
  
  node_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::_internal_mutable_node_name() {
  
  return node_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GcsNodeInfo::release_node_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.GcsNodeInfo.node_name)
  return node_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GcsNodeInfo::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    
  } else {
    
  }
  node_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.GcsNodeInfo.node_name)
}

// -------------------------------------------------------------------

// HeartbeatTableData

// bytes node_id = 1;
inline void HeartbeatTableData::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& HeartbeatTableData::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.HeartbeatTableData.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatTableData::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.HeartbeatTableData.node_id)
}
inline std::string* HeartbeatTableData::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.HeartbeatTableData.node_id)
  return _s;
}
inline const std::string& HeartbeatTableData::_internal_node_id() const {
  return node_id_.Get();
}
inline void HeartbeatTableData::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HeartbeatTableData::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HeartbeatTableData::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.HeartbeatTableData.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HeartbeatTableData::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.HeartbeatTableData.node_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// JobConfig

// repeated string jvm_options = 2;
inline int JobConfig::_internal_jvm_options_size() const {
  return jvm_options_.size();
}
inline int JobConfig::jvm_options_size() const {
  return _internal_jvm_options_size();
}
inline void JobConfig::clear_jvm_options() {
  jvm_options_.Clear();
}
inline std::string* JobConfig::add_jvm_options() {
  std::string* _s = _internal_add_jvm_options();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.JobConfig.jvm_options)
  return _s;
}
inline const std::string& JobConfig::_internal_jvm_options(int index) const {
  return jvm_options_.Get(index);
}
inline const std::string& JobConfig::jvm_options(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobConfig.jvm_options)
  return _internal_jvm_options(index);
}
inline std::string* JobConfig::mutable_jvm_options(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobConfig.jvm_options)
  return jvm_options_.Mutable(index);
}
inline void JobConfig::set_jvm_options(int index, const std::string& value) {
  jvm_options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobConfig.jvm_options)
}
inline void JobConfig::set_jvm_options(int index, std::string&& value) {
  jvm_options_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.JobConfig.jvm_options)
}
inline void JobConfig::set_jvm_options(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  jvm_options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.JobConfig.jvm_options)
}
inline void JobConfig::set_jvm_options(int index, const char* value, size_t size) {
  jvm_options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.JobConfig.jvm_options)
}
inline std::string* JobConfig::_internal_add_jvm_options() {
  return jvm_options_.Add();
}
inline void JobConfig::add_jvm_options(const std::string& value) {
  jvm_options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.JobConfig.jvm_options)
}
inline void JobConfig::add_jvm_options(std::string&& value) {
  jvm_options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.JobConfig.jvm_options)
}
inline void JobConfig::add_jvm_options(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  jvm_options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.JobConfig.jvm_options)
}
inline void JobConfig::add_jvm_options(const char* value, size_t size) {
  jvm_options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.JobConfig.jvm_options)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JobConfig::jvm_options() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.JobConfig.jvm_options)
  return jvm_options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JobConfig::mutable_jvm_options() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.JobConfig.jvm_options)
  return &jvm_options_;
}

// repeated string code_search_path = 3;
inline int JobConfig::_internal_code_search_path_size() const {
  return code_search_path_.size();
}
inline int JobConfig::code_search_path_size() const {
  return _internal_code_search_path_size();
}
inline void JobConfig::clear_code_search_path() {
  code_search_path_.Clear();
}
inline std::string* JobConfig::add_code_search_path() {
  std::string* _s = _internal_add_code_search_path();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.JobConfig.code_search_path)
  return _s;
}
inline const std::string& JobConfig::_internal_code_search_path(int index) const {
  return code_search_path_.Get(index);
}
inline const std::string& JobConfig::code_search_path(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobConfig.code_search_path)
  return _internal_code_search_path(index);
}
inline std::string* JobConfig::mutable_code_search_path(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobConfig.code_search_path)
  return code_search_path_.Mutable(index);
}
inline void JobConfig::set_code_search_path(int index, const std::string& value) {
  code_search_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobConfig.code_search_path)
}
inline void JobConfig::set_code_search_path(int index, std::string&& value) {
  code_search_path_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.JobConfig.code_search_path)
}
inline void JobConfig::set_code_search_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  code_search_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.JobConfig.code_search_path)
}
inline void JobConfig::set_code_search_path(int index, const char* value, size_t size) {
  code_search_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.JobConfig.code_search_path)
}
inline std::string* JobConfig::_internal_add_code_search_path() {
  return code_search_path_.Add();
}
inline void JobConfig::add_code_search_path(const std::string& value) {
  code_search_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.JobConfig.code_search_path)
}
inline void JobConfig::add_code_search_path(std::string&& value) {
  code_search_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.JobConfig.code_search_path)
}
inline void JobConfig::add_code_search_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  code_search_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.JobConfig.code_search_path)
}
inline void JobConfig::add_code_search_path(const char* value, size_t size) {
  code_search_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.JobConfig.code_search_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JobConfig::code_search_path() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.JobConfig.code_search_path)
  return code_search_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JobConfig::mutable_code_search_path() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.JobConfig.code_search_path)
  return &code_search_path_;
}

// .mcs.rpc.RuntimeEnvInfo runtime_env_info = 4;
inline bool JobConfig::_internal_has_runtime_env_info() const {
  return this != internal_default_instance() && runtime_env_info_ != nullptr;
}
inline bool JobConfig::has_runtime_env_info() const {
  return _internal_has_runtime_env_info();
}
inline const ::mcs::rpc::RuntimeEnvInfo& JobConfig::_internal_runtime_env_info() const {
  const ::mcs::rpc::RuntimeEnvInfo* p = runtime_env_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::RuntimeEnvInfo&>(
      ::mcs::rpc::_RuntimeEnvInfo_default_instance_);
}
inline const ::mcs::rpc::RuntimeEnvInfo& JobConfig::runtime_env_info() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobConfig.runtime_env_info)
  return _internal_runtime_env_info();
}
inline void JobConfig::unsafe_arena_set_allocated_runtime_env_info(
    ::mcs::rpc::RuntimeEnvInfo* runtime_env_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info_);
  }
  runtime_env_info_ = runtime_env_info;
  if (runtime_env_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.JobConfig.runtime_env_info)
}
inline ::mcs::rpc::RuntimeEnvInfo* JobConfig::release_runtime_env_info() {
  
  ::mcs::rpc::RuntimeEnvInfo* temp = runtime_env_info_;
  runtime_env_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::RuntimeEnvInfo* JobConfig::unsafe_arena_release_runtime_env_info() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JobConfig.runtime_env_info)
  
  ::mcs::rpc::RuntimeEnvInfo* temp = runtime_env_info_;
  runtime_env_info_ = nullptr;
  return temp;
}
inline ::mcs::rpc::RuntimeEnvInfo* JobConfig::_internal_mutable_runtime_env_info() {
  
  if (runtime_env_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::RuntimeEnvInfo>(GetArenaForAllocation());
    runtime_env_info_ = p;
  }
  return runtime_env_info_;
}
inline ::mcs::rpc::RuntimeEnvInfo* JobConfig::mutable_runtime_env_info() {
  ::mcs::rpc::RuntimeEnvInfo* _msg = _internal_mutable_runtime_env_info();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobConfig.runtime_env_info)
  return _msg;
}
inline void JobConfig::set_allocated_runtime_env_info(::mcs::rpc::RuntimeEnvInfo* runtime_env_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info_);
  }
  if (runtime_env_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info));
    if (message_arena != submessage_arena) {
      runtime_env_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime_env_info, submessage_arena);
    }
    
  } else {
    
  }
  runtime_env_info_ = runtime_env_info;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JobConfig.runtime_env_info)
}

// string mcs_namespace = 5;
inline void JobConfig::clear_mcs_namespace() {
  mcs_namespace_.ClearToEmpty();
}
inline const std::string& JobConfig::mcs_namespace() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobConfig.mcs_namespace)
  return _internal_mcs_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobConfig::set_mcs_namespace(ArgT0&& arg0, ArgT... args) {
 
 mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.JobConfig.mcs_namespace)
}
inline std::string* JobConfig::mutable_mcs_namespace() {
  std::string* _s = _internal_mutable_mcs_namespace();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobConfig.mcs_namespace)
  return _s;
}
inline const std::string& JobConfig::_internal_mcs_namespace() const {
  return mcs_namespace_.Get();
}
inline void JobConfig::_internal_set_mcs_namespace(const std::string& value) {
  
  mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JobConfig::_internal_mutable_mcs_namespace() {
  
  return mcs_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JobConfig::release_mcs_namespace() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JobConfig.mcs_namespace)
  return mcs_namespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JobConfig::set_allocated_mcs_namespace(std::string* mcs_namespace) {
  if (mcs_namespace != nullptr) {
    
  } else {
    
  }
  mcs_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcs_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JobConfig.mcs_namespace)
}

// map<string, string> metadata = 6;
inline int JobConfig::_internal_metadata_size() const {
  return metadata_.size();
}
inline int JobConfig::metadata_size() const {
  return _internal_metadata_size();
}
inline void JobConfig::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobConfig::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JobConfig::metadata() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.JobConfig.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobConfig::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JobConfig::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.JobConfig.metadata)
  return _internal_mutable_metadata();
}

// .mcs.rpc.JobConfig.ActorLifetime default_actor_lifetime = 7;
inline void JobConfig::clear_default_actor_lifetime() {
  default_actor_lifetime_ = 0;
}
inline ::mcs::rpc::JobConfig_ActorLifetime JobConfig::_internal_default_actor_lifetime() const {
  return static_cast< ::mcs::rpc::JobConfig_ActorLifetime >(default_actor_lifetime_);
}
inline ::mcs::rpc::JobConfig_ActorLifetime JobConfig::default_actor_lifetime() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobConfig.default_actor_lifetime)
  return _internal_default_actor_lifetime();
}
inline void JobConfig::_internal_set_default_actor_lifetime(::mcs::rpc::JobConfig_ActorLifetime value) {
  
  default_actor_lifetime_ = value;
}
inline void JobConfig::set_default_actor_lifetime(::mcs::rpc::JobConfig_ActorLifetime value) {
  _internal_set_default_actor_lifetime(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobConfig.default_actor_lifetime)
}

// -------------------------------------------------------------------

// JobTableData

// bytes job_id = 1;
inline void JobTableData::clear_job_id() {
  job_id_.ClearToEmpty();
}
inline const std::string& JobTableData::job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobTableData::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.job_id)
}
inline std::string* JobTableData::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobTableData.job_id)
  return _s;
}
inline const std::string& JobTableData::_internal_job_id() const {
  return job_id_.Get();
}
inline void JobTableData::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JobTableData::_internal_mutable_job_id() {
  
  return job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JobTableData::release_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JobTableData.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JobTableData::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JobTableData.job_id)
}

// bool is_dead = 2;
inline void JobTableData::clear_is_dead() {
  is_dead_ = false;
}
inline bool JobTableData::_internal_is_dead() const {
  return is_dead_;
}
inline bool JobTableData::is_dead() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.is_dead)
  return _internal_is_dead();
}
inline void JobTableData::_internal_set_is_dead(bool value) {
  
  is_dead_ = value;
}
inline void JobTableData::set_is_dead(bool value) {
  _internal_set_is_dead(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.is_dead)
}

// int64 timestamp = 3;
inline void JobTableData::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JobTableData::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JobTableData::timestamp() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.timestamp)
  return _internal_timestamp();
}
inline void JobTableData::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void JobTableData::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.timestamp)
}

// string driver_ip_address = 4;
inline void JobTableData::clear_driver_ip_address() {
  driver_ip_address_.ClearToEmpty();
}
inline const std::string& JobTableData::driver_ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.driver_ip_address)
  return _internal_driver_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobTableData::set_driver_ip_address(ArgT0&& arg0, ArgT... args) {
 
 driver_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.driver_ip_address)
}
inline std::string* JobTableData::mutable_driver_ip_address() {
  std::string* _s = _internal_mutable_driver_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobTableData.driver_ip_address)
  return _s;
}
inline const std::string& JobTableData::_internal_driver_ip_address() const {
  return driver_ip_address_.Get();
}
inline void JobTableData::_internal_set_driver_ip_address(const std::string& value) {
  
  driver_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JobTableData::_internal_mutable_driver_ip_address() {
  
  return driver_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JobTableData::release_driver_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JobTableData.driver_ip_address)
  return driver_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JobTableData::set_allocated_driver_ip_address(std::string* driver_ip_address) {
  if (driver_ip_address != nullptr) {
    
  } else {
    
  }
  driver_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), driver_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JobTableData.driver_ip_address)
}

// int64 driver_pid = 5;
inline void JobTableData::clear_driver_pid() {
  driver_pid_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JobTableData::_internal_driver_pid() const {
  return driver_pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JobTableData::driver_pid() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.driver_pid)
  return _internal_driver_pid();
}
inline void JobTableData::_internal_set_driver_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  driver_pid_ = value;
}
inline void JobTableData::set_driver_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_driver_pid(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.driver_pid)
}

// .mcs.rpc.JobConfig config = 6;
inline bool JobTableData::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool JobTableData::has_config() const {
  return _internal_has_config();
}
inline void JobTableData::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::mcs::rpc::JobConfig& JobTableData::_internal_config() const {
  const ::mcs::rpc::JobConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::JobConfig&>(
      ::mcs::rpc::_JobConfig_default_instance_);
}
inline const ::mcs::rpc::JobConfig& JobTableData::config() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.config)
  return _internal_config();
}
inline void JobTableData::unsafe_arena_set_allocated_config(
    ::mcs::rpc::JobConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.JobTableData.config)
}
inline ::mcs::rpc::JobConfig* JobTableData::release_config() {
  
  ::mcs::rpc::JobConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::JobConfig* JobTableData::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JobTableData.config)
  
  ::mcs::rpc::JobConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::mcs::rpc::JobConfig* JobTableData::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::JobConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::mcs::rpc::JobConfig* JobTableData::mutable_config() {
  ::mcs::rpc::JobConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobTableData.config)
  return _msg;
}
inline void JobTableData::set_allocated_config(::mcs::rpc::JobConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::JobConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JobTableData.config)
}

// uint64 start_time = 7;
inline void JobTableData::clear_start_time() {
  start_time_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 JobTableData::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 JobTableData::start_time() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.start_time)
  return _internal_start_time();
}
inline void JobTableData::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_time_ = value;
}
inline void JobTableData::set_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.start_time)
}

// uint64 end_time = 8;
inline void JobTableData::clear_end_time() {
  end_time_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 JobTableData::_internal_end_time() const {
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 JobTableData::end_time() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.end_time)
  return _internal_end_time();
}
inline void JobTableData::_internal_set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_time_ = value;
}
inline void JobTableData::set_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.end_time)
}

// string entrypoint = 9;
inline void JobTableData::clear_entrypoint() {
  entrypoint_.ClearToEmpty();
}
inline const std::string& JobTableData::entrypoint() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JobTableData.entrypoint)
  return _internal_entrypoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobTableData::set_entrypoint(ArgT0&& arg0, ArgT... args) {
 
 entrypoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.JobTableData.entrypoint)
}
inline std::string* JobTableData::mutable_entrypoint() {
  std::string* _s = _internal_mutable_entrypoint();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JobTableData.entrypoint)
  return _s;
}
inline const std::string& JobTableData::_internal_entrypoint() const {
  return entrypoint_.Get();
}
inline void JobTableData::_internal_set_entrypoint(const std::string& value) {
  
  entrypoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JobTableData::_internal_mutable_entrypoint() {
  
  return entrypoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JobTableData::release_entrypoint() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JobTableData.entrypoint)
  return entrypoint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JobTableData::set_allocated_entrypoint(std::string* entrypoint) {
  if (entrypoint != nullptr) {
    
  } else {
    
  }
  entrypoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entrypoint,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JobTableData.entrypoint)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorkerTableData

// bool is_alive = 1;
inline void WorkerTableData::clear_is_alive() {
  is_alive_ = false;
}
inline bool WorkerTableData::_internal_is_alive() const {
  return is_alive_;
}
inline bool WorkerTableData::is_alive() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.is_alive)
  return _internal_is_alive();
}
inline void WorkerTableData::_internal_set_is_alive(bool value) {
  
  is_alive_ = value;
}
inline void WorkerTableData::set_is_alive(bool value) {
  _internal_set_is_alive(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerTableData.is_alive)
}

// .mcs.rpc.Address worker_address = 2;
inline bool WorkerTableData::_internal_has_worker_address() const {
  return this != internal_default_instance() && worker_address_ != nullptr;
}
inline bool WorkerTableData::has_worker_address() const {
  return _internal_has_worker_address();
}
inline const ::mcs::rpc::Address& WorkerTableData::_internal_worker_address() const {
  const ::mcs::rpc::Address* p = worker_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::Address&>(
      ::mcs::rpc::_Address_default_instance_);
}
inline const ::mcs::rpc::Address& WorkerTableData::worker_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.worker_address)
  return _internal_worker_address();
}
inline void WorkerTableData::unsafe_arena_set_allocated_worker_address(
    ::mcs::rpc::Address* worker_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(worker_address_);
  }
  worker_address_ = worker_address;
  if (worker_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.WorkerTableData.worker_address)
}
inline ::mcs::rpc::Address* WorkerTableData::release_worker_address() {
  
  ::mcs::rpc::Address* temp = worker_address_;
  worker_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::Address* WorkerTableData::unsafe_arena_release_worker_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.WorkerTableData.worker_address)
  
  ::mcs::rpc::Address* temp = worker_address_;
  worker_address_ = nullptr;
  return temp;
}
inline ::mcs::rpc::Address* WorkerTableData::_internal_mutable_worker_address() {
  
  if (worker_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::Address>(GetArenaForAllocation());
    worker_address_ = p;
  }
  return worker_address_;
}
inline ::mcs::rpc::Address* WorkerTableData::mutable_worker_address() {
  ::mcs::rpc::Address* _msg = _internal_mutable_worker_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.WorkerTableData.worker_address)
  return _msg;
}
inline void WorkerTableData::set_allocated_worker_address(::mcs::rpc::Address* worker_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(worker_address_);
  }
  if (worker_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(worker_address));
    if (message_arena != submessage_arena) {
      worker_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, worker_address, submessage_arena);
    }
    
  } else {
    
  }
  worker_address_ = worker_address;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.WorkerTableData.worker_address)
}

// int64 timestamp = 3;
inline void WorkerTableData::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WorkerTableData::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WorkerTableData::timestamp() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.timestamp)
  return _internal_timestamp();
}
inline void WorkerTableData::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void WorkerTableData::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerTableData.timestamp)
}

// .mcs.rpc.WorkerType worker_type = 5;
inline void WorkerTableData::clear_worker_type() {
  worker_type_ = 0;
}
inline ::mcs::rpc::WorkerType WorkerTableData::_internal_worker_type() const {
  return static_cast< ::mcs::rpc::WorkerType >(worker_type_);
}
inline ::mcs::rpc::WorkerType WorkerTableData::worker_type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.worker_type)
  return _internal_worker_type();
}
inline void WorkerTableData::_internal_set_worker_type(::mcs::rpc::WorkerType value) {
  
  worker_type_ = value;
}
inline void WorkerTableData::set_worker_type(::mcs::rpc::WorkerType value) {
  _internal_set_worker_type(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerTableData.worker_type)
}

// map<string, bytes> worker_info = 6;
inline int WorkerTableData::_internal_worker_info_size() const {
  return worker_info_.size();
}
inline int WorkerTableData::worker_info_size() const {
  return _internal_worker_info_size();
}
inline void WorkerTableData::clear_worker_info() {
  worker_info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WorkerTableData::_internal_worker_info() const {
  return worker_info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WorkerTableData::worker_info() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.WorkerTableData.worker_info)
  return _internal_worker_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WorkerTableData::_internal_mutable_worker_info() {
  return worker_info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WorkerTableData::mutable_worker_info() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.WorkerTableData.worker_info)
  return _internal_mutable_worker_info();
}

// .mcs.rpc.McsException creation_task_exception = 18;
inline bool WorkerTableData::_internal_has_creation_task_exception() const {
  return this != internal_default_instance() && creation_task_exception_ != nullptr;
}
inline bool WorkerTableData::has_creation_task_exception() const {
  return _internal_has_creation_task_exception();
}
inline const ::mcs::rpc::McsException& WorkerTableData::_internal_creation_task_exception() const {
  const ::mcs::rpc::McsException* p = creation_task_exception_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::McsException&>(
      ::mcs::rpc::_McsException_default_instance_);
}
inline const ::mcs::rpc::McsException& WorkerTableData::creation_task_exception() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.creation_task_exception)
  return _internal_creation_task_exception();
}
inline void WorkerTableData::unsafe_arena_set_allocated_creation_task_exception(
    ::mcs::rpc::McsException* creation_task_exception) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_task_exception_);
  }
  creation_task_exception_ = creation_task_exception;
  if (creation_task_exception) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.WorkerTableData.creation_task_exception)
}
inline ::mcs::rpc::McsException* WorkerTableData::release_creation_task_exception() {
  
  ::mcs::rpc::McsException* temp = creation_task_exception_;
  creation_task_exception_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::McsException* WorkerTableData::unsafe_arena_release_creation_task_exception() {
  // @@protoc_insertion_point(field_release:mcs.rpc.WorkerTableData.creation_task_exception)
  
  ::mcs::rpc::McsException* temp = creation_task_exception_;
  creation_task_exception_ = nullptr;
  return temp;
}
inline ::mcs::rpc::McsException* WorkerTableData::_internal_mutable_creation_task_exception() {
  
  if (creation_task_exception_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::McsException>(GetArenaForAllocation());
    creation_task_exception_ = p;
  }
  return creation_task_exception_;
}
inline ::mcs::rpc::McsException* WorkerTableData::mutable_creation_task_exception() {
  ::mcs::rpc::McsException* _msg = _internal_mutable_creation_task_exception();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.WorkerTableData.creation_task_exception)
  return _msg;
}
inline void WorkerTableData::set_allocated_creation_task_exception(::mcs::rpc::McsException* creation_task_exception) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_task_exception_);
  }
  if (creation_task_exception) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_task_exception));
    if (message_arena != submessage_arena) {
      creation_task_exception = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creation_task_exception, submessage_arena);
    }
    
  } else {
    
  }
  creation_task_exception_ = creation_task_exception;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.WorkerTableData.creation_task_exception)
}

// optional .mcs.rpc.WorkerExitType exit_type = 19;
inline bool WorkerTableData::_internal_has_exit_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WorkerTableData::has_exit_type() const {
  return _internal_has_exit_type();
}
inline void WorkerTableData::clear_exit_type() {
  exit_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::mcs::rpc::WorkerExitType WorkerTableData::_internal_exit_type() const {
  return static_cast< ::mcs::rpc::WorkerExitType >(exit_type_);
}
inline ::mcs::rpc::WorkerExitType WorkerTableData::exit_type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.exit_type)
  return _internal_exit_type();
}
inline void WorkerTableData::_internal_set_exit_type(::mcs::rpc::WorkerExitType value) {
  _has_bits_[0] |= 0x00000002u;
  exit_type_ = value;
}
inline void WorkerTableData::set_exit_type(::mcs::rpc::WorkerExitType value) {
  _internal_set_exit_type(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerTableData.exit_type)
}

// optional string exit_detail = 20;
inline bool WorkerTableData::_internal_has_exit_detail() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WorkerTableData::has_exit_detail() const {
  return _internal_has_exit_detail();
}
inline void WorkerTableData::clear_exit_detail() {
  exit_detail_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WorkerTableData::exit_detail() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.exit_detail)
  return _internal_exit_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerTableData::set_exit_detail(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 exit_detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerTableData.exit_detail)
}
inline std::string* WorkerTableData::mutable_exit_detail() {
  std::string* _s = _internal_mutable_exit_detail();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.WorkerTableData.exit_detail)
  return _s;
}
inline const std::string& WorkerTableData::_internal_exit_detail() const {
  return exit_detail_.Get();
}
inline void WorkerTableData::_internal_set_exit_detail(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  exit_detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WorkerTableData::_internal_mutable_exit_detail() {
  _has_bits_[0] |= 0x00000001u;
  return exit_detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WorkerTableData::release_exit_detail() {
  // @@protoc_insertion_point(field_release:mcs.rpc.WorkerTableData.exit_detail)
  if (!_internal_has_exit_detail()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return exit_detail_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WorkerTableData::set_allocated_exit_detail(std::string* exit_detail) {
  if (exit_detail != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  exit_detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exit_detail,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.WorkerTableData.exit_detail)
}

// uint32 pid = 21;
inline void WorkerTableData::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WorkerTableData::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WorkerTableData::pid() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerTableData.pid)
  return _internal_pid();
}
inline void WorkerTableData::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void WorkerTableData::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerTableData.pid)
}

// -------------------------------------------------------------------

// WorkerDeltaData

// bytes mcslet_id = 1;
inline void WorkerDeltaData::clear_mcslet_id() {
  mcslet_id_.ClearToEmpty();
}
inline const std::string& WorkerDeltaData::mcslet_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerDeltaData.mcslet_id)
  return _internal_mcslet_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerDeltaData::set_mcslet_id(ArgT0&& arg0, ArgT... args) {
 
 mcslet_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerDeltaData.mcslet_id)
}
inline std::string* WorkerDeltaData::mutable_mcslet_id() {
  std::string* _s = _internal_mutable_mcslet_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.WorkerDeltaData.mcslet_id)
  return _s;
}
inline const std::string& WorkerDeltaData::_internal_mcslet_id() const {
  return mcslet_id_.Get();
}
inline void WorkerDeltaData::_internal_set_mcslet_id(const std::string& value) {
  
  mcslet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WorkerDeltaData::_internal_mutable_mcslet_id() {
  
  return mcslet_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WorkerDeltaData::release_mcslet_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.WorkerDeltaData.mcslet_id)
  return mcslet_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WorkerDeltaData::set_allocated_mcslet_id(std::string* mcslet_id) {
  if (mcslet_id != nullptr) {
    
  } else {
    
  }
  mcslet_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcslet_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.WorkerDeltaData.mcslet_id)
}

// bytes worker_id = 2;
inline void WorkerDeltaData::clear_worker_id() {
  worker_id_.ClearToEmpty();
}
inline const std::string& WorkerDeltaData::worker_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.WorkerDeltaData.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerDeltaData::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 worker_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.WorkerDeltaData.worker_id)
}
inline std::string* WorkerDeltaData::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.WorkerDeltaData.worker_id)
  return _s;
}
inline const std::string& WorkerDeltaData::_internal_worker_id() const {
  return worker_id_.Get();
}
inline void WorkerDeltaData::_internal_set_worker_id(const std::string& value) {
  
  worker_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WorkerDeltaData::_internal_mutable_worker_id() {
  
  return worker_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WorkerDeltaData::release_worker_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.WorkerDeltaData.worker_id)
  return worker_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WorkerDeltaData::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  worker_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worker_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.WorkerDeltaData.worker_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ResourceMap

// map<string, .mcs.rpc.ResourceTableData> items = 1;
inline int ResourceMap::_internal_items_size() const {
  return items_.size();
}
inline int ResourceMap::items_size() const {
  return _internal_items_size();
}
inline void ResourceMap::clear_items() {
  items_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >&
ResourceMap::_internal_items() const {
  return items_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >&
ResourceMap::items() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ResourceMap.items)
  return _internal_items();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >*
ResourceMap::_internal_mutable_items() {
  return items_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceTableData >*
ResourceMap::mutable_items() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ResourceMap.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// StoredConfig

// string config = 1;
inline void StoredConfig::clear_config() {
  config_.ClearToEmpty();
}
inline const std::string& StoredConfig::config() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.StoredConfig.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoredConfig::set_config(ArgT0&& arg0, ArgT... args) {
 
 config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.StoredConfig.config)
}
inline std::string* StoredConfig::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.StoredConfig.config)
  return _s;
}
inline const std::string& StoredConfig::_internal_config() const {
  return config_.Get();
}
inline void StoredConfig::_internal_set_config(const std::string& value) {
  
  config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoredConfig::_internal_mutable_config() {
  
  return config_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoredConfig::release_config() {
  // @@protoc_insertion_point(field_release:mcs.rpc.StoredConfig.config)
  return config_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoredConfig::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    
  } else {
    
  }
  config_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.StoredConfig.config)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodeResourceChange

// bytes node_id = 1;
inline void NodeResourceChange::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& NodeResourceChange::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NodeResourceChange.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeResourceChange::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.NodeResourceChange.node_id)
}
inline std::string* NodeResourceChange::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.NodeResourceChange.node_id)
  return _s;
}
inline const std::string& NodeResourceChange::_internal_node_id() const {
  return node_id_.Get();
}
inline void NodeResourceChange::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeResourceChange::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeResourceChange::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.NodeResourceChange.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeResourceChange::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.NodeResourceChange.node_id)
}

// map<string, double> updated_resources = 2;
inline int NodeResourceChange::_internal_updated_resources_size() const {
  return updated_resources_.size();
}
inline int NodeResourceChange::updated_resources_size() const {
  return _internal_updated_resources_size();
}
inline void NodeResourceChange::clear_updated_resources() {
  updated_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
NodeResourceChange::_internal_updated_resources() const {
  return updated_resources_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
NodeResourceChange::updated_resources() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.NodeResourceChange.updated_resources)
  return _internal_updated_resources();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
NodeResourceChange::_internal_mutable_updated_resources() {
  return updated_resources_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
NodeResourceChange::mutable_updated_resources() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.NodeResourceChange.updated_resources)
  return _internal_mutable_updated_resources();
}

// repeated string deleted_resources = 3;
inline int NodeResourceChange::_internal_deleted_resources_size() const {
  return deleted_resources_.size();
}
inline int NodeResourceChange::deleted_resources_size() const {
  return _internal_deleted_resources_size();
}
inline void NodeResourceChange::clear_deleted_resources() {
  deleted_resources_.Clear();
}
inline std::string* NodeResourceChange::add_deleted_resources() {
  std::string* _s = _internal_add_deleted_resources();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.NodeResourceChange.deleted_resources)
  return _s;
}
inline const std::string& NodeResourceChange::_internal_deleted_resources(int index) const {
  return deleted_resources_.Get(index);
}
inline const std::string& NodeResourceChange::deleted_resources(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NodeResourceChange.deleted_resources)
  return _internal_deleted_resources(index);
}
inline std::string* NodeResourceChange::mutable_deleted_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.NodeResourceChange.deleted_resources)
  return deleted_resources_.Mutable(index);
}
inline void NodeResourceChange::set_deleted_resources(int index, const std::string& value) {
  deleted_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline void NodeResourceChange::set_deleted_resources(int index, std::string&& value) {
  deleted_resources_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline void NodeResourceChange::set_deleted_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  deleted_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline void NodeResourceChange::set_deleted_resources(int index, const char* value, size_t size) {
  deleted_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline std::string* NodeResourceChange::_internal_add_deleted_resources() {
  return deleted_resources_.Add();
}
inline void NodeResourceChange::add_deleted_resources(const std::string& value) {
  deleted_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline void NodeResourceChange::add_deleted_resources(std::string&& value) {
  deleted_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline void NodeResourceChange::add_deleted_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  deleted_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline void NodeResourceChange::add_deleted_resources(const char* value, size_t size) {
  deleted_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.NodeResourceChange.deleted_resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NodeResourceChange::deleted_resources() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.NodeResourceChange.deleted_resources)
  return deleted_resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NodeResourceChange::mutable_deleted_resources() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.NodeResourceChange.deleted_resources)
  return &deleted_resources_;
}

// -------------------------------------------------------------------

// PubSubMessage

// bytes id = 1;
inline void PubSubMessage::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& PubSubMessage::id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PubSubMessage.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PubSubMessage::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PubSubMessage.id)
}
inline std::string* PubSubMessage::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PubSubMessage.id)
  return _s;
}
inline const std::string& PubSubMessage::_internal_id() const {
  return id_.Get();
}
inline void PubSubMessage::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PubSubMessage::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PubSubMessage::release_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PubSubMessage.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PubSubMessage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PubSubMessage.id)
}

// bytes data = 2;
inline void PubSubMessage::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PubSubMessage::data() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PubSubMessage.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PubSubMessage::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PubSubMessage.data)
}
inline std::string* PubSubMessage::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PubSubMessage.data)
  return _s;
}
inline const std::string& PubSubMessage::_internal_data() const {
  return data_.Get();
}
inline void PubSubMessage::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PubSubMessage::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PubSubMessage::release_data() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PubSubMessage.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PubSubMessage::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PubSubMessage.data)
}

// -------------------------------------------------------------------

// ResourceUpdate

// .mcs.rpc.NodeResourceChange change = 1;
inline bool ResourceUpdate::_internal_has_change() const {
  return resource_change_or_data_case() == kChange;
}
inline bool ResourceUpdate::has_change() const {
  return _internal_has_change();
}
inline void ResourceUpdate::set_has_change() {
  _oneof_case_[0] = kChange;
}
inline void ResourceUpdate::clear_change() {
  if (_internal_has_change()) {
    if (GetArenaForAllocation() == nullptr) {
      delete resource_change_or_data_.change_;
    }
    clear_has_resource_change_or_data();
  }
}
inline ::mcs::rpc::NodeResourceChange* ResourceUpdate::release_change() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourceUpdate.change)
  if (_internal_has_change()) {
    clear_has_resource_change_or_data();
      ::mcs::rpc::NodeResourceChange* temp = resource_change_or_data_.change_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    resource_change_or_data_.change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::NodeResourceChange& ResourceUpdate::_internal_change() const {
  return _internal_has_change()
      ? *resource_change_or_data_.change_
      : reinterpret_cast< ::mcs::rpc::NodeResourceChange&>(::mcs::rpc::_NodeResourceChange_default_instance_);
}
inline const ::mcs::rpc::NodeResourceChange& ResourceUpdate::change() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceUpdate.change)
  return _internal_change();
}
inline ::mcs::rpc::NodeResourceChange* ResourceUpdate::unsafe_arena_release_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.ResourceUpdate.change)
  if (_internal_has_change()) {
    clear_has_resource_change_or_data();
    ::mcs::rpc::NodeResourceChange* temp = resource_change_or_data_.change_;
    resource_change_or_data_.change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResourceUpdate::unsafe_arena_set_allocated_change(::mcs::rpc::NodeResourceChange* change) {
  clear_resource_change_or_data();
  if (change) {
    set_has_change();
    resource_change_or_data_.change_ = change;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ResourceUpdate.change)
}
inline ::mcs::rpc::NodeResourceChange* ResourceUpdate::_internal_mutable_change() {
  if (!_internal_has_change()) {
    clear_resource_change_or_data();
    set_has_change();
    resource_change_or_data_.change_ = CreateMaybeMessage< ::mcs::rpc::NodeResourceChange >(GetArenaForAllocation());
  }
  return resource_change_or_data_.change_;
}
inline ::mcs::rpc::NodeResourceChange* ResourceUpdate::mutable_change() {
  ::mcs::rpc::NodeResourceChange* _msg = _internal_mutable_change();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceUpdate.change)
  return _msg;
}

// .mcs.rpc.ResourcesData data = 2;
inline bool ResourceUpdate::_internal_has_data() const {
  return resource_change_or_data_case() == kData;
}
inline bool ResourceUpdate::has_data() const {
  return _internal_has_data();
}
inline void ResourceUpdate::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void ResourceUpdate::clear_data() {
  if (_internal_has_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete resource_change_or_data_.data_;
    }
    clear_has_resource_change_or_data();
  }
}
inline ::mcs::rpc::ResourcesData* ResourceUpdate::release_data() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourceUpdate.data)
  if (_internal_has_data()) {
    clear_has_resource_change_or_data();
      ::mcs::rpc::ResourcesData* temp = resource_change_or_data_.data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    resource_change_or_data_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::ResourcesData& ResourceUpdate::_internal_data() const {
  return _internal_has_data()
      ? *resource_change_or_data_.data_
      : reinterpret_cast< ::mcs::rpc::ResourcesData&>(::mcs::rpc::_ResourcesData_default_instance_);
}
inline const ::mcs::rpc::ResourcesData& ResourceUpdate::data() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceUpdate.data)
  return _internal_data();
}
inline ::mcs::rpc::ResourcesData* ResourceUpdate::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.ResourceUpdate.data)
  if (_internal_has_data()) {
    clear_has_resource_change_or_data();
    ::mcs::rpc::ResourcesData* temp = resource_change_or_data_.data_;
    resource_change_or_data_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResourceUpdate::unsafe_arena_set_allocated_data(::mcs::rpc::ResourcesData* data) {
  clear_resource_change_or_data();
  if (data) {
    set_has_data();
    resource_change_or_data_.data_ = data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ResourceUpdate.data)
}
inline ::mcs::rpc::ResourcesData* ResourceUpdate::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_resource_change_or_data();
    set_has_data();
    resource_change_or_data_.data_ = CreateMaybeMessage< ::mcs::rpc::ResourcesData >(GetArenaForAllocation());
  }
  return resource_change_or_data_.data_;
}
inline ::mcs::rpc::ResourcesData* ResourceUpdate::mutable_data() {
  ::mcs::rpc::ResourcesData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceUpdate.data)
  return _msg;
}

inline bool ResourceUpdate::has_resource_change_or_data() const {
  return resource_change_or_data_case() != RESOURCE_CHANGE_OR_DATA_NOT_SET;
}
inline void ResourceUpdate::clear_has_resource_change_or_data() {
  _oneof_case_[0] = RESOURCE_CHANGE_OR_DATA_NOT_SET;
}
inline ResourceUpdate::ResourceChangeOrDataCase ResourceUpdate::resource_change_or_data_case() const {
  return ResourceUpdate::ResourceChangeOrDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResourceUsageBroadcastData

// int64 seq_no = 1;
inline void ResourceUsageBroadcastData::clear_seq_no() {
  seq_no_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceUsageBroadcastData::_internal_seq_no() const {
  return seq_no_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceUsageBroadcastData::seq_no() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceUsageBroadcastData.seq_no)
  return _internal_seq_no();
}
inline void ResourceUsageBroadcastData::_internal_set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  seq_no_ = value;
}
inline void ResourceUsageBroadcastData::set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seq_no(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceUsageBroadcastData.seq_no)
}

// repeated .mcs.rpc.ResourceUpdate batch = 2;
inline int ResourceUsageBroadcastData::_internal_batch_size() const {
  return batch_.size();
}
inline int ResourceUsageBroadcastData::batch_size() const {
  return _internal_batch_size();
}
inline void ResourceUsageBroadcastData::clear_batch() {
  batch_.Clear();
}
inline ::mcs::rpc::ResourceUpdate* ResourceUsageBroadcastData::mutable_batch(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceUsageBroadcastData.batch)
  return batch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceUpdate >*
ResourceUsageBroadcastData::mutable_batch() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ResourceUsageBroadcastData.batch)
  return &batch_;
}
inline const ::mcs::rpc::ResourceUpdate& ResourceUsageBroadcastData::_internal_batch(int index) const {
  return batch_.Get(index);
}
inline const ::mcs::rpc::ResourceUpdate& ResourceUsageBroadcastData::batch(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceUsageBroadcastData.batch)
  return _internal_batch(index);
}
inline ::mcs::rpc::ResourceUpdate* ResourceUsageBroadcastData::_internal_add_batch() {
  return batch_.Add();
}
inline ::mcs::rpc::ResourceUpdate* ResourceUsageBroadcastData::add_batch() {
  ::mcs::rpc::ResourceUpdate* _add = _internal_add_batch();
  // @@protoc_insertion_point(field_add:mcs.rpc.ResourceUsageBroadcastData.batch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceUpdate >&
ResourceUsageBroadcastData::batch() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ResourceUsageBroadcastData.batch)
  return batch_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ResourceDemand

// map<string, double> shape = 1;
inline int ResourceDemand::_internal_shape_size() const {
  return shape_.size();
}
inline int ResourceDemand::shape_size() const {
  return _internal_shape_size();
}
inline void ResourceDemand::clear_shape() {
  shape_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourceDemand::_internal_shape() const {
  return shape_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourceDemand::shape() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ResourceDemand.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourceDemand::_internal_mutable_shape() {
  return shape_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourceDemand::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ResourceDemand.shape)
  return _internal_mutable_shape();
}

// uint64 num_ready_requests_queued = 2;
inline void ResourceDemand::clear_num_ready_requests_queued() {
  num_ready_requests_queued_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourceDemand::_internal_num_ready_requests_queued() const {
  return num_ready_requests_queued_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourceDemand::num_ready_requests_queued() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceDemand.num_ready_requests_queued)
  return _internal_num_ready_requests_queued();
}
inline void ResourceDemand::_internal_set_num_ready_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  num_ready_requests_queued_ = value;
}
inline void ResourceDemand::set_num_ready_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_num_ready_requests_queued(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceDemand.num_ready_requests_queued)
}

// uint64 num_infeasible_requests_queued = 3;
inline void ResourceDemand::clear_num_infeasible_requests_queued() {
  num_infeasible_requests_queued_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourceDemand::_internal_num_infeasible_requests_queued() const {
  return num_infeasible_requests_queued_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourceDemand::num_infeasible_requests_queued() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceDemand.num_infeasible_requests_queued)
  return _internal_num_infeasible_requests_queued();
}
inline void ResourceDemand::_internal_set_num_infeasible_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  num_infeasible_requests_queued_ = value;
}
inline void ResourceDemand::set_num_infeasible_requests_queued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_num_infeasible_requests_queued(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceDemand.num_infeasible_requests_queued)
}

// int64 backlog_size = 4;
inline void ResourceDemand::clear_backlog_size() {
  backlog_size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceDemand::_internal_backlog_size() const {
  return backlog_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceDemand::backlog_size() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceDemand.backlog_size)
  return _internal_backlog_size();
}
inline void ResourceDemand::_internal_set_backlog_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  backlog_size_ = value;
}
inline void ResourceDemand::set_backlog_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_backlog_size(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceDemand.backlog_size)
}

// -------------------------------------------------------------------

// ResourceLoad

// repeated .mcs.rpc.ResourceDemand resource_demands = 1;
inline int ResourceLoad::_internal_resource_demands_size() const {
  return resource_demands_.size();
}
inline int ResourceLoad::resource_demands_size() const {
  return _internal_resource_demands_size();
}
inline void ResourceLoad::clear_resource_demands() {
  resource_demands_.Clear();
}
inline ::mcs::rpc::ResourceDemand* ResourceLoad::mutable_resource_demands(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceLoad.resource_demands)
  return resource_demands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceDemand >*
ResourceLoad::mutable_resource_demands() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ResourceLoad.resource_demands)
  return &resource_demands_;
}
inline const ::mcs::rpc::ResourceDemand& ResourceLoad::_internal_resource_demands(int index) const {
  return resource_demands_.Get(index);
}
inline const ::mcs::rpc::ResourceDemand& ResourceLoad::resource_demands(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceLoad.resource_demands)
  return _internal_resource_demands(index);
}
inline ::mcs::rpc::ResourceDemand* ResourceLoad::_internal_add_resource_demands() {
  return resource_demands_.Add();
}
inline ::mcs::rpc::ResourceDemand* ResourceLoad::add_resource_demands() {
  ::mcs::rpc::ResourceDemand* _add = _internal_add_resource_demands();
  // @@protoc_insertion_point(field_add:mcs.rpc.ResourceLoad.resource_demands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceDemand >&
ResourceLoad::resource_demands() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ResourceLoad.resource_demands)
  return resource_demands_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ResourcesData

// bytes node_id = 1;
inline void ResourcesData::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& ResourcesData::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourcesData::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.node_id)
}
inline std::string* ResourcesData::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourcesData.node_id)
  return _s;
}
inline const std::string& ResourcesData::_internal_node_id() const {
  return node_id_.Get();
}
inline void ResourcesData::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResourcesData::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResourcesData::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourcesData.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResourcesData::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ResourcesData.node_id)
}

// map<string, double> resources_available = 2;
inline int ResourcesData::_internal_resources_available_size() const {
  return resources_available_.size();
}
inline int ResourcesData::resources_available_size() const {
  return _internal_resources_available_size();
}
inline void ResourcesData::clear_resources_available() {
  resources_available_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::_internal_resources_available() const {
  return resources_available_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::resources_available() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ResourcesData.resources_available)
  return _internal_resources_available();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::_internal_mutable_resources_available() {
  return resources_available_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::mutable_resources_available() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ResourcesData.resources_available)
  return _internal_mutable_resources_available();
}

// bool resources_available_changed = 3;
inline void ResourcesData::clear_resources_available_changed() {
  resources_available_changed_ = false;
}
inline bool ResourcesData::_internal_resources_available_changed() const {
  return resources_available_changed_;
}
inline bool ResourcesData::resources_available_changed() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.resources_available_changed)
  return _internal_resources_available_changed();
}
inline void ResourcesData::_internal_set_resources_available_changed(bool value) {
  
  resources_available_changed_ = value;
}
inline void ResourcesData::set_resources_available_changed(bool value) {
  _internal_set_resources_available_changed(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.resources_available_changed)
}

// map<string, double> resources_total = 4;
inline int ResourcesData::_internal_resources_total_size() const {
  return resources_total_.size();
}
inline int ResourcesData::resources_total_size() const {
  return _internal_resources_total_size();
}
inline void ResourcesData::clear_resources_total() {
  resources_total_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::_internal_resources_total() const {
  return resources_total_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::resources_total() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ResourcesData.resources_total)
  return _internal_resources_total();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::_internal_mutable_resources_total() {
  return resources_total_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::mutable_resources_total() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ResourcesData.resources_total)
  return _internal_mutable_resources_total();
}

// map<string, double> resource_load = 5;
inline int ResourcesData::_internal_resource_load_size() const {
  return resource_load_.size();
}
inline int ResourcesData::resource_load_size() const {
  return _internal_resource_load_size();
}
inline void ResourcesData::clear_resource_load() {
  resource_load_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::_internal_resource_load() const {
  return resource_load_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::resource_load() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ResourcesData.resource_load)
  return _internal_resource_load();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::_internal_mutable_resource_load() {
  return resource_load_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::mutable_resource_load() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ResourcesData.resource_load)
  return _internal_mutable_resource_load();
}

// bool resource_load_changed = 6;
inline void ResourcesData::clear_resource_load_changed() {
  resource_load_changed_ = false;
}
inline bool ResourcesData::_internal_resource_load_changed() const {
  return resource_load_changed_;
}
inline bool ResourcesData::resource_load_changed() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.resource_load_changed)
  return _internal_resource_load_changed();
}
inline void ResourcesData::_internal_set_resource_load_changed(bool value) {
  
  resource_load_changed_ = value;
}
inline void ResourcesData::set_resource_load_changed(bool value) {
  _internal_set_resource_load_changed(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.resource_load_changed)
}

// .mcs.rpc.ResourceLoad resource_load_by_shape = 7;
inline bool ResourcesData::_internal_has_resource_load_by_shape() const {
  return this != internal_default_instance() && resource_load_by_shape_ != nullptr;
}
inline bool ResourcesData::has_resource_load_by_shape() const {
  return _internal_has_resource_load_by_shape();
}
inline void ResourcesData::clear_resource_load_by_shape() {
  if (GetArenaForAllocation() == nullptr && resource_load_by_shape_ != nullptr) {
    delete resource_load_by_shape_;
  }
  resource_load_by_shape_ = nullptr;
}
inline const ::mcs::rpc::ResourceLoad& ResourcesData::_internal_resource_load_by_shape() const {
  const ::mcs::rpc::ResourceLoad* p = resource_load_by_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ResourceLoad&>(
      ::mcs::rpc::_ResourceLoad_default_instance_);
}
inline const ::mcs::rpc::ResourceLoad& ResourcesData::resource_load_by_shape() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.resource_load_by_shape)
  return _internal_resource_load_by_shape();
}
inline void ResourcesData::unsafe_arena_set_allocated_resource_load_by_shape(
    ::mcs::rpc::ResourceLoad* resource_load_by_shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource_load_by_shape_);
  }
  resource_load_by_shape_ = resource_load_by_shape;
  if (resource_load_by_shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ResourcesData.resource_load_by_shape)
}
inline ::mcs::rpc::ResourceLoad* ResourcesData::release_resource_load_by_shape() {
  
  ::mcs::rpc::ResourceLoad* temp = resource_load_by_shape_;
  resource_load_by_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ResourceLoad* ResourcesData::unsafe_arena_release_resource_load_by_shape() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourcesData.resource_load_by_shape)
  
  ::mcs::rpc::ResourceLoad* temp = resource_load_by_shape_;
  resource_load_by_shape_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ResourceLoad* ResourcesData::_internal_mutable_resource_load_by_shape() {
  
  if (resource_load_by_shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ResourceLoad>(GetArenaForAllocation());
    resource_load_by_shape_ = p;
  }
  return resource_load_by_shape_;
}
inline ::mcs::rpc::ResourceLoad* ResourcesData::mutable_resource_load_by_shape() {
  ::mcs::rpc::ResourceLoad* _msg = _internal_mutable_resource_load_by_shape();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourcesData.resource_load_by_shape)
  return _msg;
}
inline void ResourcesData::set_allocated_resource_load_by_shape(::mcs::rpc::ResourceLoad* resource_load_by_shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resource_load_by_shape_;
  }
  if (resource_load_by_shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::ResourceLoad>::GetOwningArena(resource_load_by_shape);
    if (message_arena != submessage_arena) {
      resource_load_by_shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource_load_by_shape, submessage_arena);
    }
    
  } else {
    
  }
  resource_load_by_shape_ = resource_load_by_shape;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ResourcesData.resource_load_by_shape)
}

// bool should_global_gc = 8;
inline void ResourcesData::clear_should_global_gc() {
  should_global_gc_ = false;
}
inline bool ResourcesData::_internal_should_global_gc() const {
  return should_global_gc_;
}
inline bool ResourcesData::should_global_gc() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.should_global_gc)
  return _internal_should_global_gc();
}
inline void ResourcesData::_internal_set_should_global_gc(bool value) {
  
  should_global_gc_ = value;
}
inline void ResourcesData::set_should_global_gc(bool value) {
  _internal_set_should_global_gc(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.should_global_gc)
}

// string node_manager_address = 9;
inline void ResourcesData::clear_node_manager_address() {
  node_manager_address_.ClearToEmpty();
}
inline const std::string& ResourcesData::node_manager_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.node_manager_address)
  return _internal_node_manager_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourcesData::set_node_manager_address(ArgT0&& arg0, ArgT... args) {
 
 node_manager_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.node_manager_address)
}
inline std::string* ResourcesData::mutable_node_manager_address() {
  std::string* _s = _internal_mutable_node_manager_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourcesData.node_manager_address)
  return _s;
}
inline const std::string& ResourcesData::_internal_node_manager_address() const {
  return node_manager_address_.Get();
}
inline void ResourcesData::_internal_set_node_manager_address(const std::string& value) {
  
  node_manager_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResourcesData::_internal_mutable_node_manager_address() {
  
  return node_manager_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResourcesData::release_node_manager_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourcesData.node_manager_address)
  return node_manager_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResourcesData::set_allocated_node_manager_address(std::string* node_manager_address) {
  if (node_manager_address != nullptr) {
    
  } else {
    
  }
  node_manager_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_manager_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ResourcesData.node_manager_address)
}

// bool object_pulls_queued = 10;
inline void ResourcesData::clear_object_pulls_queued() {
  object_pulls_queued_ = false;
}
inline bool ResourcesData::_internal_object_pulls_queued() const {
  return object_pulls_queued_;
}
inline bool ResourcesData::object_pulls_queued() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.object_pulls_queued)
  return _internal_object_pulls_queued();
}
inline void ResourcesData::_internal_set_object_pulls_queued(bool value) {
  
  object_pulls_queued_ = value;
}
inline void ResourcesData::set_object_pulls_queued(bool value) {
  _internal_set_object_pulls_queued(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.object_pulls_queued)
}

// map<string, double> resources_normal_task = 11;
inline int ResourcesData::_internal_resources_normal_task_size() const {
  return resources_normal_task_.size();
}
inline int ResourcesData::resources_normal_task_size() const {
  return _internal_resources_normal_task_size();
}
inline void ResourcesData::clear_resources_normal_task() {
  resources_normal_task_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::_internal_resources_normal_task() const {
  return resources_normal_task_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ResourcesData::resources_normal_task() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.ResourcesData.resources_normal_task)
  return _internal_resources_normal_task();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::_internal_mutable_resources_normal_task() {
  return resources_normal_task_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ResourcesData::mutable_resources_normal_task() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.ResourcesData.resources_normal_task)
  return _internal_mutable_resources_normal_task();
}

// bool resources_normal_task_changed = 12;
inline void ResourcesData::clear_resources_normal_task_changed() {
  resources_normal_task_changed_ = false;
}
inline bool ResourcesData::_internal_resources_normal_task_changed() const {
  return resources_normal_task_changed_;
}
inline bool ResourcesData::resources_normal_task_changed() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.resources_normal_task_changed)
  return _internal_resources_normal_task_changed();
}
inline void ResourcesData::_internal_set_resources_normal_task_changed(bool value) {
  
  resources_normal_task_changed_ = value;
}
inline void ResourcesData::set_resources_normal_task_changed(bool value) {
  _internal_set_resources_normal_task_changed(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.resources_normal_task_changed)
}

// int64 resources_normal_task_timestamp = 13;
inline void ResourcesData::clear_resources_normal_task_timestamp() {
  resources_normal_task_timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourcesData::_internal_resources_normal_task_timestamp() const {
  return resources_normal_task_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourcesData::resources_normal_task_timestamp() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.resources_normal_task_timestamp)
  return _internal_resources_normal_task_timestamp();
}
inline void ResourcesData::_internal_set_resources_normal_task_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  resources_normal_task_timestamp_ = value;
}
inline void ResourcesData::set_resources_normal_task_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_resources_normal_task_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.resources_normal_task_timestamp)
}

// bool cluster_full_of_actors_detected = 14;
inline void ResourcesData::clear_cluster_full_of_actors_detected() {
  cluster_full_of_actors_detected_ = false;
}
inline bool ResourcesData::_internal_cluster_full_of_actors_detected() const {
  return cluster_full_of_actors_detected_;
}
inline bool ResourcesData::cluster_full_of_actors_detected() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourcesData.cluster_full_of_actors_detected)
  return _internal_cluster_full_of_actors_detected();
}
inline void ResourcesData::_internal_set_cluster_full_of_actors_detected(bool value) {
  
  cluster_full_of_actors_detected_ = value;
}
inline void ResourcesData::set_cluster_full_of_actors_detected(bool value) {
  _internal_set_cluster_full_of_actors_detected(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourcesData.cluster_full_of_actors_detected)
}

// -------------------------------------------------------------------

// ResourceUsageBatchData

// repeated .mcs.rpc.ResourcesData batch = 1;
inline int ResourceUsageBatchData::_internal_batch_size() const {
  return batch_.size();
}
inline int ResourceUsageBatchData::batch_size() const {
  return _internal_batch_size();
}
inline void ResourceUsageBatchData::clear_batch() {
  batch_.Clear();
}
inline ::mcs::rpc::ResourcesData* ResourceUsageBatchData::mutable_batch(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceUsageBatchData.batch)
  return batch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourcesData >*
ResourceUsageBatchData::mutable_batch() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ResourceUsageBatchData.batch)
  return &batch_;
}
inline const ::mcs::rpc::ResourcesData& ResourceUsageBatchData::_internal_batch(int index) const {
  return batch_.Get(index);
}
inline const ::mcs::rpc::ResourcesData& ResourceUsageBatchData::batch(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceUsageBatchData.batch)
  return _internal_batch(index);
}
inline ::mcs::rpc::ResourcesData* ResourceUsageBatchData::_internal_add_batch() {
  return batch_.Add();
}
inline ::mcs::rpc::ResourcesData* ResourceUsageBatchData::add_batch() {
  ::mcs::rpc::ResourcesData* _add = _internal_add_batch();
  // @@protoc_insertion_point(field_add:mcs.rpc.ResourceUsageBatchData.batch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourcesData >&
ResourceUsageBatchData::batch() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ResourceUsageBatchData.batch)
  return batch_;
}

// .mcs.rpc.ResourceLoad resource_load_by_shape = 2;
inline bool ResourceUsageBatchData::_internal_has_resource_load_by_shape() const {
  return this != internal_default_instance() && resource_load_by_shape_ != nullptr;
}
inline bool ResourceUsageBatchData::has_resource_load_by_shape() const {
  return _internal_has_resource_load_by_shape();
}
inline void ResourceUsageBatchData::clear_resource_load_by_shape() {
  if (GetArenaForAllocation() == nullptr && resource_load_by_shape_ != nullptr) {
    delete resource_load_by_shape_;
  }
  resource_load_by_shape_ = nullptr;
}
inline const ::mcs::rpc::ResourceLoad& ResourceUsageBatchData::_internal_resource_load_by_shape() const {
  const ::mcs::rpc::ResourceLoad* p = resource_load_by_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ResourceLoad&>(
      ::mcs::rpc::_ResourceLoad_default_instance_);
}
inline const ::mcs::rpc::ResourceLoad& ResourceUsageBatchData::resource_load_by_shape() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceUsageBatchData.resource_load_by_shape)
  return _internal_resource_load_by_shape();
}
inline void ResourceUsageBatchData::unsafe_arena_set_allocated_resource_load_by_shape(
    ::mcs::rpc::ResourceLoad* resource_load_by_shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource_load_by_shape_);
  }
  resource_load_by_shape_ = resource_load_by_shape;
  if (resource_load_by_shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ResourceUsageBatchData.resource_load_by_shape)
}
inline ::mcs::rpc::ResourceLoad* ResourceUsageBatchData::release_resource_load_by_shape() {
  
  ::mcs::rpc::ResourceLoad* temp = resource_load_by_shape_;
  resource_load_by_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ResourceLoad* ResourceUsageBatchData::unsafe_arena_release_resource_load_by_shape() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourceUsageBatchData.resource_load_by_shape)
  
  ::mcs::rpc::ResourceLoad* temp = resource_load_by_shape_;
  resource_load_by_shape_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ResourceLoad* ResourceUsageBatchData::_internal_mutable_resource_load_by_shape() {
  
  if (resource_load_by_shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ResourceLoad>(GetArenaForAllocation());
    resource_load_by_shape_ = p;
  }
  return resource_load_by_shape_;
}
inline ::mcs::rpc::ResourceLoad* ResourceUsageBatchData::mutable_resource_load_by_shape() {
  ::mcs::rpc::ResourceLoad* _msg = _internal_mutable_resource_load_by_shape();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceUsageBatchData.resource_load_by_shape)
  return _msg;
}
inline void ResourceUsageBatchData::set_allocated_resource_load_by_shape(::mcs::rpc::ResourceLoad* resource_load_by_shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resource_load_by_shape_;
  }
  if (resource_load_by_shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::ResourceLoad>::GetOwningArena(resource_load_by_shape);
    if (message_arena != submessage_arena) {
      resource_load_by_shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource_load_by_shape, submessage_arena);
    }
    
  } else {
    
  }
  resource_load_by_shape_ = resource_load_by_shape;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ResourceUsageBatchData.resource_load_by_shape)
}

// .mcs.rpc.PlacementGroupLoad placement_group_load = 3;
inline bool ResourceUsageBatchData::_internal_has_placement_group_load() const {
  return this != internal_default_instance() && placement_group_load_ != nullptr;
}
inline bool ResourceUsageBatchData::has_placement_group_load() const {
  return _internal_has_placement_group_load();
}
inline void ResourceUsageBatchData::clear_placement_group_load() {
  if (GetArenaForAllocation() == nullptr && placement_group_load_ != nullptr) {
    delete placement_group_load_;
  }
  placement_group_load_ = nullptr;
}
inline const ::mcs::rpc::PlacementGroupLoad& ResourceUsageBatchData::_internal_placement_group_load() const {
  const ::mcs::rpc::PlacementGroupLoad* p = placement_group_load_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::PlacementGroupLoad&>(
      ::mcs::rpc::_PlacementGroupLoad_default_instance_);
}
inline const ::mcs::rpc::PlacementGroupLoad& ResourceUsageBatchData::placement_group_load() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceUsageBatchData.placement_group_load)
  return _internal_placement_group_load();
}
inline void ResourceUsageBatchData::unsafe_arena_set_allocated_placement_group_load(
    ::mcs::rpc::PlacementGroupLoad* placement_group_load) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placement_group_load_);
  }
  placement_group_load_ = placement_group_load;
  if (placement_group_load) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ResourceUsageBatchData.placement_group_load)
}
inline ::mcs::rpc::PlacementGroupLoad* ResourceUsageBatchData::release_placement_group_load() {
  
  ::mcs::rpc::PlacementGroupLoad* temp = placement_group_load_;
  placement_group_load_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::PlacementGroupLoad* ResourceUsageBatchData::unsafe_arena_release_placement_group_load() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourceUsageBatchData.placement_group_load)
  
  ::mcs::rpc::PlacementGroupLoad* temp = placement_group_load_;
  placement_group_load_ = nullptr;
  return temp;
}
inline ::mcs::rpc::PlacementGroupLoad* ResourceUsageBatchData::_internal_mutable_placement_group_load() {
  
  if (placement_group_load_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::PlacementGroupLoad>(GetArenaForAllocation());
    placement_group_load_ = p;
  }
  return placement_group_load_;
}
inline ::mcs::rpc::PlacementGroupLoad* ResourceUsageBatchData::mutable_placement_group_load() {
  ::mcs::rpc::PlacementGroupLoad* _msg = _internal_mutable_placement_group_load();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceUsageBatchData.placement_group_load)
  return _msg;
}
inline void ResourceUsageBatchData::set_allocated_placement_group_load(::mcs::rpc::PlacementGroupLoad* placement_group_load) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete placement_group_load_;
  }
  if (placement_group_load) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::PlacementGroupLoad>::GetOwningArena(placement_group_load);
    if (message_arena != submessage_arena) {
      placement_group_load = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placement_group_load, submessage_arena);
    }
    
  } else {
    
  }
  placement_group_load_ = placement_group_load;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ResourceUsageBatchData.placement_group_load)
}

// -------------------------------------------------------------------

// PlacementGroupLoad

// repeated .mcs.rpc.PlacementGroupTableData placement_group_data = 1;
inline int PlacementGroupLoad::_internal_placement_group_data_size() const {
  return placement_group_data_.size();
}
inline int PlacementGroupLoad::placement_group_data_size() const {
  return _internal_placement_group_data_size();
}
inline void PlacementGroupLoad::clear_placement_group_data() {
  placement_group_data_.Clear();
}
inline ::mcs::rpc::PlacementGroupTableData* PlacementGroupLoad::mutable_placement_group_data(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupLoad.placement_group_data)
  return placement_group_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::PlacementGroupTableData >*
PlacementGroupLoad::mutable_placement_group_data() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.PlacementGroupLoad.placement_group_data)
  return &placement_group_data_;
}
inline const ::mcs::rpc::PlacementGroupTableData& PlacementGroupLoad::_internal_placement_group_data(int index) const {
  return placement_group_data_.Get(index);
}
inline const ::mcs::rpc::PlacementGroupTableData& PlacementGroupLoad::placement_group_data(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupLoad.placement_group_data)
  return _internal_placement_group_data(index);
}
inline ::mcs::rpc::PlacementGroupTableData* PlacementGroupLoad::_internal_add_placement_group_data() {
  return placement_group_data_.Add();
}
inline ::mcs::rpc::PlacementGroupTableData* PlacementGroupLoad::add_placement_group_data() {
  ::mcs::rpc::PlacementGroupTableData* _add = _internal_add_placement_group_data();
  // @@protoc_insertion_point(field_add:mcs.rpc.PlacementGroupLoad.placement_group_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::PlacementGroupTableData >&
PlacementGroupLoad::placement_group_data() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.PlacementGroupLoad.placement_group_data)
  return placement_group_data_;
}

// -------------------------------------------------------------------

// PlacementGroupStats

// int64 creation_request_received_ns = 2;
inline void PlacementGroupStats::clear_creation_request_received_ns() {
  creation_request_received_ns_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::_internal_creation_request_received_ns() const {
  return creation_request_received_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::creation_request_received_ns() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupStats.creation_request_received_ns)
  return _internal_creation_request_received_ns();
}
inline void PlacementGroupStats::_internal_set_creation_request_received_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  creation_request_received_ns_ = value;
}
inline void PlacementGroupStats::set_creation_request_received_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_creation_request_received_ns(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupStats.creation_request_received_ns)
}

// int64 scheduling_started_time_ns = 3;
inline void PlacementGroupStats::clear_scheduling_started_time_ns() {
  scheduling_started_time_ns_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::_internal_scheduling_started_time_ns() const {
  return scheduling_started_time_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::scheduling_started_time_ns() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupStats.scheduling_started_time_ns)
  return _internal_scheduling_started_time_ns();
}
inline void PlacementGroupStats::_internal_set_scheduling_started_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  scheduling_started_time_ns_ = value;
}
inline void PlacementGroupStats::set_scheduling_started_time_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_scheduling_started_time_ns(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupStats.scheduling_started_time_ns)
}

// int64 scheduling_latency_us = 4;
inline void PlacementGroupStats::clear_scheduling_latency_us() {
  scheduling_latency_us_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::_internal_scheduling_latency_us() const {
  return scheduling_latency_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::scheduling_latency_us() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupStats.scheduling_latency_us)
  return _internal_scheduling_latency_us();
}
inline void PlacementGroupStats::_internal_set_scheduling_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  scheduling_latency_us_ = value;
}
inline void PlacementGroupStats::set_scheduling_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_scheduling_latency_us(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupStats.scheduling_latency_us)
}

// int64 end_to_end_creation_latency_us = 5;
inline void PlacementGroupStats::clear_end_to_end_creation_latency_us() {
  end_to_end_creation_latency_us_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::_internal_end_to_end_creation_latency_us() const {
  return end_to_end_creation_latency_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupStats::end_to_end_creation_latency_us() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupStats.end_to_end_creation_latency_us)
  return _internal_end_to_end_creation_latency_us();
}
inline void PlacementGroupStats::_internal_set_end_to_end_creation_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_to_end_creation_latency_us_ = value;
}
inline void PlacementGroupStats::set_end_to_end_creation_latency_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_to_end_creation_latency_us(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupStats.end_to_end_creation_latency_us)
}

// uint32 scheduling_attempt = 6;
inline void PlacementGroupStats::clear_scheduling_attempt() {
  scheduling_attempt_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlacementGroupStats::_internal_scheduling_attempt() const {
  return scheduling_attempt_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlacementGroupStats::scheduling_attempt() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupStats.scheduling_attempt)
  return _internal_scheduling_attempt();
}
inline void PlacementGroupStats::_internal_set_scheduling_attempt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  scheduling_attempt_ = value;
}
inline void PlacementGroupStats::set_scheduling_attempt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_scheduling_attempt(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupStats.scheduling_attempt)
}

// double highest_retry_delay_ms = 7;
inline void PlacementGroupStats::clear_highest_retry_delay_ms() {
  highest_retry_delay_ms_ = 0;
}
inline double PlacementGroupStats::_internal_highest_retry_delay_ms() const {
  return highest_retry_delay_ms_;
}
inline double PlacementGroupStats::highest_retry_delay_ms() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupStats.highest_retry_delay_ms)
  return _internal_highest_retry_delay_ms();
}
inline void PlacementGroupStats::_internal_set_highest_retry_delay_ms(double value) {
  
  highest_retry_delay_ms_ = value;
}
inline void PlacementGroupStats::set_highest_retry_delay_ms(double value) {
  _internal_set_highest_retry_delay_ms(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupStats.highest_retry_delay_ms)
}

// .mcs.rpc.PlacementGroupStats.SchedulingState scheduling_state = 8;
inline void PlacementGroupStats::clear_scheduling_state() {
  scheduling_state_ = 0;
}
inline ::mcs::rpc::PlacementGroupStats_SchedulingState PlacementGroupStats::_internal_scheduling_state() const {
  return static_cast< ::mcs::rpc::PlacementGroupStats_SchedulingState >(scheduling_state_);
}
inline ::mcs::rpc::PlacementGroupStats_SchedulingState PlacementGroupStats::scheduling_state() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupStats.scheduling_state)
  return _internal_scheduling_state();
}
inline void PlacementGroupStats::_internal_set_scheduling_state(::mcs::rpc::PlacementGroupStats_SchedulingState value) {
  
  scheduling_state_ = value;
}
inline void PlacementGroupStats::set_scheduling_state(::mcs::rpc::PlacementGroupStats_SchedulingState value) {
  _internal_set_scheduling_state(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupStats.scheduling_state)
}

// -------------------------------------------------------------------

// PlacementGroupTableData

// bytes placement_group_id = 1;
inline void PlacementGroupTableData::clear_placement_group_id() {
  placement_group_id_.ClearToEmpty();
}
inline const std::string& PlacementGroupTableData::placement_group_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.placement_group_id)
  return _internal_placement_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupTableData::set_placement_group_id(ArgT0&& arg0, ArgT... args) {
 
 placement_group_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.placement_group_id)
}
inline std::string* PlacementGroupTableData::mutable_placement_group_id() {
  std::string* _s = _internal_mutable_placement_group_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupTableData.placement_group_id)
  return _s;
}
inline const std::string& PlacementGroupTableData::_internal_placement_group_id() const {
  return placement_group_id_.Get();
}
inline void PlacementGroupTableData::_internal_set_placement_group_id(const std::string& value) {
  
  placement_group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::_internal_mutable_placement_group_id() {
  
  return placement_group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::release_placement_group_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupTableData.placement_group_id)
  return placement_group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupTableData::set_allocated_placement_group_id(std::string* placement_group_id) {
  if (placement_group_id != nullptr) {
    
  } else {
    
  }
  placement_group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), placement_group_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupTableData.placement_group_id)
}

// string name = 2;
inline void PlacementGroupTableData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PlacementGroupTableData::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupTableData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.name)
}
inline std::string* PlacementGroupTableData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupTableData.name)
  return _s;
}
inline const std::string& PlacementGroupTableData::_internal_name() const {
  return name_.Get();
}
inline void PlacementGroupTableData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupTableData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupTableData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupTableData.name)
}

// repeated .mcs.rpc.Bundle bundles = 3;
inline int PlacementGroupTableData::_internal_bundles_size() const {
  return bundles_.size();
}
inline int PlacementGroupTableData::bundles_size() const {
  return _internal_bundles_size();
}
inline ::mcs::rpc::Bundle* PlacementGroupTableData::mutable_bundles(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupTableData.bundles)
  return bundles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >*
PlacementGroupTableData::mutable_bundles() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.PlacementGroupTableData.bundles)
  return &bundles_;
}
inline const ::mcs::rpc::Bundle& PlacementGroupTableData::_internal_bundles(int index) const {
  return bundles_.Get(index);
}
inline const ::mcs::rpc::Bundle& PlacementGroupTableData::bundles(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.bundles)
  return _internal_bundles(index);
}
inline ::mcs::rpc::Bundle* PlacementGroupTableData::_internal_add_bundles() {
  return bundles_.Add();
}
inline ::mcs::rpc::Bundle* PlacementGroupTableData::add_bundles() {
  ::mcs::rpc::Bundle* _add = _internal_add_bundles();
  // @@protoc_insertion_point(field_add:mcs.rpc.PlacementGroupTableData.bundles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >&
PlacementGroupTableData::bundles() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.PlacementGroupTableData.bundles)
  return bundles_;
}

// .mcs.rpc.PlacementStrategy strategy = 4;
inline void PlacementGroupTableData::clear_strategy() {
  strategy_ = 0;
}
inline ::mcs::rpc::PlacementStrategy PlacementGroupTableData::_internal_strategy() const {
  return static_cast< ::mcs::rpc::PlacementStrategy >(strategy_);
}
inline ::mcs::rpc::PlacementStrategy PlacementGroupTableData::strategy() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.strategy)
  return _internal_strategy();
}
inline void PlacementGroupTableData::_internal_set_strategy(::mcs::rpc::PlacementStrategy value) {
  
  strategy_ = value;
}
inline void PlacementGroupTableData::set_strategy(::mcs::rpc::PlacementStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.strategy)
}

// .mcs.rpc.PlacementGroupTableData.PlacementGroupState state = 5;
inline void PlacementGroupTableData::clear_state() {
  state_ = 0;
}
inline ::mcs::rpc::PlacementGroupTableData_PlacementGroupState PlacementGroupTableData::_internal_state() const {
  return static_cast< ::mcs::rpc::PlacementGroupTableData_PlacementGroupState >(state_);
}
inline ::mcs::rpc::PlacementGroupTableData_PlacementGroupState PlacementGroupTableData::state() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.state)
  return _internal_state();
}
inline void PlacementGroupTableData::_internal_set_state(::mcs::rpc::PlacementGroupTableData_PlacementGroupState value) {
  
  state_ = value;
}
inline void PlacementGroupTableData::set_state(::mcs::rpc::PlacementGroupTableData_PlacementGroupState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.state)
}

// bytes creator_job_id = 6;
inline void PlacementGroupTableData::clear_creator_job_id() {
  creator_job_id_.ClearToEmpty();
}
inline const std::string& PlacementGroupTableData::creator_job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.creator_job_id)
  return _internal_creator_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupTableData::set_creator_job_id(ArgT0&& arg0, ArgT... args) {
 
 creator_job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.creator_job_id)
}
inline std::string* PlacementGroupTableData::mutable_creator_job_id() {
  std::string* _s = _internal_mutable_creator_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupTableData.creator_job_id)
  return _s;
}
inline const std::string& PlacementGroupTableData::_internal_creator_job_id() const {
  return creator_job_id_.Get();
}
inline void PlacementGroupTableData::_internal_set_creator_job_id(const std::string& value) {
  
  creator_job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::_internal_mutable_creator_job_id() {
  
  return creator_job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::release_creator_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupTableData.creator_job_id)
  return creator_job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupTableData::set_allocated_creator_job_id(std::string* creator_job_id) {
  if (creator_job_id != nullptr) {
    
  } else {
    
  }
  creator_job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator_job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupTableData.creator_job_id)
}

// bytes creator_actor_id = 7;
inline void PlacementGroupTableData::clear_creator_actor_id() {
  creator_actor_id_.ClearToEmpty();
}
inline const std::string& PlacementGroupTableData::creator_actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.creator_actor_id)
  return _internal_creator_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupTableData::set_creator_actor_id(ArgT0&& arg0, ArgT... args) {
 
 creator_actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.creator_actor_id)
}
inline std::string* PlacementGroupTableData::mutable_creator_actor_id() {
  std::string* _s = _internal_mutable_creator_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupTableData.creator_actor_id)
  return _s;
}
inline const std::string& PlacementGroupTableData::_internal_creator_actor_id() const {
  return creator_actor_id_.Get();
}
inline void PlacementGroupTableData::_internal_set_creator_actor_id(const std::string& value) {
  
  creator_actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::_internal_mutable_creator_actor_id() {
  
  return creator_actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::release_creator_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupTableData.creator_actor_id)
  return creator_actor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupTableData::set_allocated_creator_actor_id(std::string* creator_actor_id) {
  if (creator_actor_id != nullptr) {
    
  } else {
    
  }
  creator_actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator_actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupTableData.creator_actor_id)
}

// bool creator_job_dead = 8;
inline void PlacementGroupTableData::clear_creator_job_dead() {
  creator_job_dead_ = false;
}
inline bool PlacementGroupTableData::_internal_creator_job_dead() const {
  return creator_job_dead_;
}
inline bool PlacementGroupTableData::creator_job_dead() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.creator_job_dead)
  return _internal_creator_job_dead();
}
inline void PlacementGroupTableData::_internal_set_creator_job_dead(bool value) {
  
  creator_job_dead_ = value;
}
inline void PlacementGroupTableData::set_creator_job_dead(bool value) {
  _internal_set_creator_job_dead(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.creator_job_dead)
}

// bool creator_actor_dead = 9;
inline void PlacementGroupTableData::clear_creator_actor_dead() {
  creator_actor_dead_ = false;
}
inline bool PlacementGroupTableData::_internal_creator_actor_dead() const {
  return creator_actor_dead_;
}
inline bool PlacementGroupTableData::creator_actor_dead() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.creator_actor_dead)
  return _internal_creator_actor_dead();
}
inline void PlacementGroupTableData::_internal_set_creator_actor_dead(bool value) {
  
  creator_actor_dead_ = value;
}
inline void PlacementGroupTableData::set_creator_actor_dead(bool value) {
  _internal_set_creator_actor_dead(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.creator_actor_dead)
}

// bool is_detached = 10;
inline void PlacementGroupTableData::clear_is_detached() {
  is_detached_ = false;
}
inline bool PlacementGroupTableData::_internal_is_detached() const {
  return is_detached_;
}
inline bool PlacementGroupTableData::is_detached() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.is_detached)
  return _internal_is_detached();
}
inline void PlacementGroupTableData::_internal_set_is_detached(bool value) {
  
  is_detached_ = value;
}
inline void PlacementGroupTableData::set_is_detached(bool value) {
  _internal_set_is_detached(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.is_detached)
}

// string mcs_namespace = 11;
inline void PlacementGroupTableData::clear_mcs_namespace() {
  mcs_namespace_.ClearToEmpty();
}
inline const std::string& PlacementGroupTableData::mcs_namespace() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.mcs_namespace)
  return _internal_mcs_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupTableData::set_mcs_namespace(ArgT0&& arg0, ArgT... args) {
 
 mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.mcs_namespace)
}
inline std::string* PlacementGroupTableData::mutable_mcs_namespace() {
  std::string* _s = _internal_mutable_mcs_namespace();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupTableData.mcs_namespace)
  return _s;
}
inline const std::string& PlacementGroupTableData::_internal_mcs_namespace() const {
  return mcs_namespace_.Get();
}
inline void PlacementGroupTableData::_internal_set_mcs_namespace(const std::string& value) {
  
  mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::_internal_mutable_mcs_namespace() {
  
  return mcs_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupTableData::release_mcs_namespace() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupTableData.mcs_namespace)
  return mcs_namespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupTableData::set_allocated_mcs_namespace(std::string* mcs_namespace) {
  if (mcs_namespace != nullptr) {
    
  } else {
    
  }
  mcs_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcs_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupTableData.mcs_namespace)
}

// .mcs.rpc.PlacementGroupStats stats = 12;
inline bool PlacementGroupTableData::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool PlacementGroupTableData::has_stats() const {
  return _internal_has_stats();
}
inline void PlacementGroupTableData::clear_stats() {
  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
inline const ::mcs::rpc::PlacementGroupStats& PlacementGroupTableData::_internal_stats() const {
  const ::mcs::rpc::PlacementGroupStats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::PlacementGroupStats&>(
      ::mcs::rpc::_PlacementGroupStats_default_instance_);
}
inline const ::mcs::rpc::PlacementGroupStats& PlacementGroupTableData::stats() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.stats)
  return _internal_stats();
}
inline void PlacementGroupTableData::unsafe_arena_set_allocated_stats(
    ::mcs::rpc::PlacementGroupStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.PlacementGroupTableData.stats)
}
inline ::mcs::rpc::PlacementGroupStats* PlacementGroupTableData::release_stats() {
  
  ::mcs::rpc::PlacementGroupStats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::PlacementGroupStats* PlacementGroupTableData::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupTableData.stats)
  
  ::mcs::rpc::PlacementGroupStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::mcs::rpc::PlacementGroupStats* PlacementGroupTableData::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::PlacementGroupStats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::mcs::rpc::PlacementGroupStats* PlacementGroupTableData::mutable_stats() {
  ::mcs::rpc::PlacementGroupStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupTableData.stats)
  return _msg;
}
inline void PlacementGroupTableData::set_allocated_stats(::mcs::rpc::PlacementGroupStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::PlacementGroupStats>::GetOwningArena(stats);
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupTableData.stats)
}

// double max_cpu_fraction_per_node = 13;
inline void PlacementGroupTableData::clear_max_cpu_fraction_per_node() {
  max_cpu_fraction_per_node_ = 0;
}
inline double PlacementGroupTableData::_internal_max_cpu_fraction_per_node() const {
  return max_cpu_fraction_per_node_;
}
inline double PlacementGroupTableData::max_cpu_fraction_per_node() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupTableData.max_cpu_fraction_per_node)
  return _internal_max_cpu_fraction_per_node();
}
inline void PlacementGroupTableData::_internal_set_max_cpu_fraction_per_node(double value) {
  
  max_cpu_fraction_per_node_ = value;
}
inline void PlacementGroupTableData::set_max_cpu_fraction_per_node(double value) {
  _internal_set_max_cpu_fraction_per_node(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupTableData.max_cpu_fraction_per_node)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace mcs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mcs::rpc::ActorTableData_ActorState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::ActorTableData_ActorState>() {
  return ::mcs::rpc::ActorTableData_ActorState_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::GcsNodeInfo_GcsNodeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::GcsNodeInfo_GcsNodeState>() {
  return ::mcs::rpc::GcsNodeInfo_GcsNodeState_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::JobConfig_ActorLifetime> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::JobConfig_ActorLifetime>() {
  return ::mcs::rpc::JobConfig_ActorLifetime_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::PlacementGroupStats_SchedulingState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::PlacementGroupStats_SchedulingState>() {
  return ::mcs::rpc::PlacementGroupStats_SchedulingState_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::PlacementGroupTableData_PlacementGroupState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::PlacementGroupTableData_PlacementGroupState>() {
  return ::mcs::rpc::PlacementGroupTableData_PlacementGroupState_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::TablePrefix> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::TablePrefix>() {
  return ::mcs::rpc::TablePrefix_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::TablePubsub> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::TablePubsub>() {
  return ::mcs::rpc::TablePubsub_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::GcsChangeMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::GcsChangeMode>() {
  return ::mcs::rpc::GcsChangeMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gcs_2eproto
