// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "runtime_env_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[47]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
namespace mcs {
namespace rpc {
class ActorCreationTaskSpec;
struct ActorCreationTaskSpecDefaultTypeInternal;
extern ActorCreationTaskSpecDefaultTypeInternal _ActorCreationTaskSpec_default_instance_;
class ActorDeathCause;
struct ActorDeathCauseDefaultTypeInternal;
extern ActorDeathCauseDefaultTypeInternal _ActorDeathCause_default_instance_;
class ActorDiedErrorContext;
struct ActorDiedErrorContextDefaultTypeInternal;
extern ActorDiedErrorContextDefaultTypeInternal _ActorDiedErrorContext_default_instance_;
class ActorTaskSpec;
struct ActorTaskSpecDefaultTypeInternal;
extern ActorTaskSpecDefaultTypeInternal _ActorTaskSpec_default_instance_;
class ActorUnschedulableContext;
struct ActorUnschedulableContextDefaultTypeInternal;
extern ActorUnschedulableContextDefaultTypeInternal _ActorUnschedulableContext_default_instance_;
class Address;
struct AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class Bundle;
struct BundleDefaultTypeInternal;
extern BundleDefaultTypeInternal _Bundle_default_instance_;
class Bundle_BundleIdentifier;
struct Bundle_BundleIdentifierDefaultTypeInternal;
extern Bundle_BundleIdentifierDefaultTypeInternal _Bundle_BundleIdentifier_default_instance_;
class Bundle_UnitResourcesEntry_DoNotUse;
struct Bundle_UnitResourcesEntry_DoNotUseDefaultTypeInternal;
extern Bundle_UnitResourcesEntry_DoNotUseDefaultTypeInternal _Bundle_UnitResourcesEntry_DoNotUse_default_instance_;
class ConcurrencyGroup;
struct ConcurrencyGroupDefaultTypeInternal;
extern ConcurrencyGroupDefaultTypeInternal _ConcurrencyGroup_default_instance_;
class CoreWorkerStats;
struct CoreWorkerStatsDefaultTypeInternal;
extern CoreWorkerStatsDefaultTypeInternal _CoreWorkerStats_default_instance_;
class CoreWorkerStats_UsedResourcesEntry_DoNotUse;
struct CoreWorkerStats_UsedResourcesEntry_DoNotUseDefaultTypeInternal;
extern CoreWorkerStats_UsedResourcesEntry_DoNotUseDefaultTypeInternal _CoreWorkerStats_UsedResourcesEntry_DoNotUse_default_instance_;
class CoreWorkerStats_WebuiDisplayEntry_DoNotUse;
struct CoreWorkerStats_WebuiDisplayEntry_DoNotUseDefaultTypeInternal;
extern CoreWorkerStats_WebuiDisplayEntry_DoNotUseDefaultTypeInternal _CoreWorkerStats_WebuiDisplayEntry_DoNotUse_default_instance_;
class CppFunctionDescriptor;
struct CppFunctionDescriptorDefaultTypeInternal;
extern CppFunctionDescriptorDefaultTypeInternal _CppFunctionDescriptor_default_instance_;
class DefaultSchedulingStrategy;
struct DefaultSchedulingStrategyDefaultTypeInternal;
extern DefaultSchedulingStrategyDefaultTypeInternal _DefaultSchedulingStrategy_default_instance_;
class FunctionDescriptor;
struct FunctionDescriptorDefaultTypeInternal;
extern FunctionDescriptorDefaultTypeInternal _FunctionDescriptor_default_instance_;
class JavaFunctionDescriptor;
struct JavaFunctionDescriptorDefaultTypeInternal;
extern JavaFunctionDescriptorDefaultTypeInternal _JavaFunctionDescriptor_default_instance_;
class McsErrorInfo;
struct McsErrorInfoDefaultTypeInternal;
extern McsErrorInfoDefaultTypeInternal _McsErrorInfo_default_instance_;
class McsException;
struct McsExceptionDefaultTypeInternal;
extern McsExceptionDefaultTypeInternal _McsException_default_instance_;
class MetricPoint;
struct MetricPointDefaultTypeInternal;
extern MetricPointDefaultTypeInternal _MetricPoint_default_instance_;
class MetricPoint_TagsEntry_DoNotUse;
struct MetricPoint_TagsEntry_DoNotUseDefaultTypeInternal;
extern MetricPoint_TagsEntry_DoNotUseDefaultTypeInternal _MetricPoint_TagsEntry_DoNotUse_default_instance_;
class NamedActorInfo;
struct NamedActorInfoDefaultTypeInternal;
extern NamedActorInfoDefaultTypeInternal _NamedActorInfo_default_instance_;
class NodeAffinitySchedulingStrategy;
struct NodeAffinitySchedulingStrategyDefaultTypeInternal;
extern NodeAffinitySchedulingStrategyDefaultTypeInternal _NodeAffinitySchedulingStrategy_default_instance_;
class NodeDiedErrorContext;
struct NodeDiedErrorContextDefaultTypeInternal;
extern NodeDiedErrorContextDefaultTypeInternal _NodeDiedErrorContext_default_instance_;
class ObjectRefInfo;
struct ObjectRefInfoDefaultTypeInternal;
extern ObjectRefInfoDefaultTypeInternal _ObjectRefInfo_default_instance_;
class ObjectReference;
struct ObjectReferenceDefaultTypeInternal;
extern ObjectReferenceDefaultTypeInternal _ObjectReference_default_instance_;
class ObjectReferenceCount;
struct ObjectReferenceCountDefaultTypeInternal;
extern ObjectReferenceCountDefaultTypeInternal _ObjectReferenceCount_default_instance_;
class OutOfMemoryErrorContext;
struct OutOfMemoryErrorContextDefaultTypeInternal;
extern OutOfMemoryErrorContextDefaultTypeInternal _OutOfMemoryErrorContext_default_instance_;
class PlacementGroupSchedulingStrategy;
struct PlacementGroupSchedulingStrategyDefaultTypeInternal;
extern PlacementGroupSchedulingStrategyDefaultTypeInternal _PlacementGroupSchedulingStrategy_default_instance_;
class PlacementGroupSpec;
struct PlacementGroupSpecDefaultTypeInternal;
extern PlacementGroupSpecDefaultTypeInternal _PlacementGroupSpec_default_instance_;
class PythonFunctionDescriptor;
struct PythonFunctionDescriptorDefaultTypeInternal;
extern PythonFunctionDescriptorDefaultTypeInternal _PythonFunctionDescriptor_default_instance_;
class ResourceAllocations;
struct ResourceAllocationsDefaultTypeInternal;
extern ResourceAllocationsDefaultTypeInternal _ResourceAllocations_default_instance_;
class ResourceAllocations_ResourceSlot;
struct ResourceAllocations_ResourceSlotDefaultTypeInternal;
extern ResourceAllocations_ResourceSlotDefaultTypeInternal _ResourceAllocations_ResourceSlot_default_instance_;
class ResourceId;
struct ResourceIdDefaultTypeInternal;
extern ResourceIdDefaultTypeInternal _ResourceId_default_instance_;
class ResourceMapEntry;
struct ResourceMapEntryDefaultTypeInternal;
extern ResourceMapEntryDefaultTypeInternal _ResourceMapEntry_default_instance_;
class RuntimeEnvFailedContext;
struct RuntimeEnvFailedContextDefaultTypeInternal;
extern RuntimeEnvFailedContextDefaultTypeInternal _RuntimeEnvFailedContext_default_instance_;
class SchedulingStrategy;
struct SchedulingStrategyDefaultTypeInternal;
extern SchedulingStrategyDefaultTypeInternal _SchedulingStrategy_default_instance_;
class SpreadSchedulingStrategy;
struct SpreadSchedulingStrategyDefaultTypeInternal;
extern SpreadSchedulingStrategyDefaultTypeInternal _SpreadSchedulingStrategy_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskArg;
struct TaskArgDefaultTypeInternal;
extern TaskArgDefaultTypeInternal _TaskArg_default_instance_;
class TaskInfoEntry;
struct TaskInfoEntryDefaultTypeInternal;
extern TaskInfoEntryDefaultTypeInternal _TaskInfoEntry_default_instance_;
class TaskInfoEntry_RequiredResourcesEntry_DoNotUse;
struct TaskInfoEntry_RequiredResourcesEntry_DoNotUseDefaultTypeInternal;
extern TaskInfoEntry_RequiredResourcesEntry_DoNotUseDefaultTypeInternal _TaskInfoEntry_RequiredResourcesEntry_DoNotUse_default_instance_;
class TaskSpec;
struct TaskSpecDefaultTypeInternal;
extern TaskSpecDefaultTypeInternal _TaskSpec_default_instance_;
class TaskSpec_RequiredPlacementResourcesEntry_DoNotUse;
struct TaskSpec_RequiredPlacementResourcesEntry_DoNotUseDefaultTypeInternal;
extern TaskSpec_RequiredPlacementResourcesEntry_DoNotUseDefaultTypeInternal _TaskSpec_RequiredPlacementResourcesEntry_DoNotUse_default_instance_;
class TaskSpec_RequiredResourcesEntry_DoNotUse;
struct TaskSpec_RequiredResourcesEntry_DoNotUseDefaultTypeInternal;
extern TaskSpec_RequiredResourcesEntry_DoNotUseDefaultTypeInternal _TaskSpec_RequiredResourcesEntry_DoNotUse_default_instance_;
class ViewData;
struct ViewDataDefaultTypeInternal;
extern ViewDataDefaultTypeInternal _ViewData_default_instance_;
class ViewData_Measure;
struct ViewData_MeasureDefaultTypeInternal;
extern ViewData_MeasureDefaultTypeInternal _ViewData_Measure_default_instance_;
}  // namespace rpc
}  // namespace mcs
PROTOBUF_NAMESPACE_OPEN
template<> ::mcs::rpc::ActorCreationTaskSpec* Arena::CreateMaybeMessage<::mcs::rpc::ActorCreationTaskSpec>(Arena*);
template<> ::mcs::rpc::ActorDeathCause* Arena::CreateMaybeMessage<::mcs::rpc::ActorDeathCause>(Arena*);
template<> ::mcs::rpc::ActorDiedErrorContext* Arena::CreateMaybeMessage<::mcs::rpc::ActorDiedErrorContext>(Arena*);
template<> ::mcs::rpc::ActorTaskSpec* Arena::CreateMaybeMessage<::mcs::rpc::ActorTaskSpec>(Arena*);
template<> ::mcs::rpc::ActorUnschedulableContext* Arena::CreateMaybeMessage<::mcs::rpc::ActorUnschedulableContext>(Arena*);
template<> ::mcs::rpc::Address* Arena::CreateMaybeMessage<::mcs::rpc::Address>(Arena*);
template<> ::mcs::rpc::Bundle* Arena::CreateMaybeMessage<::mcs::rpc::Bundle>(Arena*);
template<> ::mcs::rpc::Bundle_BundleIdentifier* Arena::CreateMaybeMessage<::mcs::rpc::Bundle_BundleIdentifier>(Arena*);
template<> ::mcs::rpc::Bundle_UnitResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::Bundle_UnitResourcesEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ConcurrencyGroup* Arena::CreateMaybeMessage<::mcs::rpc::ConcurrencyGroup>(Arena*);
template<> ::mcs::rpc::CoreWorkerStats* Arena::CreateMaybeMessage<::mcs::rpc::CoreWorkerStats>(Arena*);
template<> ::mcs::rpc::CoreWorkerStats_UsedResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::CoreWorkerStats_UsedResourcesEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::CoreWorkerStats_WebuiDisplayEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::CoreWorkerStats_WebuiDisplayEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::CppFunctionDescriptor* Arena::CreateMaybeMessage<::mcs::rpc::CppFunctionDescriptor>(Arena*);
template<> ::mcs::rpc::DefaultSchedulingStrategy* Arena::CreateMaybeMessage<::mcs::rpc::DefaultSchedulingStrategy>(Arena*);
template<> ::mcs::rpc::FunctionDescriptor* Arena::CreateMaybeMessage<::mcs::rpc::FunctionDescriptor>(Arena*);
template<> ::mcs::rpc::JavaFunctionDescriptor* Arena::CreateMaybeMessage<::mcs::rpc::JavaFunctionDescriptor>(Arena*);
template<> ::mcs::rpc::McsErrorInfo* Arena::CreateMaybeMessage<::mcs::rpc::McsErrorInfo>(Arena*);
template<> ::mcs::rpc::McsException* Arena::CreateMaybeMessage<::mcs::rpc::McsException>(Arena*);
template<> ::mcs::rpc::MetricPoint* Arena::CreateMaybeMessage<::mcs::rpc::MetricPoint>(Arena*);
template<> ::mcs::rpc::MetricPoint_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::MetricPoint_TagsEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::NamedActorInfo* Arena::CreateMaybeMessage<::mcs::rpc::NamedActorInfo>(Arena*);
template<> ::mcs::rpc::NodeAffinitySchedulingStrategy* Arena::CreateMaybeMessage<::mcs::rpc::NodeAffinitySchedulingStrategy>(Arena*);
template<> ::mcs::rpc::NodeDiedErrorContext* Arena::CreateMaybeMessage<::mcs::rpc::NodeDiedErrorContext>(Arena*);
template<> ::mcs::rpc::ObjectRefInfo* Arena::CreateMaybeMessage<::mcs::rpc::ObjectRefInfo>(Arena*);
template<> ::mcs::rpc::ObjectReference* Arena::CreateMaybeMessage<::mcs::rpc::ObjectReference>(Arena*);
template<> ::mcs::rpc::ObjectReferenceCount* Arena::CreateMaybeMessage<::mcs::rpc::ObjectReferenceCount>(Arena*);
template<> ::mcs::rpc::OutOfMemoryErrorContext* Arena::CreateMaybeMessage<::mcs::rpc::OutOfMemoryErrorContext>(Arena*);
template<> ::mcs::rpc::PlacementGroupSchedulingStrategy* Arena::CreateMaybeMessage<::mcs::rpc::PlacementGroupSchedulingStrategy>(Arena*);
template<> ::mcs::rpc::PlacementGroupSpec* Arena::CreateMaybeMessage<::mcs::rpc::PlacementGroupSpec>(Arena*);
template<> ::mcs::rpc::PythonFunctionDescriptor* Arena::CreateMaybeMessage<::mcs::rpc::PythonFunctionDescriptor>(Arena*);
template<> ::mcs::rpc::ResourceAllocations* Arena::CreateMaybeMessage<::mcs::rpc::ResourceAllocations>(Arena*);
template<> ::mcs::rpc::ResourceAllocations_ResourceSlot* Arena::CreateMaybeMessage<::mcs::rpc::ResourceAllocations_ResourceSlot>(Arena*);
template<> ::mcs::rpc::ResourceId* Arena::CreateMaybeMessage<::mcs::rpc::ResourceId>(Arena*);
template<> ::mcs::rpc::ResourceMapEntry* Arena::CreateMaybeMessage<::mcs::rpc::ResourceMapEntry>(Arena*);
template<> ::mcs::rpc::RuntimeEnvFailedContext* Arena::CreateMaybeMessage<::mcs::rpc::RuntimeEnvFailedContext>(Arena*);
template<> ::mcs::rpc::SchedulingStrategy* Arena::CreateMaybeMessage<::mcs::rpc::SchedulingStrategy>(Arena*);
template<> ::mcs::rpc::SpreadSchedulingStrategy* Arena::CreateMaybeMessage<::mcs::rpc::SpreadSchedulingStrategy>(Arena*);
template<> ::mcs::rpc::Task* Arena::CreateMaybeMessage<::mcs::rpc::Task>(Arena*);
template<> ::mcs::rpc::TaskArg* Arena::CreateMaybeMessage<::mcs::rpc::TaskArg>(Arena*);
template<> ::mcs::rpc::TaskInfoEntry* Arena::CreateMaybeMessage<::mcs::rpc::TaskInfoEntry>(Arena*);
template<> ::mcs::rpc::TaskInfoEntry_RequiredResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::TaskInfoEntry_RequiredResourcesEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::TaskSpec* Arena::CreateMaybeMessage<::mcs::rpc::TaskSpec>(Arena*);
template<> ::mcs::rpc::TaskSpec_RequiredPlacementResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::TaskSpec_RequiredPlacementResourcesEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::TaskSpec_RequiredResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::mcs::rpc::TaskSpec_RequiredResourcesEntry_DoNotUse>(Arena*);
template<> ::mcs::rpc::ViewData* Arena::CreateMaybeMessage<::mcs::rpc::ViewData>(Arena*);
template<> ::mcs::rpc::ViewData_Measure* Arena::CreateMaybeMessage<::mcs::rpc::ViewData_Measure>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mcs {
namespace rpc {

enum Language : int {
  PYTHON = 0,
  JAVA = 1,
  CPP = 2,
  Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Language_IsValid(int value);
constexpr Language Language_MIN = PYTHON;
constexpr Language Language_MAX = CPP;
constexpr int Language_ARRAYSIZE = Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_descriptor();
template<typename T>
inline const std::string& Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Language_descriptor(), enum_t_value);
}
inline bool Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
enum WorkerType : int {
  WORKER = 0,
  DRIVER = 1,
  SPILL_WORKER = 2,
  RESTORE_WORKER = 3,
  WorkerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerType_IsValid(int value);
constexpr WorkerType WorkerType_MIN = WORKER;
constexpr WorkerType WorkerType_MAX = RESTORE_WORKER;
constexpr int WorkerType_ARRAYSIZE = WorkerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerType_descriptor();
template<typename T>
inline const std::string& WorkerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerType_descriptor(), enum_t_value);
}
inline bool WorkerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerType>(
    WorkerType_descriptor(), name, value);
}
enum TaskType : int {
  NORMAL_TASK = 0,
  ACTOR_CREATION_TASK = 1,
  ACTOR_TASK = 2,
  DRIVER_TASK = 3,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskType_IsValid(int value);
constexpr TaskType TaskType_MIN = NORMAL_TASK;
constexpr TaskType TaskType_MAX = DRIVER_TASK;
constexpr int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor();
template<typename T>
inline const std::string& TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskType_descriptor(), enum_t_value);
}
inline bool TaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
enum ErrorType : int {
  WORKER_DIED = 0,
  ACTOR_DIED = 1,
  OBJECT_UNRECONSTRUCTABLE = 2,
  TASK_EXECUTION_EXCEPTION = 3,
  OBJECT_IN_PLASMA = 4,
  TASK_CANCELLED = 5,
  ACTOR_CREATION_FAILED = 6,
  RUNTIME_ENV_SETUP_FAILED = 7,
  OBJECT_LOST = 8,
  OWNER_DIED = 9,
  OBJECT_DELETED = 10,
  DEPENDENCY_RESOLUTION_FAILED = 11,
  OBJECT_UNRECONSTRUCTABLE_MAX_ATTEMPTS_EXCEEDED = 12,
  OBJECT_UNRECONSTRUCTABLE_LINEAGE_EVICTED = 13,
  OBJECT_FETCH_TIMED_OUT = 14,
  LOCAL_MCSLET_DIED = 15,
  TASK_PLACEMENT_GROUP_REMOVED = 16,
  ACTOR_PLACEMENT_GROUP_REMOVED = 17,
  TASK_UNSCHEDULABLE_ERROR = 18,
  ACTOR_UNSCHEDULABLE_ERROR = 19,
  OUT_OF_DISK_ERROR = 20,
  OBJECT_FREED = 21,
  OUT_OF_MEMORY = 22,
  NODE_DIED = 23,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ErrorType_IsValid(int value);
constexpr ErrorType ErrorType_MIN = WORKER_DIED;
constexpr ErrorType ErrorType_MAX = NODE_DIED;
constexpr int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorType_descriptor();
template<typename T>
inline const std::string& ErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorType_descriptor(), enum_t_value);
}
inline bool ErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum TaskStatus : int {
  NIL = 0,
  PENDING_ARGS_AVAIL = 1,
  PENDING_NODE_ASSIGNMENT = 2,
  PENDING_OBJ_STORE_MEM_AVAIL = 3,
  PENDING_ARGS_FETCH = 4,
  SUBMITTED_TO_WORKER = 5,
  RUNNING = 6,
  RUNNING_IN_MCS_GET = 7,
  RUNNING_IN_MCS_WAIT = 8,
  FINISHED = 9,
  FAILED = 10,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = NIL;
constexpr TaskStatus TaskStatus_MAX = FAILED;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum WorkerExitType : int {
  SYSTEM_ERROR = 0,
  INTENDED_SYSTEM_EXIT = 1,
  USER_ERROR = 2,
  INTENDED_USER_EXIT = 3,
  NODE_OUT_OF_MEMORY = 4,
  WorkerExitType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkerExitType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkerExitType_IsValid(int value);
constexpr WorkerExitType WorkerExitType_MIN = SYSTEM_ERROR;
constexpr WorkerExitType WorkerExitType_MAX = NODE_OUT_OF_MEMORY;
constexpr int WorkerExitType_ARRAYSIZE = WorkerExitType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerExitType_descriptor();
template<typename T>
inline const std::string& WorkerExitType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerExitType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerExitType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerExitType_descriptor(), enum_t_value);
}
inline bool WorkerExitType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerExitType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerExitType>(
    WorkerExitType_descriptor(), name, value);
}
enum PlacementStrategy : int {
  PACK = 0,
  SPREAD = 1,
  STRICT_PACK = 2,
  STRICT_SPREAD = 3,
  PlacementStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlacementStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlacementStrategy_IsValid(int value);
constexpr PlacementStrategy PlacementStrategy_MIN = PACK;
constexpr PlacementStrategy PlacementStrategy_MAX = STRICT_SPREAD;
constexpr int PlacementStrategy_ARRAYSIZE = PlacementStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlacementStrategy_descriptor();
template<typename T>
inline const std::string& PlacementStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlacementStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlacementStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlacementStrategy_descriptor(), enum_t_value);
}
inline bool PlacementStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlacementStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlacementStrategy>(
    PlacementStrategy_descriptor(), name, value);
}
// ===================================================================

class NodeAffinitySchedulingStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.NodeAffinitySchedulingStrategy) */ {
 public:
  inline NodeAffinitySchedulingStrategy() : NodeAffinitySchedulingStrategy(nullptr) {}
  ~NodeAffinitySchedulingStrategy() override;
  explicit constexpr NodeAffinitySchedulingStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeAffinitySchedulingStrategy(const NodeAffinitySchedulingStrategy& from);
  NodeAffinitySchedulingStrategy(NodeAffinitySchedulingStrategy&& from) noexcept
    : NodeAffinitySchedulingStrategy() {
    *this = ::std::move(from);
  }

  inline NodeAffinitySchedulingStrategy& operator=(const NodeAffinitySchedulingStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeAffinitySchedulingStrategy& operator=(NodeAffinitySchedulingStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeAffinitySchedulingStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeAffinitySchedulingStrategy* internal_default_instance() {
    return reinterpret_cast<const NodeAffinitySchedulingStrategy*>(
               &_NodeAffinitySchedulingStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NodeAffinitySchedulingStrategy& a, NodeAffinitySchedulingStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeAffinitySchedulingStrategy* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeAffinitySchedulingStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeAffinitySchedulingStrategy* New() const final {
    return new NodeAffinitySchedulingStrategy();
  }

  NodeAffinitySchedulingStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeAffinitySchedulingStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeAffinitySchedulingStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeAffinitySchedulingStrategy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeAffinitySchedulingStrategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.NodeAffinitySchedulingStrategy";
  }
  protected:
  explicit NodeAffinitySchedulingStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kSoftFieldNumber = 2,
  };
  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // bool soft = 2;
  void clear_soft();
  bool soft() const;
  void set_soft(bool value);
  private:
  bool _internal_soft() const;
  void _internal_set_soft(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.NodeAffinitySchedulingStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  bool soft_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PlacementGroupSchedulingStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.PlacementGroupSchedulingStrategy) */ {
 public:
  inline PlacementGroupSchedulingStrategy() : PlacementGroupSchedulingStrategy(nullptr) {}
  ~PlacementGroupSchedulingStrategy() override;
  explicit constexpr PlacementGroupSchedulingStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlacementGroupSchedulingStrategy(const PlacementGroupSchedulingStrategy& from);
  PlacementGroupSchedulingStrategy(PlacementGroupSchedulingStrategy&& from) noexcept
    : PlacementGroupSchedulingStrategy() {
    *this = ::std::move(from);
  }

  inline PlacementGroupSchedulingStrategy& operator=(const PlacementGroupSchedulingStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlacementGroupSchedulingStrategy& operator=(PlacementGroupSchedulingStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlacementGroupSchedulingStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlacementGroupSchedulingStrategy* internal_default_instance() {
    return reinterpret_cast<const PlacementGroupSchedulingStrategy*>(
               &_PlacementGroupSchedulingStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PlacementGroupSchedulingStrategy& a, PlacementGroupSchedulingStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(PlacementGroupSchedulingStrategy* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlacementGroupSchedulingStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlacementGroupSchedulingStrategy* New() const final {
    return new PlacementGroupSchedulingStrategy();
  }

  PlacementGroupSchedulingStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlacementGroupSchedulingStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlacementGroupSchedulingStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlacementGroupSchedulingStrategy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlacementGroupSchedulingStrategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.PlacementGroupSchedulingStrategy";
  }
  protected:
  explicit PlacementGroupSchedulingStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlacementGroupIdFieldNumber = 1,
    kPlacementGroupBundleIndexFieldNumber = 2,
    kPlacementGroupCaptureChildTasksFieldNumber = 3,
  };
  // bytes placement_group_id = 1;
  void clear_placement_group_id();
  const std::string& placement_group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_placement_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_placement_group_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_placement_group_id();
  void set_allocated_placement_group_id(std::string* placement_group_id);
  private:
  const std::string& _internal_placement_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placement_group_id(const std::string& value);
  std::string* _internal_mutable_placement_group_id();
  public:

  // int64 placement_group_bundle_index = 2;
  void clear_placement_group_bundle_index();
  ::PROTOBUF_NAMESPACE_ID::int64 placement_group_bundle_index() const;
  void set_placement_group_bundle_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_placement_group_bundle_index() const;
  void _internal_set_placement_group_bundle_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool placement_group_capture_child_tasks = 3;
  void clear_placement_group_capture_child_tasks();
  bool placement_group_capture_child_tasks() const;
  void set_placement_group_capture_child_tasks(bool value);
  private:
  bool _internal_placement_group_capture_child_tasks() const;
  void _internal_set_placement_group_capture_child_tasks(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.PlacementGroupSchedulingStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placement_group_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 placement_group_bundle_index_;
  bool placement_group_capture_child_tasks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DefaultSchedulingStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.DefaultSchedulingStrategy) */ {
 public:
  inline DefaultSchedulingStrategy() : DefaultSchedulingStrategy(nullptr) {}
  ~DefaultSchedulingStrategy() override;
  explicit constexpr DefaultSchedulingStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultSchedulingStrategy(const DefaultSchedulingStrategy& from);
  DefaultSchedulingStrategy(DefaultSchedulingStrategy&& from) noexcept
    : DefaultSchedulingStrategy() {
    *this = ::std::move(from);
  }

  inline DefaultSchedulingStrategy& operator=(const DefaultSchedulingStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultSchedulingStrategy& operator=(DefaultSchedulingStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultSchedulingStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultSchedulingStrategy* internal_default_instance() {
    return reinterpret_cast<const DefaultSchedulingStrategy*>(
               &_DefaultSchedulingStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DefaultSchedulingStrategy& a, DefaultSchedulingStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultSchedulingStrategy* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultSchedulingStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DefaultSchedulingStrategy* New() const final {
    return new DefaultSchedulingStrategy();
  }

  DefaultSchedulingStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DefaultSchedulingStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultSchedulingStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DefaultSchedulingStrategy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultSchedulingStrategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.DefaultSchedulingStrategy";
  }
  protected:
  explicit DefaultSchedulingStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcs.rpc.DefaultSchedulingStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class SpreadSchedulingStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.SpreadSchedulingStrategy) */ {
 public:
  inline SpreadSchedulingStrategy() : SpreadSchedulingStrategy(nullptr) {}
  ~SpreadSchedulingStrategy() override;
  explicit constexpr SpreadSchedulingStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpreadSchedulingStrategy(const SpreadSchedulingStrategy& from);
  SpreadSchedulingStrategy(SpreadSchedulingStrategy&& from) noexcept
    : SpreadSchedulingStrategy() {
    *this = ::std::move(from);
  }

  inline SpreadSchedulingStrategy& operator=(const SpreadSchedulingStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpreadSchedulingStrategy& operator=(SpreadSchedulingStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpreadSchedulingStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpreadSchedulingStrategy* internal_default_instance() {
    return reinterpret_cast<const SpreadSchedulingStrategy*>(
               &_SpreadSchedulingStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SpreadSchedulingStrategy& a, SpreadSchedulingStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(SpreadSchedulingStrategy* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpreadSchedulingStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpreadSchedulingStrategy* New() const final {
    return new SpreadSchedulingStrategy();
  }

  SpreadSchedulingStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpreadSchedulingStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpreadSchedulingStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpreadSchedulingStrategy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpreadSchedulingStrategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.SpreadSchedulingStrategy";
  }
  protected:
  explicit SpreadSchedulingStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcs.rpc.SpreadSchedulingStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class SchedulingStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.SchedulingStrategy) */ {
 public:
  inline SchedulingStrategy() : SchedulingStrategy(nullptr) {}
  ~SchedulingStrategy() override;
  explicit constexpr SchedulingStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedulingStrategy(const SchedulingStrategy& from);
  SchedulingStrategy(SchedulingStrategy&& from) noexcept
    : SchedulingStrategy() {
    *this = ::std::move(from);
  }

  inline SchedulingStrategy& operator=(const SchedulingStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedulingStrategy& operator=(SchedulingStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedulingStrategy& default_instance() {
    return *internal_default_instance();
  }
  enum SchedulingStrategyCase {
    kDefaultSchedulingStrategy = 1,
    kPlacementGroupSchedulingStrategy = 2,
    kSpreadSchedulingStrategy = 3,
    kNodeAffinitySchedulingStrategy = 4,
    SCHEDULING_STRATEGY_NOT_SET = 0,
  };

  static inline const SchedulingStrategy* internal_default_instance() {
    return reinterpret_cast<const SchedulingStrategy*>(
               &_SchedulingStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SchedulingStrategy& a, SchedulingStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedulingStrategy* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedulingStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedulingStrategy* New() const final {
    return new SchedulingStrategy();
  }

  SchedulingStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedulingStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedulingStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SchedulingStrategy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedulingStrategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.SchedulingStrategy";
  }
  protected:
  explicit SchedulingStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultSchedulingStrategyFieldNumber = 1,
    kPlacementGroupSchedulingStrategyFieldNumber = 2,
    kSpreadSchedulingStrategyFieldNumber = 3,
    kNodeAffinitySchedulingStrategyFieldNumber = 4,
  };
  // .mcs.rpc.DefaultSchedulingStrategy default_scheduling_strategy = 1;
  bool has_default_scheduling_strategy() const;
  private:
  bool _internal_has_default_scheduling_strategy() const;
  public:
  void clear_default_scheduling_strategy();
  const ::mcs::rpc::DefaultSchedulingStrategy& default_scheduling_strategy() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::DefaultSchedulingStrategy* release_default_scheduling_strategy();
  ::mcs::rpc::DefaultSchedulingStrategy* mutable_default_scheduling_strategy();
  void set_allocated_default_scheduling_strategy(::mcs::rpc::DefaultSchedulingStrategy* default_scheduling_strategy);
  private:
  const ::mcs::rpc::DefaultSchedulingStrategy& _internal_default_scheduling_strategy() const;
  ::mcs::rpc::DefaultSchedulingStrategy* _internal_mutable_default_scheduling_strategy();
  public:
  void unsafe_arena_set_allocated_default_scheduling_strategy(
      ::mcs::rpc::DefaultSchedulingStrategy* default_scheduling_strategy);
  ::mcs::rpc::DefaultSchedulingStrategy* unsafe_arena_release_default_scheduling_strategy();

  // .mcs.rpc.PlacementGroupSchedulingStrategy placement_group_scheduling_strategy = 2;
  bool has_placement_group_scheduling_strategy() const;
  private:
  bool _internal_has_placement_group_scheduling_strategy() const;
  public:
  void clear_placement_group_scheduling_strategy();
  const ::mcs::rpc::PlacementGroupSchedulingStrategy& placement_group_scheduling_strategy() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::PlacementGroupSchedulingStrategy* release_placement_group_scheduling_strategy();
  ::mcs::rpc::PlacementGroupSchedulingStrategy* mutable_placement_group_scheduling_strategy();
  void set_allocated_placement_group_scheduling_strategy(::mcs::rpc::PlacementGroupSchedulingStrategy* placement_group_scheduling_strategy);
  private:
  const ::mcs::rpc::PlacementGroupSchedulingStrategy& _internal_placement_group_scheduling_strategy() const;
  ::mcs::rpc::PlacementGroupSchedulingStrategy* _internal_mutable_placement_group_scheduling_strategy();
  public:
  void unsafe_arena_set_allocated_placement_group_scheduling_strategy(
      ::mcs::rpc::PlacementGroupSchedulingStrategy* placement_group_scheduling_strategy);
  ::mcs::rpc::PlacementGroupSchedulingStrategy* unsafe_arena_release_placement_group_scheduling_strategy();

  // .mcs.rpc.SpreadSchedulingStrategy spread_scheduling_strategy = 3;
  bool has_spread_scheduling_strategy() const;
  private:
  bool _internal_has_spread_scheduling_strategy() const;
  public:
  void clear_spread_scheduling_strategy();
  const ::mcs::rpc::SpreadSchedulingStrategy& spread_scheduling_strategy() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::SpreadSchedulingStrategy* release_spread_scheduling_strategy();
  ::mcs::rpc::SpreadSchedulingStrategy* mutable_spread_scheduling_strategy();
  void set_allocated_spread_scheduling_strategy(::mcs::rpc::SpreadSchedulingStrategy* spread_scheduling_strategy);
  private:
  const ::mcs::rpc::SpreadSchedulingStrategy& _internal_spread_scheduling_strategy() const;
  ::mcs::rpc::SpreadSchedulingStrategy* _internal_mutable_spread_scheduling_strategy();
  public:
  void unsafe_arena_set_allocated_spread_scheduling_strategy(
      ::mcs::rpc::SpreadSchedulingStrategy* spread_scheduling_strategy);
  ::mcs::rpc::SpreadSchedulingStrategy* unsafe_arena_release_spread_scheduling_strategy();

  // .mcs.rpc.NodeAffinitySchedulingStrategy node_affinity_scheduling_strategy = 4;
  bool has_node_affinity_scheduling_strategy() const;
  private:
  bool _internal_has_node_affinity_scheduling_strategy() const;
  public:
  void clear_node_affinity_scheduling_strategy();
  const ::mcs::rpc::NodeAffinitySchedulingStrategy& node_affinity_scheduling_strategy() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::NodeAffinitySchedulingStrategy* release_node_affinity_scheduling_strategy();
  ::mcs::rpc::NodeAffinitySchedulingStrategy* mutable_node_affinity_scheduling_strategy();
  void set_allocated_node_affinity_scheduling_strategy(::mcs::rpc::NodeAffinitySchedulingStrategy* node_affinity_scheduling_strategy);
  private:
  const ::mcs::rpc::NodeAffinitySchedulingStrategy& _internal_node_affinity_scheduling_strategy() const;
  ::mcs::rpc::NodeAffinitySchedulingStrategy* _internal_mutable_node_affinity_scheduling_strategy();
  public:
  void unsafe_arena_set_allocated_node_affinity_scheduling_strategy(
      ::mcs::rpc::NodeAffinitySchedulingStrategy* node_affinity_scheduling_strategy);
  ::mcs::rpc::NodeAffinitySchedulingStrategy* unsafe_arena_release_node_affinity_scheduling_strategy();

  void clear_scheduling_strategy();
  SchedulingStrategyCase scheduling_strategy_case() const;
  // @@protoc_insertion_point(class_scope:mcs.rpc.SchedulingStrategy)
 private:
  class _Internal;
  void set_has_default_scheduling_strategy();
  void set_has_placement_group_scheduling_strategy();
  void set_has_spread_scheduling_strategy();
  void set_has_node_affinity_scheduling_strategy();

  inline bool has_scheduling_strategy() const;
  inline void clear_has_scheduling_strategy();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SchedulingStrategyUnion {
    constexpr SchedulingStrategyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::mcs::rpc::DefaultSchedulingStrategy* default_scheduling_strategy_;
    ::mcs::rpc::PlacementGroupSchedulingStrategy* placement_group_scheduling_strategy_;
    ::mcs::rpc::SpreadSchedulingStrategy* spread_scheduling_strategy_;
    ::mcs::rpc::NodeAffinitySchedulingStrategy* node_affinity_scheduling_strategy_;
  } scheduling_strategy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Address final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.Address) */ {
 public:
  inline Address() : Address(nullptr) {}
  ~Address() override;
  explicit constexpr Address(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Address(const Address& from);
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline Address& operator=(Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }
  inline void Swap(Address* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Address* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Address* New() const final {
    return new Address();
  }

  Address* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Address>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Address& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Address& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Address* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.Address";
  }
  protected:
  explicit Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMcsletIdFieldNumber = 1,
    kIpAddressFieldNumber = 2,
    kWorkerIdFieldNumber = 4,
    kPortFieldNumber = 3,
  };
  // bytes mcslet_id = 1;
  void clear_mcslet_id();
  const std::string& mcslet_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcslet_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcslet_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcslet_id();
  void set_allocated_mcslet_id(std::string* mcslet_id);
  private:
  const std::string& _internal_mcslet_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcslet_id(const std::string& value);
  std::string* _internal_mutable_mcslet_id();
  public:

  // string ip_address = 2;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // bytes worker_id = 4;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // int32 port = 3;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.Address)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcslet_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class JavaFunctionDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.JavaFunctionDescriptor) */ {
 public:
  inline JavaFunctionDescriptor() : JavaFunctionDescriptor(nullptr) {}
  ~JavaFunctionDescriptor() override;
  explicit constexpr JavaFunctionDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JavaFunctionDescriptor(const JavaFunctionDescriptor& from);
  JavaFunctionDescriptor(JavaFunctionDescriptor&& from) noexcept
    : JavaFunctionDescriptor() {
    *this = ::std::move(from);
  }

  inline JavaFunctionDescriptor& operator=(const JavaFunctionDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline JavaFunctionDescriptor& operator=(JavaFunctionDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JavaFunctionDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const JavaFunctionDescriptor* internal_default_instance() {
    return reinterpret_cast<const JavaFunctionDescriptor*>(
               &_JavaFunctionDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JavaFunctionDescriptor& a, JavaFunctionDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(JavaFunctionDescriptor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JavaFunctionDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JavaFunctionDescriptor* New() const final {
    return new JavaFunctionDescriptor();
  }

  JavaFunctionDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JavaFunctionDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JavaFunctionDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JavaFunctionDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JavaFunctionDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.JavaFunctionDescriptor";
  }
  protected:
  explicit JavaFunctionDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 1,
    kFunctionNameFieldNumber = 2,
    kSignatureFieldNumber = 3,
  };
  // string class_name = 1;
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // string function_name = 2;
  void clear_function_name();
  const std::string& function_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // string signature = 3;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.JavaFunctionDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PythonFunctionDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.PythonFunctionDescriptor) */ {
 public:
  inline PythonFunctionDescriptor() : PythonFunctionDescriptor(nullptr) {}
  ~PythonFunctionDescriptor() override;
  explicit constexpr PythonFunctionDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PythonFunctionDescriptor(const PythonFunctionDescriptor& from);
  PythonFunctionDescriptor(PythonFunctionDescriptor&& from) noexcept
    : PythonFunctionDescriptor() {
    *this = ::std::move(from);
  }

  inline PythonFunctionDescriptor& operator=(const PythonFunctionDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline PythonFunctionDescriptor& operator=(PythonFunctionDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PythonFunctionDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const PythonFunctionDescriptor* internal_default_instance() {
    return reinterpret_cast<const PythonFunctionDescriptor*>(
               &_PythonFunctionDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PythonFunctionDescriptor& a, PythonFunctionDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(PythonFunctionDescriptor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PythonFunctionDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PythonFunctionDescriptor* New() const final {
    return new PythonFunctionDescriptor();
  }

  PythonFunctionDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PythonFunctionDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PythonFunctionDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PythonFunctionDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PythonFunctionDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.PythonFunctionDescriptor";
  }
  protected:
  explicit PythonFunctionDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleNameFieldNumber = 1,
    kClassNameFieldNumber = 2,
    kFunctionNameFieldNumber = 3,
    kFunctionHashFieldNumber = 4,
  };
  // string module_name = 1;
  void clear_module_name();
  const std::string& module_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_module_name();
  void set_allocated_module_name(std::string* module_name);
  private:
  const std::string& _internal_module_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_name(const std::string& value);
  std::string* _internal_mutable_module_name();
  public:

  // string class_name = 2;
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // string function_name = 3;
  void clear_function_name();
  const std::string& function_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // string function_hash = 4;
  void clear_function_hash();
  const std::string& function_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_function_hash();
  void set_allocated_function_hash(std::string* function_hash);
  private:
  const std::string& _internal_function_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_hash(const std::string& value);
  std::string* _internal_mutable_function_hash();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.PythonFunctionDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CppFunctionDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.CppFunctionDescriptor) */ {
 public:
  inline CppFunctionDescriptor() : CppFunctionDescriptor(nullptr) {}
  ~CppFunctionDescriptor() override;
  explicit constexpr CppFunctionDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CppFunctionDescriptor(const CppFunctionDescriptor& from);
  CppFunctionDescriptor(CppFunctionDescriptor&& from) noexcept
    : CppFunctionDescriptor() {
    *this = ::std::move(from);
  }

  inline CppFunctionDescriptor& operator=(const CppFunctionDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CppFunctionDescriptor& operator=(CppFunctionDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CppFunctionDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const CppFunctionDescriptor* internal_default_instance() {
    return reinterpret_cast<const CppFunctionDescriptor*>(
               &_CppFunctionDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CppFunctionDescriptor& a, CppFunctionDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(CppFunctionDescriptor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CppFunctionDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CppFunctionDescriptor* New() const final {
    return new CppFunctionDescriptor();
  }

  CppFunctionDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CppFunctionDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CppFunctionDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CppFunctionDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CppFunctionDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.CppFunctionDescriptor";
  }
  protected:
  explicit CppFunctionDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionNameFieldNumber = 1,
    kCallerFieldNumber = 2,
    kClassNameFieldNumber = 3,
  };
  // string function_name = 1;
  void clear_function_name();
  const std::string& function_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // string caller = 2;
  void clear_caller();
  const std::string& caller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller();
  PROTOBUF_MUST_USE_RESULT std::string* release_caller();
  void set_allocated_caller(std::string* caller);
  private:
  const std::string& _internal_caller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller(const std::string& value);
  std::string* _internal_mutable_caller();
  public:

  // string class_name = 3;
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.CppFunctionDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class FunctionDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.FunctionDescriptor) */ {
 public:
  inline FunctionDescriptor() : FunctionDescriptor(nullptr) {}
  ~FunctionDescriptor() override;
  explicit constexpr FunctionDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionDescriptor(const FunctionDescriptor& from);
  FunctionDescriptor(FunctionDescriptor&& from) noexcept
    : FunctionDescriptor() {
    *this = ::std::move(from);
  }

  inline FunctionDescriptor& operator=(const FunctionDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionDescriptor& operator=(FunctionDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionDescriptor& default_instance() {
    return *internal_default_instance();
  }
  enum FunctionDescriptorCase {
    kJavaFunctionDescriptor = 1,
    kPythonFunctionDescriptor = 2,
    kCppFunctionDescriptor = 3,
    FUNCTION_DESCRIPTOR_NOT_SET = 0,
  };

  static inline const FunctionDescriptor* internal_default_instance() {
    return reinterpret_cast<const FunctionDescriptor*>(
               &_FunctionDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FunctionDescriptor& a, FunctionDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionDescriptor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FunctionDescriptor* New() const final {
    return new FunctionDescriptor();
  }

  FunctionDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FunctionDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FunctionDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.FunctionDescriptor";
  }
  protected:
  explicit FunctionDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJavaFunctionDescriptorFieldNumber = 1,
    kPythonFunctionDescriptorFieldNumber = 2,
    kCppFunctionDescriptorFieldNumber = 3,
  };
  // .mcs.rpc.JavaFunctionDescriptor java_function_descriptor = 1;
  bool has_java_function_descriptor() const;
  private:
  bool _internal_has_java_function_descriptor() const;
  public:
  void clear_java_function_descriptor();
  const ::mcs::rpc::JavaFunctionDescriptor& java_function_descriptor() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::JavaFunctionDescriptor* release_java_function_descriptor();
  ::mcs::rpc::JavaFunctionDescriptor* mutable_java_function_descriptor();
  void set_allocated_java_function_descriptor(::mcs::rpc::JavaFunctionDescriptor* java_function_descriptor);
  private:
  const ::mcs::rpc::JavaFunctionDescriptor& _internal_java_function_descriptor() const;
  ::mcs::rpc::JavaFunctionDescriptor* _internal_mutable_java_function_descriptor();
  public:
  void unsafe_arena_set_allocated_java_function_descriptor(
      ::mcs::rpc::JavaFunctionDescriptor* java_function_descriptor);
  ::mcs::rpc::JavaFunctionDescriptor* unsafe_arena_release_java_function_descriptor();

  // .mcs.rpc.PythonFunctionDescriptor python_function_descriptor = 2;
  bool has_python_function_descriptor() const;
  private:
  bool _internal_has_python_function_descriptor() const;
  public:
  void clear_python_function_descriptor();
  const ::mcs::rpc::PythonFunctionDescriptor& python_function_descriptor() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::PythonFunctionDescriptor* release_python_function_descriptor();
  ::mcs::rpc::PythonFunctionDescriptor* mutable_python_function_descriptor();
  void set_allocated_python_function_descriptor(::mcs::rpc::PythonFunctionDescriptor* python_function_descriptor);
  private:
  const ::mcs::rpc::PythonFunctionDescriptor& _internal_python_function_descriptor() const;
  ::mcs::rpc::PythonFunctionDescriptor* _internal_mutable_python_function_descriptor();
  public:
  void unsafe_arena_set_allocated_python_function_descriptor(
      ::mcs::rpc::PythonFunctionDescriptor* python_function_descriptor);
  ::mcs::rpc::PythonFunctionDescriptor* unsafe_arena_release_python_function_descriptor();

  // .mcs.rpc.CppFunctionDescriptor cpp_function_descriptor = 3;
  bool has_cpp_function_descriptor() const;
  private:
  bool _internal_has_cpp_function_descriptor() const;
  public:
  void clear_cpp_function_descriptor();
  const ::mcs::rpc::CppFunctionDescriptor& cpp_function_descriptor() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::CppFunctionDescriptor* release_cpp_function_descriptor();
  ::mcs::rpc::CppFunctionDescriptor* mutable_cpp_function_descriptor();
  void set_allocated_cpp_function_descriptor(::mcs::rpc::CppFunctionDescriptor* cpp_function_descriptor);
  private:
  const ::mcs::rpc::CppFunctionDescriptor& _internal_cpp_function_descriptor() const;
  ::mcs::rpc::CppFunctionDescriptor* _internal_mutable_cpp_function_descriptor();
  public:
  void unsafe_arena_set_allocated_cpp_function_descriptor(
      ::mcs::rpc::CppFunctionDescriptor* cpp_function_descriptor);
  ::mcs::rpc::CppFunctionDescriptor* unsafe_arena_release_cpp_function_descriptor();

  void clear_function_descriptor();
  FunctionDescriptorCase function_descriptor_case() const;
  // @@protoc_insertion_point(class_scope:mcs.rpc.FunctionDescriptor)
 private:
  class _Internal;
  void set_has_java_function_descriptor();
  void set_has_python_function_descriptor();
  void set_has_cpp_function_descriptor();

  inline bool has_function_descriptor() const;
  inline void clear_has_function_descriptor();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FunctionDescriptorUnion {
    constexpr FunctionDescriptorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::mcs::rpc::JavaFunctionDescriptor* java_function_descriptor_;
    ::mcs::rpc::PythonFunctionDescriptor* python_function_descriptor_;
    ::mcs::rpc::CppFunctionDescriptor* cpp_function_descriptor_;
  } function_descriptor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ConcurrencyGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ConcurrencyGroup) */ {
 public:
  inline ConcurrencyGroup() : ConcurrencyGroup(nullptr) {}
  ~ConcurrencyGroup() override;
  explicit constexpr ConcurrencyGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConcurrencyGroup(const ConcurrencyGroup& from);
  ConcurrencyGroup(ConcurrencyGroup&& from) noexcept
    : ConcurrencyGroup() {
    *this = ::std::move(from);
  }

  inline ConcurrencyGroup& operator=(const ConcurrencyGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConcurrencyGroup& operator=(ConcurrencyGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConcurrencyGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConcurrencyGroup* internal_default_instance() {
    return reinterpret_cast<const ConcurrencyGroup*>(
               &_ConcurrencyGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ConcurrencyGroup& a, ConcurrencyGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ConcurrencyGroup* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConcurrencyGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConcurrencyGroup* New() const final {
    return new ConcurrencyGroup();
  }

  ConcurrencyGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConcurrencyGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConcurrencyGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConcurrencyGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConcurrencyGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ConcurrencyGroup";
  }
  protected:
  explicit ConcurrencyGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionDescriptorsFieldNumber = 3,
    kNameFieldNumber = 1,
    kMaxConcurrencyFieldNumber = 2,
  };
  // repeated .mcs.rpc.FunctionDescriptor function_descriptors = 3;
  int function_descriptors_size() const;
  private:
  int _internal_function_descriptors_size() const;
  public:
  void clear_function_descriptors();
  ::mcs::rpc::FunctionDescriptor* mutable_function_descriptors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::FunctionDescriptor >*
      mutable_function_descriptors();
  private:
  const ::mcs::rpc::FunctionDescriptor& _internal_function_descriptors(int index) const;
  ::mcs::rpc::FunctionDescriptor* _internal_add_function_descriptors();
  public:
  const ::mcs::rpc::FunctionDescriptor& function_descriptors(int index) const;
  ::mcs::rpc::FunctionDescriptor* add_function_descriptors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::FunctionDescriptor >&
      function_descriptors() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 max_concurrency = 2;
  void clear_max_concurrency();
  ::PROTOBUF_NAMESPACE_ID::int32 max_concurrency() const;
  void set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_concurrency() const;
  void _internal_set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ConcurrencyGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::FunctionDescriptor > function_descriptors_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_concurrency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class McsErrorInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.McsErrorInfo) */ {
 public:
  inline McsErrorInfo() : McsErrorInfo(nullptr) {}
  ~McsErrorInfo() override;
  explicit constexpr McsErrorInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  McsErrorInfo(const McsErrorInfo& from);
  McsErrorInfo(McsErrorInfo&& from) noexcept
    : McsErrorInfo() {
    *this = ::std::move(from);
  }

  inline McsErrorInfo& operator=(const McsErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline McsErrorInfo& operator=(McsErrorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const McsErrorInfo& default_instance() {
    return *internal_default_instance();
  }
  enum ErrorCase {
    kActorDiedError = 2,
    kRuntimeEnvSetupFailedError = 3,
    kErrorMessage = 4,
    ERROR_NOT_SET = 0,
  };

  static inline const McsErrorInfo* internal_default_instance() {
    return reinterpret_cast<const McsErrorInfo*>(
               &_McsErrorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(McsErrorInfo& a, McsErrorInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(McsErrorInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(McsErrorInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline McsErrorInfo* New() const final {
    return new McsErrorInfo();
  }

  McsErrorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<McsErrorInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const McsErrorInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const McsErrorInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(McsErrorInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.McsErrorInfo";
  }
  protected:
  explicit McsErrorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorTypeFieldNumber = 11,
    kActorDiedErrorFieldNumber = 2,
    kRuntimeEnvSetupFailedErrorFieldNumber = 3,
    kErrorMessageFieldNumber = 4,
  };
  // optional .mcs.rpc.ErrorType error_type = 11;
  bool has_error_type() const;
  private:
  bool _internal_has_error_type() const;
  public:
  void clear_error_type();
  ::mcs::rpc::ErrorType error_type() const;
  void set_error_type(::mcs::rpc::ErrorType value);
  private:
  ::mcs::rpc::ErrorType _internal_error_type() const;
  void _internal_set_error_type(::mcs::rpc::ErrorType value);
  public:

  // .mcs.rpc.ActorDeathCause actor_died_error = 2;
  bool has_actor_died_error() const;
  private:
  bool _internal_has_actor_died_error() const;
  public:
  void clear_actor_died_error();
  const ::mcs::rpc::ActorDeathCause& actor_died_error() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ActorDeathCause* release_actor_died_error();
  ::mcs::rpc::ActorDeathCause* mutable_actor_died_error();
  void set_allocated_actor_died_error(::mcs::rpc::ActorDeathCause* actor_died_error);
  private:
  const ::mcs::rpc::ActorDeathCause& _internal_actor_died_error() const;
  ::mcs::rpc::ActorDeathCause* _internal_mutable_actor_died_error();
  public:
  void unsafe_arena_set_allocated_actor_died_error(
      ::mcs::rpc::ActorDeathCause* actor_died_error);
  ::mcs::rpc::ActorDeathCause* unsafe_arena_release_actor_died_error();

  // .mcs.rpc.RuntimeEnvFailedContext runtime_env_setup_failed_error = 3;
  bool has_runtime_env_setup_failed_error() const;
  private:
  bool _internal_has_runtime_env_setup_failed_error() const;
  public:
  void clear_runtime_env_setup_failed_error();
  const ::mcs::rpc::RuntimeEnvFailedContext& runtime_env_setup_failed_error() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::RuntimeEnvFailedContext* release_runtime_env_setup_failed_error();
  ::mcs::rpc::RuntimeEnvFailedContext* mutable_runtime_env_setup_failed_error();
  void set_allocated_runtime_env_setup_failed_error(::mcs::rpc::RuntimeEnvFailedContext* runtime_env_setup_failed_error);
  private:
  const ::mcs::rpc::RuntimeEnvFailedContext& _internal_runtime_env_setup_failed_error() const;
  ::mcs::rpc::RuntimeEnvFailedContext* _internal_mutable_runtime_env_setup_failed_error();
  public:
  void unsafe_arena_set_allocated_runtime_env_setup_failed_error(
      ::mcs::rpc::RuntimeEnvFailedContext* runtime_env_setup_failed_error);
  ::mcs::rpc::RuntimeEnvFailedContext* unsafe_arena_release_runtime_env_setup_failed_error();

  // string error_message = 4;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  void clear_error();
  ErrorCase error_case() const;
  // @@protoc_insertion_point(class_scope:mcs.rpc.McsErrorInfo)
 private:
  class _Internal;
  void set_has_actor_died_error();
  void set_has_runtime_env_setup_failed_error();
  void set_has_error_message();

  inline bool has_error() const;
  inline void clear_has_error();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int error_type_;
  union ErrorUnion {
    constexpr ErrorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::mcs::rpc::ActorDeathCause* actor_died_error_;
    ::mcs::rpc::RuntimeEnvFailedContext* runtime_env_setup_failed_error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  } error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class OutOfMemoryErrorContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.OutOfMemoryErrorContext) */ {
 public:
  inline OutOfMemoryErrorContext() : OutOfMemoryErrorContext(nullptr) {}
  ~OutOfMemoryErrorContext() override;
  explicit constexpr OutOfMemoryErrorContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutOfMemoryErrorContext(const OutOfMemoryErrorContext& from);
  OutOfMemoryErrorContext(OutOfMemoryErrorContext&& from) noexcept
    : OutOfMemoryErrorContext() {
    *this = ::std::move(from);
  }

  inline OutOfMemoryErrorContext& operator=(const OutOfMemoryErrorContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutOfMemoryErrorContext& operator=(OutOfMemoryErrorContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutOfMemoryErrorContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutOfMemoryErrorContext* internal_default_instance() {
    return reinterpret_cast<const OutOfMemoryErrorContext*>(
               &_OutOfMemoryErrorContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OutOfMemoryErrorContext& a, OutOfMemoryErrorContext& b) {
    a.Swap(&b);
  }
  inline void Swap(OutOfMemoryErrorContext* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutOfMemoryErrorContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutOfMemoryErrorContext* New() const final {
    return new OutOfMemoryErrorContext();
  }

  OutOfMemoryErrorContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutOfMemoryErrorContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutOfMemoryErrorContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OutOfMemoryErrorContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutOfMemoryErrorContext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.OutOfMemoryErrorContext";
  }
  protected:
  explicit OutOfMemoryErrorContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kTaskNameFieldNumber = 2,
    kNodeIpAddressFieldNumber = 3,
    kMemoryUsedBytesFieldNumber = 4,
    kMemoryTotalBytesFieldNumber = 5,
    kMemoryUsageFractionFieldNumber = 6,
    kMemoryThresholdFieldNumber = 7,
  };
  // bytes task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // string task_name = 2;
  void clear_task_name();
  const std::string& task_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_name();
  void set_allocated_task_name(std::string* task_name);
  private:
  const std::string& _internal_task_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_name(const std::string& value);
  std::string* _internal_mutable_task_name();
  public:

  // string node_ip_address = 3;
  void clear_node_ip_address();
  const std::string& node_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_ip_address();
  void set_allocated_node_ip_address(std::string* node_ip_address);
  private:
  const std::string& _internal_node_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_ip_address(const std::string& value);
  std::string* _internal_mutable_node_ip_address();
  public:

  // uint64 memory_used_bytes = 4;
  void clear_memory_used_bytes();
  ::PROTOBUF_NAMESPACE_ID::uint64 memory_used_bytes() const;
  void set_memory_used_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memory_used_bytes() const;
  void _internal_set_memory_used_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 memory_total_bytes = 5;
  void clear_memory_total_bytes();
  ::PROTOBUF_NAMESPACE_ID::uint64 memory_total_bytes() const;
  void set_memory_total_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memory_total_bytes() const;
  void _internal_set_memory_total_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // double memory_usage_fraction = 6;
  void clear_memory_usage_fraction();
  double memory_usage_fraction() const;
  void set_memory_usage_fraction(double value);
  private:
  double _internal_memory_usage_fraction() const;
  void _internal_set_memory_usage_fraction(double value);
  public:

  // double memory_threshold = 7;
  void clear_memory_threshold();
  double memory_threshold() const;
  void set_memory_threshold(double value);
  private:
  double _internal_memory_threshold() const;
  void _internal_set_memory_threshold(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.OutOfMemoryErrorContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memory_used_bytes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 memory_total_bytes_;
  double memory_usage_fraction_;
  double memory_threshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class NodeDiedErrorContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.NodeDiedErrorContext) */ {
 public:
  inline NodeDiedErrorContext() : NodeDiedErrorContext(nullptr) {}
  ~NodeDiedErrorContext() override;
  explicit constexpr NodeDiedErrorContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeDiedErrorContext(const NodeDiedErrorContext& from);
  NodeDiedErrorContext(NodeDiedErrorContext&& from) noexcept
    : NodeDiedErrorContext() {
    *this = ::std::move(from);
  }

  inline NodeDiedErrorContext& operator=(const NodeDiedErrorContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeDiedErrorContext& operator=(NodeDiedErrorContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeDiedErrorContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeDiedErrorContext* internal_default_instance() {
    return reinterpret_cast<const NodeDiedErrorContext*>(
               &_NodeDiedErrorContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NodeDiedErrorContext& a, NodeDiedErrorContext& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeDiedErrorContext* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeDiedErrorContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeDiedErrorContext* New() const final {
    return new NodeDiedErrorContext();
  }

  NodeDiedErrorContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeDiedErrorContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeDiedErrorContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeDiedErrorContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeDiedErrorContext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.NodeDiedErrorContext";
  }
  protected:
  explicit NodeDiedErrorContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kNodeIpAddressFieldNumber = 2,
  };
  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // string node_ip_address = 2;
  void clear_node_ip_address();
  const std::string& node_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_ip_address();
  void set_allocated_node_ip_address(std::string* node_ip_address);
  private:
  const std::string& _internal_node_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_ip_address(const std::string& value);
  std::string* _internal_mutable_node_ip_address();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.NodeDiedErrorContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_ip_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class McsException final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.McsException) */ {
 public:
  inline McsException() : McsException(nullptr) {}
  ~McsException() override;
  explicit constexpr McsException(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  McsException(const McsException& from);
  McsException(McsException&& from) noexcept
    : McsException() {
    *this = ::std::move(from);
  }

  inline McsException& operator=(const McsException& from) {
    CopyFrom(from);
    return *this;
  }
  inline McsException& operator=(McsException&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const McsException& default_instance() {
    return *internal_default_instance();
  }
  static inline const McsException* internal_default_instance() {
    return reinterpret_cast<const McsException*>(
               &_McsException_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(McsException& a, McsException& b) {
    a.Swap(&b);
  }
  inline void Swap(McsException* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(McsException* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline McsException* New() const final {
    return new McsException();
  }

  McsException* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<McsException>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const McsException& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const McsException& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(McsException* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.McsException";
  }
  protected:
  explicit McsException(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedExceptionFieldNumber = 2,
    kFormattedExceptionStringFieldNumber = 3,
    kLanguageFieldNumber = 1,
  };
  // bytes serialized_exception = 2;
  void clear_serialized_exception();
  const std::string& serialized_exception() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_exception(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_exception();
  PROTOBUF_MUST_USE_RESULT std::string* release_serialized_exception();
  void set_allocated_serialized_exception(std::string* serialized_exception);
  private:
  const std::string& _internal_serialized_exception() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_exception(const std::string& value);
  std::string* _internal_mutable_serialized_exception();
  public:

  // string formatted_exception_string = 3;
  void clear_formatted_exception_string();
  const std::string& formatted_exception_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formatted_exception_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formatted_exception_string();
  PROTOBUF_MUST_USE_RESULT std::string* release_formatted_exception_string();
  void set_allocated_formatted_exception_string(std::string* formatted_exception_string);
  private:
  const std::string& _internal_formatted_exception_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formatted_exception_string(const std::string& value);
  std::string* _internal_mutable_formatted_exception_string();
  public:

  // .mcs.rpc.Language language = 1;
  void clear_language();
  ::mcs::rpc::Language language() const;
  void set_language(::mcs::rpc::Language value);
  private:
  ::mcs::rpc::Language _internal_language() const;
  void _internal_set_language(::mcs::rpc::Language value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.McsException)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_exception_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formatted_exception_string_;
  int language_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ActorDeathCause final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ActorDeathCause) */ {
 public:
  inline ActorDeathCause() : ActorDeathCause(nullptr) {}
  ~ActorDeathCause() override;
  explicit constexpr ActorDeathCause(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActorDeathCause(const ActorDeathCause& from);
  ActorDeathCause(ActorDeathCause&& from) noexcept
    : ActorDeathCause() {
    *this = ::std::move(from);
  }

  inline ActorDeathCause& operator=(const ActorDeathCause& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorDeathCause& operator=(ActorDeathCause&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorDeathCause& default_instance() {
    return *internal_default_instance();
  }
  enum ContextCase {
    kCreationTaskFailureContext = 1,
    kRuntimeEnvFailedContext = 2,
    kActorDiedErrorContext = 3,
    kActorUnschedulableContext = 4,
    CONTEXT_NOT_SET = 0,
  };

  static inline const ActorDeathCause* internal_default_instance() {
    return reinterpret_cast<const ActorDeathCause*>(
               &_ActorDeathCause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ActorDeathCause& a, ActorDeathCause& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorDeathCause* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorDeathCause* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorDeathCause* New() const final {
    return new ActorDeathCause();
  }

  ActorDeathCause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorDeathCause>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActorDeathCause& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActorDeathCause& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorDeathCause* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ActorDeathCause";
  }
  protected:
  explicit ActorDeathCause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreationTaskFailureContextFieldNumber = 1,
    kRuntimeEnvFailedContextFieldNumber = 2,
    kActorDiedErrorContextFieldNumber = 3,
    kActorUnschedulableContextFieldNumber = 4,
  };
  // .mcs.rpc.McsException creation_task_failure_context = 1;
  bool has_creation_task_failure_context() const;
  private:
  bool _internal_has_creation_task_failure_context() const;
  public:
  void clear_creation_task_failure_context();
  const ::mcs::rpc::McsException& creation_task_failure_context() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::McsException* release_creation_task_failure_context();
  ::mcs::rpc::McsException* mutable_creation_task_failure_context();
  void set_allocated_creation_task_failure_context(::mcs::rpc::McsException* creation_task_failure_context);
  private:
  const ::mcs::rpc::McsException& _internal_creation_task_failure_context() const;
  ::mcs::rpc::McsException* _internal_mutable_creation_task_failure_context();
  public:
  void unsafe_arena_set_allocated_creation_task_failure_context(
      ::mcs::rpc::McsException* creation_task_failure_context);
  ::mcs::rpc::McsException* unsafe_arena_release_creation_task_failure_context();

  // .mcs.rpc.RuntimeEnvFailedContext runtime_env_failed_context = 2;
  bool has_runtime_env_failed_context() const;
  private:
  bool _internal_has_runtime_env_failed_context() const;
  public:
  void clear_runtime_env_failed_context();
  const ::mcs::rpc::RuntimeEnvFailedContext& runtime_env_failed_context() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::RuntimeEnvFailedContext* release_runtime_env_failed_context();
  ::mcs::rpc::RuntimeEnvFailedContext* mutable_runtime_env_failed_context();
  void set_allocated_runtime_env_failed_context(::mcs::rpc::RuntimeEnvFailedContext* runtime_env_failed_context);
  private:
  const ::mcs::rpc::RuntimeEnvFailedContext& _internal_runtime_env_failed_context() const;
  ::mcs::rpc::RuntimeEnvFailedContext* _internal_mutable_runtime_env_failed_context();
  public:
  void unsafe_arena_set_allocated_runtime_env_failed_context(
      ::mcs::rpc::RuntimeEnvFailedContext* runtime_env_failed_context);
  ::mcs::rpc::RuntimeEnvFailedContext* unsafe_arena_release_runtime_env_failed_context();

  // .mcs.rpc.ActorDiedErrorContext actor_died_error_context = 3;
  bool has_actor_died_error_context() const;
  private:
  bool _internal_has_actor_died_error_context() const;
  public:
  void clear_actor_died_error_context();
  const ::mcs::rpc::ActorDiedErrorContext& actor_died_error_context() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ActorDiedErrorContext* release_actor_died_error_context();
  ::mcs::rpc::ActorDiedErrorContext* mutable_actor_died_error_context();
  void set_allocated_actor_died_error_context(::mcs::rpc::ActorDiedErrorContext* actor_died_error_context);
  private:
  const ::mcs::rpc::ActorDiedErrorContext& _internal_actor_died_error_context() const;
  ::mcs::rpc::ActorDiedErrorContext* _internal_mutable_actor_died_error_context();
  public:
  void unsafe_arena_set_allocated_actor_died_error_context(
      ::mcs::rpc::ActorDiedErrorContext* actor_died_error_context);
  ::mcs::rpc::ActorDiedErrorContext* unsafe_arena_release_actor_died_error_context();

  // .mcs.rpc.ActorUnschedulableContext actor_unschedulable_context = 4;
  bool has_actor_unschedulable_context() const;
  private:
  bool _internal_has_actor_unschedulable_context() const;
  public:
  void clear_actor_unschedulable_context();
  const ::mcs::rpc::ActorUnschedulableContext& actor_unschedulable_context() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ActorUnschedulableContext* release_actor_unschedulable_context();
  ::mcs::rpc::ActorUnschedulableContext* mutable_actor_unschedulable_context();
  void set_allocated_actor_unschedulable_context(::mcs::rpc::ActorUnschedulableContext* actor_unschedulable_context);
  private:
  const ::mcs::rpc::ActorUnschedulableContext& _internal_actor_unschedulable_context() const;
  ::mcs::rpc::ActorUnschedulableContext* _internal_mutable_actor_unschedulable_context();
  public:
  void unsafe_arena_set_allocated_actor_unschedulable_context(
      ::mcs::rpc::ActorUnschedulableContext* actor_unschedulable_context);
  ::mcs::rpc::ActorUnschedulableContext* unsafe_arena_release_actor_unschedulable_context();

  void clear_context();
  ContextCase context_case() const;
  // @@protoc_insertion_point(class_scope:mcs.rpc.ActorDeathCause)
 private:
  class _Internal;
  void set_has_creation_task_failure_context();
  void set_has_runtime_env_failed_context();
  void set_has_actor_died_error_context();
  void set_has_actor_unschedulable_context();

  inline bool has_context() const;
  inline void clear_has_context();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ContextUnion {
    constexpr ContextUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::mcs::rpc::McsException* creation_task_failure_context_;
    ::mcs::rpc::RuntimeEnvFailedContext* runtime_env_failed_context_;
    ::mcs::rpc::ActorDiedErrorContext* actor_died_error_context_;
    ::mcs::rpc::ActorUnschedulableContext* actor_unschedulable_context_;
  } context_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class RuntimeEnvFailedContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.RuntimeEnvFailedContext) */ {
 public:
  inline RuntimeEnvFailedContext() : RuntimeEnvFailedContext(nullptr) {}
  ~RuntimeEnvFailedContext() override;
  explicit constexpr RuntimeEnvFailedContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeEnvFailedContext(const RuntimeEnvFailedContext& from);
  RuntimeEnvFailedContext(RuntimeEnvFailedContext&& from) noexcept
    : RuntimeEnvFailedContext() {
    *this = ::std::move(from);
  }

  inline RuntimeEnvFailedContext& operator=(const RuntimeEnvFailedContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeEnvFailedContext& operator=(RuntimeEnvFailedContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeEnvFailedContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeEnvFailedContext* internal_default_instance() {
    return reinterpret_cast<const RuntimeEnvFailedContext*>(
               &_RuntimeEnvFailedContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RuntimeEnvFailedContext& a, RuntimeEnvFailedContext& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeEnvFailedContext* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeEnvFailedContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeEnvFailedContext* New() const final {
    return new RuntimeEnvFailedContext();
  }

  RuntimeEnvFailedContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeEnvFailedContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeEnvFailedContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuntimeEnvFailedContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeEnvFailedContext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.RuntimeEnvFailedContext";
  }
  protected:
  explicit RuntimeEnvFailedContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // string error_message = 1;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.RuntimeEnvFailedContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ActorUnschedulableContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ActorUnschedulableContext) */ {
 public:
  inline ActorUnschedulableContext() : ActorUnschedulableContext(nullptr) {}
  ~ActorUnschedulableContext() override;
  explicit constexpr ActorUnschedulableContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActorUnschedulableContext(const ActorUnschedulableContext& from);
  ActorUnschedulableContext(ActorUnschedulableContext&& from) noexcept
    : ActorUnschedulableContext() {
    *this = ::std::move(from);
  }

  inline ActorUnschedulableContext& operator=(const ActorUnschedulableContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorUnschedulableContext& operator=(ActorUnschedulableContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorUnschedulableContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActorUnschedulableContext* internal_default_instance() {
    return reinterpret_cast<const ActorUnschedulableContext*>(
               &_ActorUnschedulableContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ActorUnschedulableContext& a, ActorUnschedulableContext& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorUnschedulableContext* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorUnschedulableContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorUnschedulableContext* New() const final {
    return new ActorUnschedulableContext();
  }

  ActorUnschedulableContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorUnschedulableContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActorUnschedulableContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActorUnschedulableContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorUnschedulableContext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ActorUnschedulableContext";
  }
  protected:
  explicit ActorUnschedulableContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // string error_message = 1;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ActorUnschedulableContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ActorDiedErrorContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ActorDiedErrorContext) */ {
 public:
  inline ActorDiedErrorContext() : ActorDiedErrorContext(nullptr) {}
  ~ActorDiedErrorContext() override;
  explicit constexpr ActorDiedErrorContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActorDiedErrorContext(const ActorDiedErrorContext& from);
  ActorDiedErrorContext(ActorDiedErrorContext&& from) noexcept
    : ActorDiedErrorContext() {
    *this = ::std::move(from);
  }

  inline ActorDiedErrorContext& operator=(const ActorDiedErrorContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorDiedErrorContext& operator=(ActorDiedErrorContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorDiedErrorContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActorDiedErrorContext* internal_default_instance() {
    return reinterpret_cast<const ActorDiedErrorContext*>(
               &_ActorDiedErrorContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ActorDiedErrorContext& a, ActorDiedErrorContext& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorDiedErrorContext* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorDiedErrorContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorDiedErrorContext* New() const final {
    return new ActorDiedErrorContext();
  }

  ActorDiedErrorContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorDiedErrorContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActorDiedErrorContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActorDiedErrorContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorDiedErrorContext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ActorDiedErrorContext";
  }
  protected:
  explicit ActorDiedErrorContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
    kOwnerIdFieldNumber = 2,
    kOwnerIpAddressFieldNumber = 3,
    kNodeIpAddressFieldNumber = 4,
    kNameFieldNumber = 6,
    kMcsNamespaceFieldNumber = 7,
    kClassNameFieldNumber = 8,
    kActorIdFieldNumber = 9,
    kPidFieldNumber = 5,
    kNeverStartedFieldNumber = 10,
  };
  // string error_message = 1;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bytes owner_id = 2;
  void clear_owner_id();
  const std::string& owner_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_owner_id();
  void set_allocated_owner_id(std::string* owner_id);
  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(const std::string& value);
  std::string* _internal_mutable_owner_id();
  public:

  // string owner_ip_address = 3;
  void clear_owner_ip_address();
  const std::string& owner_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_owner_ip_address();
  void set_allocated_owner_ip_address(std::string* owner_ip_address);
  private:
  const std::string& _internal_owner_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_ip_address(const std::string& value);
  std::string* _internal_mutable_owner_ip_address();
  public:

  // string node_ip_address = 4;
  void clear_node_ip_address();
  const std::string& node_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_ip_address();
  void set_allocated_node_ip_address(std::string* node_ip_address);
  private:
  const std::string& _internal_node_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_ip_address(const std::string& value);
  std::string* _internal_mutable_node_ip_address();
  public:

  // string name = 6;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mcs_namespace = 7;
  void clear_mcs_namespace();
  const std::string& mcs_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcs_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcs_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcs_namespace();
  void set_allocated_mcs_namespace(std::string* mcs_namespace);
  private:
  const std::string& _internal_mcs_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcs_namespace(const std::string& value);
  std::string* _internal_mutable_mcs_namespace();
  public:

  // string class_name = 8;
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // bytes actor_id = 9;
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // uint32 pid = 5;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool never_started = 10;
  void clear_never_started();
  bool never_started() const;
  void set_never_started(bool value);
  private:
  bool _internal_never_started() const;
  void _internal_set_never_started(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ActorDiedErrorContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcs_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  bool never_started_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TaskSpec_RequiredResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskSpec_RequiredResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskSpec_RequiredResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  TaskSpec_RequiredResourcesEntry_DoNotUse();
  explicit constexpr TaskSpec_RequiredResourcesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TaskSpec_RequiredResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TaskSpec_RequiredResourcesEntry_DoNotUse& other);
  static const TaskSpec_RequiredResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskSpec_RequiredResourcesEntry_DoNotUse*>(&_TaskSpec_RequiredResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.TaskSpec.RequiredResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TaskSpec_RequiredPlacementResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskSpec_RequiredPlacementResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskSpec_RequiredPlacementResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  TaskSpec_RequiredPlacementResourcesEntry_DoNotUse();
  explicit constexpr TaskSpec_RequiredPlacementResourcesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TaskSpec_RequiredPlacementResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TaskSpec_RequiredPlacementResourcesEntry_DoNotUse& other);
  static const TaskSpec_RequiredPlacementResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskSpec_RequiredPlacementResourcesEntry_DoNotUse*>(&_TaskSpec_RequiredPlacementResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.TaskSpec.RequiredPlacementResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TaskSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.TaskSpec) */ {
 public:
  inline TaskSpec() : TaskSpec(nullptr) {}
  ~TaskSpec() override;
  explicit constexpr TaskSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskSpec(const TaskSpec& from);
  TaskSpec(TaskSpec&& from) noexcept
    : TaskSpec() {
    *this = ::std::move(from);
  }

  inline TaskSpec& operator=(const TaskSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskSpec& operator=(TaskSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskSpec* internal_default_instance() {
    return reinterpret_cast<const TaskSpec*>(
               &_TaskSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TaskSpec& a, TaskSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskSpec* New() const final {
    return new TaskSpec();
  }

  TaskSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.TaskSpec";
  }
  protected:
  explicit TaskSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 11,
    kRequiredResourcesFieldNumber = 13,
    kRequiredPlacementResourcesFieldNumber = 14,
    kDynamicReturnIdsFieldNumber = 31,
    kNameFieldNumber = 2,
    kJobIdFieldNumber = 5,
    kTaskIdFieldNumber = 6,
    kParentTaskIdFieldNumber = 7,
    kCallerIdFieldNumber = 9,
    kDebuggerBreakpointFieldNumber = 22,
    kConcurrencyGroupNameFieldNumber = 24,
    kSerializedRetryExceptionAllowlistFieldNumber = 26,
    kFunctionDescriptorFieldNumber = 4,
    kCallerAddressFieldNumber = 10,
    kActorCreationTaskSpecFieldNumber = 15,
    kActorTaskSpecFieldNumber = 16,
    kRuntimeEnvInfoFieldNumber = 23,
    kSchedulingStrategyFieldNumber = 28,
    kTypeFieldNumber = 1,
    kLanguageFieldNumber = 3,
    kParentCounterFieldNumber = 8,
    kNumReturnsFieldNumber = 12,
    kMaxRetriesFieldNumber = 17,
    kSkipExecutionFieldNumber = 21,
    kRetryExceptionsFieldNumber = 25,
    kReturnsDynamicFieldNumber = 30,
    kDepthFieldNumber = 27,
    kAttemptNumberFieldNumber = 29,
  };
  // repeated .mcs.rpc.TaskArg args = 11;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::mcs::rpc::TaskArg* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskArg >*
      mutable_args();
  private:
  const ::mcs::rpc::TaskArg& _internal_args(int index) const;
  ::mcs::rpc::TaskArg* _internal_add_args();
  public:
  const ::mcs::rpc::TaskArg& args(int index) const;
  ::mcs::rpc::TaskArg* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskArg >&
      args() const;

  // map<string, double> required_resources = 13;
  int required_resources_size() const;
  private:
  int _internal_required_resources_size() const;
  public:
  void clear_required_resources();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_required_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_required_resources();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      required_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_required_resources();

  // map<string, double> required_placement_resources = 14;
  int required_placement_resources_size() const;
  private:
  int _internal_required_placement_resources_size() const;
  public:
  void clear_required_placement_resources();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_required_placement_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_required_placement_resources();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      required_placement_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_required_placement_resources();

  // repeated bytes dynamic_return_ids = 31;
  int dynamic_return_ids_size() const;
  private:
  int _internal_dynamic_return_ids_size() const;
  public:
  void clear_dynamic_return_ids();
  const std::string& dynamic_return_ids(int index) const;
  std::string* mutable_dynamic_return_ids(int index);
  void set_dynamic_return_ids(int index, const std::string& value);
  void set_dynamic_return_ids(int index, std::string&& value);
  void set_dynamic_return_ids(int index, const char* value);
  void set_dynamic_return_ids(int index, const void* value, size_t size);
  std::string* add_dynamic_return_ids();
  void add_dynamic_return_ids(const std::string& value);
  void add_dynamic_return_ids(std::string&& value);
  void add_dynamic_return_ids(const char* value);
  void add_dynamic_return_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dynamic_return_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dynamic_return_ids();
  private:
  const std::string& _internal_dynamic_return_ids(int index) const;
  std::string* _internal_add_dynamic_return_ids();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes job_id = 5;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // bytes task_id = 6;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // bytes parent_task_id = 7;
  void clear_parent_task_id();
  const std::string& parent_task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_task_id();
  void set_allocated_parent_task_id(std::string* parent_task_id);
  private:
  const std::string& _internal_parent_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_task_id(const std::string& value);
  std::string* _internal_mutable_parent_task_id();
  public:

  // bytes caller_id = 9;
  void clear_caller_id();
  const std::string& caller_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_caller_id();
  void set_allocated_caller_id(std::string* caller_id);
  private:
  const std::string& _internal_caller_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller_id(const std::string& value);
  std::string* _internal_mutable_caller_id();
  public:

  // bytes debugger_breakpoint = 22;
  void clear_debugger_breakpoint();
  const std::string& debugger_breakpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debugger_breakpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debugger_breakpoint();
  PROTOBUF_MUST_USE_RESULT std::string* release_debugger_breakpoint();
  void set_allocated_debugger_breakpoint(std::string* debugger_breakpoint);
  private:
  const std::string& _internal_debugger_breakpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debugger_breakpoint(const std::string& value);
  std::string* _internal_mutable_debugger_breakpoint();
  public:

  // string concurrency_group_name = 24;
  void clear_concurrency_group_name();
  const std::string& concurrency_group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_concurrency_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_concurrency_group_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_concurrency_group_name();
  void set_allocated_concurrency_group_name(std::string* concurrency_group_name);
  private:
  const std::string& _internal_concurrency_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_concurrency_group_name(const std::string& value);
  std::string* _internal_mutable_concurrency_group_name();
  public:

  // bytes serialized_retry_exception_allowlist = 26;
  void clear_serialized_retry_exception_allowlist();
  const std::string& serialized_retry_exception_allowlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_retry_exception_allowlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_retry_exception_allowlist();
  PROTOBUF_MUST_USE_RESULT std::string* release_serialized_retry_exception_allowlist();
  void set_allocated_serialized_retry_exception_allowlist(std::string* serialized_retry_exception_allowlist);
  private:
  const std::string& _internal_serialized_retry_exception_allowlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_retry_exception_allowlist(const std::string& value);
  std::string* _internal_mutable_serialized_retry_exception_allowlist();
  public:

  // .mcs.rpc.FunctionDescriptor function_descriptor = 4;
  bool has_function_descriptor() const;
  private:
  bool _internal_has_function_descriptor() const;
  public:
  void clear_function_descriptor();
  const ::mcs::rpc::FunctionDescriptor& function_descriptor() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::FunctionDescriptor* release_function_descriptor();
  ::mcs::rpc::FunctionDescriptor* mutable_function_descriptor();
  void set_allocated_function_descriptor(::mcs::rpc::FunctionDescriptor* function_descriptor);
  private:
  const ::mcs::rpc::FunctionDescriptor& _internal_function_descriptor() const;
  ::mcs::rpc::FunctionDescriptor* _internal_mutable_function_descriptor();
  public:
  void unsafe_arena_set_allocated_function_descriptor(
      ::mcs::rpc::FunctionDescriptor* function_descriptor);
  ::mcs::rpc::FunctionDescriptor* unsafe_arena_release_function_descriptor();

  // .mcs.rpc.Address caller_address = 10;
  bool has_caller_address() const;
  private:
  bool _internal_has_caller_address() const;
  public:
  void clear_caller_address();
  const ::mcs::rpc::Address& caller_address() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::Address* release_caller_address();
  ::mcs::rpc::Address* mutable_caller_address();
  void set_allocated_caller_address(::mcs::rpc::Address* caller_address);
  private:
  const ::mcs::rpc::Address& _internal_caller_address() const;
  ::mcs::rpc::Address* _internal_mutable_caller_address();
  public:
  void unsafe_arena_set_allocated_caller_address(
      ::mcs::rpc::Address* caller_address);
  ::mcs::rpc::Address* unsafe_arena_release_caller_address();

  // .mcs.rpc.ActorCreationTaskSpec actor_creation_task_spec = 15;
  bool has_actor_creation_task_spec() const;
  private:
  bool _internal_has_actor_creation_task_spec() const;
  public:
  void clear_actor_creation_task_spec();
  const ::mcs::rpc::ActorCreationTaskSpec& actor_creation_task_spec() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ActorCreationTaskSpec* release_actor_creation_task_spec();
  ::mcs::rpc::ActorCreationTaskSpec* mutable_actor_creation_task_spec();
  void set_allocated_actor_creation_task_spec(::mcs::rpc::ActorCreationTaskSpec* actor_creation_task_spec);
  private:
  const ::mcs::rpc::ActorCreationTaskSpec& _internal_actor_creation_task_spec() const;
  ::mcs::rpc::ActorCreationTaskSpec* _internal_mutable_actor_creation_task_spec();
  public:
  void unsafe_arena_set_allocated_actor_creation_task_spec(
      ::mcs::rpc::ActorCreationTaskSpec* actor_creation_task_spec);
  ::mcs::rpc::ActorCreationTaskSpec* unsafe_arena_release_actor_creation_task_spec();

  // .mcs.rpc.ActorTaskSpec actor_task_spec = 16;
  bool has_actor_task_spec() const;
  private:
  bool _internal_has_actor_task_spec() const;
  public:
  void clear_actor_task_spec();
  const ::mcs::rpc::ActorTaskSpec& actor_task_spec() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ActorTaskSpec* release_actor_task_spec();
  ::mcs::rpc::ActorTaskSpec* mutable_actor_task_spec();
  void set_allocated_actor_task_spec(::mcs::rpc::ActorTaskSpec* actor_task_spec);
  private:
  const ::mcs::rpc::ActorTaskSpec& _internal_actor_task_spec() const;
  ::mcs::rpc::ActorTaskSpec* _internal_mutable_actor_task_spec();
  public:
  void unsafe_arena_set_allocated_actor_task_spec(
      ::mcs::rpc::ActorTaskSpec* actor_task_spec);
  ::mcs::rpc::ActorTaskSpec* unsafe_arena_release_actor_task_spec();

  // .mcs.rpc.RuntimeEnvInfo runtime_env_info = 23;
  bool has_runtime_env_info() const;
  private:
  bool _internal_has_runtime_env_info() const;
  public:
  void clear_runtime_env_info();
  const ::mcs::rpc::RuntimeEnvInfo& runtime_env_info() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::RuntimeEnvInfo* release_runtime_env_info();
  ::mcs::rpc::RuntimeEnvInfo* mutable_runtime_env_info();
  void set_allocated_runtime_env_info(::mcs::rpc::RuntimeEnvInfo* runtime_env_info);
  private:
  const ::mcs::rpc::RuntimeEnvInfo& _internal_runtime_env_info() const;
  ::mcs::rpc::RuntimeEnvInfo* _internal_mutable_runtime_env_info();
  public:
  void unsafe_arena_set_allocated_runtime_env_info(
      ::mcs::rpc::RuntimeEnvInfo* runtime_env_info);
  ::mcs::rpc::RuntimeEnvInfo* unsafe_arena_release_runtime_env_info();

  // .mcs.rpc.SchedulingStrategy scheduling_strategy = 28;
  bool has_scheduling_strategy() const;
  private:
  bool _internal_has_scheduling_strategy() const;
  public:
  void clear_scheduling_strategy();
  const ::mcs::rpc::SchedulingStrategy& scheduling_strategy() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::SchedulingStrategy* release_scheduling_strategy();
  ::mcs::rpc::SchedulingStrategy* mutable_scheduling_strategy();
  void set_allocated_scheduling_strategy(::mcs::rpc::SchedulingStrategy* scheduling_strategy);
  private:
  const ::mcs::rpc::SchedulingStrategy& _internal_scheduling_strategy() const;
  ::mcs::rpc::SchedulingStrategy* _internal_mutable_scheduling_strategy();
  public:
  void unsafe_arena_set_allocated_scheduling_strategy(
      ::mcs::rpc::SchedulingStrategy* scheduling_strategy);
  ::mcs::rpc::SchedulingStrategy* unsafe_arena_release_scheduling_strategy();

  // .mcs.rpc.TaskType type = 1;
  void clear_type();
  ::mcs::rpc::TaskType type() const;
  void set_type(::mcs::rpc::TaskType value);
  private:
  ::mcs::rpc::TaskType _internal_type() const;
  void _internal_set_type(::mcs::rpc::TaskType value);
  public:

  // .mcs.rpc.Language language = 3;
  void clear_language();
  ::mcs::rpc::Language language() const;
  void set_language(::mcs::rpc::Language value);
  private:
  ::mcs::rpc::Language _internal_language() const;
  void _internal_set_language(::mcs::rpc::Language value);
  public:

  // uint64 parent_counter = 8;
  void clear_parent_counter();
  ::PROTOBUF_NAMESPACE_ID::uint64 parent_counter() const;
  void set_parent_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_parent_counter() const;
  void _internal_set_parent_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 num_returns = 12;
  void clear_num_returns();
  ::PROTOBUF_NAMESPACE_ID::uint64 num_returns() const;
  void set_num_returns(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_num_returns() const;
  void _internal_set_num_returns(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 max_retries = 17;
  void clear_max_retries();
  ::PROTOBUF_NAMESPACE_ID::int32 max_retries() const;
  void set_max_retries(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_retries() const;
  void _internal_set_max_retries(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool skip_execution = 21;
  void clear_skip_execution();
  bool skip_execution() const;
  void set_skip_execution(bool value);
  private:
  bool _internal_skip_execution() const;
  void _internal_set_skip_execution(bool value);
  public:

  // bool retry_exceptions = 25;
  void clear_retry_exceptions();
  bool retry_exceptions() const;
  void set_retry_exceptions(bool value);
  private:
  bool _internal_retry_exceptions() const;
  void _internal_set_retry_exceptions(bool value);
  public:

  // bool returns_dynamic = 30;
  void clear_returns_dynamic();
  bool returns_dynamic() const;
  void set_returns_dynamic(bool value);
  private:
  bool _internal_returns_dynamic() const;
  void _internal_set_returns_dynamic(bool value);
  public:

  // int64 depth = 27;
  void clear_depth();
  ::PROTOBUF_NAMESPACE_ID::int64 depth() const;
  void set_depth(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_depth() const;
  void _internal_set_depth(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint64 attempt_number = 29;
  void clear_attempt_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 attempt_number() const;
  void set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_attempt_number() const;
  void _internal_set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.TaskSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskArg > args_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TaskSpec_RequiredResourcesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> required_resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TaskSpec_RequiredPlacementResourcesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> required_placement_resources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dynamic_return_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debugger_breakpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr concurrency_group_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_retry_exception_allowlist_;
  ::mcs::rpc::FunctionDescriptor* function_descriptor_;
  ::mcs::rpc::Address* caller_address_;
  ::mcs::rpc::ActorCreationTaskSpec* actor_creation_task_spec_;
  ::mcs::rpc::ActorTaskSpec* actor_task_spec_;
  ::mcs::rpc::RuntimeEnvInfo* runtime_env_info_;
  ::mcs::rpc::SchedulingStrategy* scheduling_strategy_;
  int type_;
  int language_;
  ::PROTOBUF_NAMESPACE_ID::uint64 parent_counter_;
  ::PROTOBUF_NAMESPACE_ID::uint64 num_returns_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_retries_;
  bool skip_execution_;
  bool retry_exceptions_;
  bool returns_dynamic_;
  ::PROTOBUF_NAMESPACE_ID::int64 depth_;
  ::PROTOBUF_NAMESPACE_ID::uint64 attempt_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TaskInfoEntry_RequiredResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskInfoEntry_RequiredResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskInfoEntry_RequiredResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  TaskInfoEntry_RequiredResourcesEntry_DoNotUse();
  explicit constexpr TaskInfoEntry_RequiredResourcesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TaskInfoEntry_RequiredResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TaskInfoEntry_RequiredResourcesEntry_DoNotUse& other);
  static const TaskInfoEntry_RequiredResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskInfoEntry_RequiredResourcesEntry_DoNotUse*>(&_TaskInfoEntry_RequiredResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.TaskInfoEntry.RequiredResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TaskInfoEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.TaskInfoEntry) */ {
 public:
  inline TaskInfoEntry() : TaskInfoEntry(nullptr) {}
  ~TaskInfoEntry() override;
  explicit constexpr TaskInfoEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskInfoEntry(const TaskInfoEntry& from);
  TaskInfoEntry(TaskInfoEntry&& from) noexcept
    : TaskInfoEntry() {
    *this = ::std::move(from);
  }

  inline TaskInfoEntry& operator=(const TaskInfoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskInfoEntry& operator=(TaskInfoEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskInfoEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskInfoEntry* internal_default_instance() {
    return reinterpret_cast<const TaskInfoEntry*>(
               &_TaskInfoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TaskInfoEntry& a, TaskInfoEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskInfoEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskInfoEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskInfoEntry* New() const final {
    return new TaskInfoEntry();
  }

  TaskInfoEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskInfoEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskInfoEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskInfoEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskInfoEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.TaskInfoEntry";
  }
  protected:
  explicit TaskInfoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRequiredResourcesFieldNumber = 13,
    kNameFieldNumber = 2,
    kFuncOrClassNameFieldNumber = 4,
    kJobIdFieldNumber = 6,
    kTaskIdFieldNumber = 7,
    kParentTaskIdFieldNumber = 8,
    kNodeIdFieldNumber = 24,
    kActorIdFieldNumber = 25,
    kRuntimeEnvInfoFieldNumber = 23,
    kTypeFieldNumber = 1,
    kLanguageFieldNumber = 3,
    kSchedulingStateFieldNumber = 5,
  };
  // map<string, double> required_resources = 13;
  int required_resources_size() const;
  private:
  int _internal_required_resources_size() const;
  public:
  void clear_required_resources();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_required_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_required_resources();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      required_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_required_resources();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string func_or_class_name = 4;
  void clear_func_or_class_name();
  const std::string& func_or_class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_func_or_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_func_or_class_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_func_or_class_name();
  void set_allocated_func_or_class_name(std::string* func_or_class_name);
  private:
  const std::string& _internal_func_or_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_func_or_class_name(const std::string& value);
  std::string* _internal_mutable_func_or_class_name();
  public:

  // bytes job_id = 6;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // bytes task_id = 7;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // bytes parent_task_id = 8;
  void clear_parent_task_id();
  const std::string& parent_task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_task_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_task_id();
  void set_allocated_parent_task_id(std::string* parent_task_id);
  private:
  const std::string& _internal_parent_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_task_id(const std::string& value);
  std::string* _internal_mutable_parent_task_id();
  public:

  // optional bytes node_id = 24;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // optional bytes actor_id = 25;
  bool has_actor_id() const;
  private:
  bool _internal_has_actor_id() const;
  public:
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // .mcs.rpc.RuntimeEnvInfo runtime_env_info = 23;
  bool has_runtime_env_info() const;
  private:
  bool _internal_has_runtime_env_info() const;
  public:
  void clear_runtime_env_info();
  const ::mcs::rpc::RuntimeEnvInfo& runtime_env_info() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::RuntimeEnvInfo* release_runtime_env_info();
  ::mcs::rpc::RuntimeEnvInfo* mutable_runtime_env_info();
  void set_allocated_runtime_env_info(::mcs::rpc::RuntimeEnvInfo* runtime_env_info);
  private:
  const ::mcs::rpc::RuntimeEnvInfo& _internal_runtime_env_info() const;
  ::mcs::rpc::RuntimeEnvInfo* _internal_mutable_runtime_env_info();
  public:
  void unsafe_arena_set_allocated_runtime_env_info(
      ::mcs::rpc::RuntimeEnvInfo* runtime_env_info);
  ::mcs::rpc::RuntimeEnvInfo* unsafe_arena_release_runtime_env_info();

  // .mcs.rpc.TaskType type = 1;
  void clear_type();
  ::mcs::rpc::TaskType type() const;
  void set_type(::mcs::rpc::TaskType value);
  private:
  ::mcs::rpc::TaskType _internal_type() const;
  void _internal_set_type(::mcs::rpc::TaskType value);
  public:

  // .mcs.rpc.Language language = 3;
  void clear_language();
  ::mcs::rpc::Language language() const;
  void set_language(::mcs::rpc::Language value);
  private:
  ::mcs::rpc::Language _internal_language() const;
  void _internal_set_language(::mcs::rpc::Language value);
  public:

  // .mcs.rpc.TaskStatus scheduling_state = 5;
  void clear_scheduling_state();
  ::mcs::rpc::TaskStatus scheduling_state() const;
  void set_scheduling_state(::mcs::rpc::TaskStatus value);
  private:
  ::mcs::rpc::TaskStatus _internal_scheduling_state() const;
  void _internal_set_scheduling_state(::mcs::rpc::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.TaskInfoEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TaskInfoEntry_RequiredResourcesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> required_resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr func_or_class_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::mcs::rpc::RuntimeEnvInfo* runtime_env_info_;
  int type_;
  int language_;
  int scheduling_state_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Bundle_BundleIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.Bundle.BundleIdentifier) */ {
 public:
  inline Bundle_BundleIdentifier() : Bundle_BundleIdentifier(nullptr) {}
  ~Bundle_BundleIdentifier() override;
  explicit constexpr Bundle_BundleIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bundle_BundleIdentifier(const Bundle_BundleIdentifier& from);
  Bundle_BundleIdentifier(Bundle_BundleIdentifier&& from) noexcept
    : Bundle_BundleIdentifier() {
    *this = ::std::move(from);
  }

  inline Bundle_BundleIdentifier& operator=(const Bundle_BundleIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bundle_BundleIdentifier& operator=(Bundle_BundleIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bundle_BundleIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bundle_BundleIdentifier* internal_default_instance() {
    return reinterpret_cast<const Bundle_BundleIdentifier*>(
               &_Bundle_BundleIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Bundle_BundleIdentifier& a, Bundle_BundleIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(Bundle_BundleIdentifier* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bundle_BundleIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bundle_BundleIdentifier* New() const final {
    return new Bundle_BundleIdentifier();
  }

  Bundle_BundleIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bundle_BundleIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bundle_BundleIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bundle_BundleIdentifier& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bundle_BundleIdentifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.Bundle.BundleIdentifier";
  }
  protected:
  explicit Bundle_BundleIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlacementGroupIdFieldNumber = 1,
    kBundleIndexFieldNumber = 2,
  };
  // bytes placement_group_id = 1;
  void clear_placement_group_id();
  const std::string& placement_group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_placement_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_placement_group_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_placement_group_id();
  void set_allocated_placement_group_id(std::string* placement_group_id);
  private:
  const std::string& _internal_placement_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placement_group_id(const std::string& value);
  std::string* _internal_mutable_placement_group_id();
  public:

  // int32 bundle_index = 2;
  void clear_bundle_index();
  ::PROTOBUF_NAMESPACE_ID::int32 bundle_index() const;
  void set_bundle_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bundle_index() const;
  void _internal_set_bundle_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.Bundle.BundleIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placement_group_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 bundle_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Bundle_UnitResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Bundle_UnitResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Bundle_UnitResourcesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  Bundle_UnitResourcesEntry_DoNotUse();
  explicit constexpr Bundle_UnitResourcesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Bundle_UnitResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Bundle_UnitResourcesEntry_DoNotUse& other);
  static const Bundle_UnitResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Bundle_UnitResourcesEntry_DoNotUse*>(&_Bundle_UnitResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.Bundle.UnitResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Bundle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.Bundle) */ {
 public:
  inline Bundle() : Bundle(nullptr) {}
  ~Bundle() override;
  explicit constexpr Bundle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bundle(const Bundle& from);
  Bundle(Bundle&& from) noexcept
    : Bundle() {
    *this = ::std::move(from);
  }

  inline Bundle& operator=(const Bundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bundle& operator=(Bundle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bundle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bundle* internal_default_instance() {
    return reinterpret_cast<const Bundle*>(
               &_Bundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Bundle& a, Bundle& b) {
    a.Swap(&b);
  }
  inline void Swap(Bundle* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bundle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bundle* New() const final {
    return new Bundle();
  }

  Bundle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bundle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bundle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bundle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bundle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.Bundle";
  }
  protected:
  explicit Bundle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Bundle_BundleIdentifier BundleIdentifier;

  // accessors -------------------------------------------------------

  enum : int {
    kUnitResourcesFieldNumber = 2,
    kNodeIdFieldNumber = 3,
    kBundleIdFieldNumber = 1,
  };
  // map<string, double> unit_resources = 2;
  int unit_resources_size() const;
  private:
  int _internal_unit_resources_size() const;
  public:
  void clear_unit_resources();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_unit_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_unit_resources();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      unit_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_unit_resources();

  // bytes node_id = 3;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // .mcs.rpc.Bundle.BundleIdentifier bundle_id = 1;
  bool has_bundle_id() const;
  private:
  bool _internal_has_bundle_id() const;
  public:
  void clear_bundle_id();
  const ::mcs::rpc::Bundle_BundleIdentifier& bundle_id() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::Bundle_BundleIdentifier* release_bundle_id();
  ::mcs::rpc::Bundle_BundleIdentifier* mutable_bundle_id();
  void set_allocated_bundle_id(::mcs::rpc::Bundle_BundleIdentifier* bundle_id);
  private:
  const ::mcs::rpc::Bundle_BundleIdentifier& _internal_bundle_id() const;
  ::mcs::rpc::Bundle_BundleIdentifier* _internal_mutable_bundle_id();
  public:
  void unsafe_arena_set_allocated_bundle_id(
      ::mcs::rpc::Bundle_BundleIdentifier* bundle_id);
  ::mcs::rpc::Bundle_BundleIdentifier* unsafe_arena_release_bundle_id();

  // @@protoc_insertion_point(class_scope:mcs.rpc.Bundle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Bundle_UnitResourcesEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> unit_resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::mcs::rpc::Bundle_BundleIdentifier* bundle_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PlacementGroupSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.PlacementGroupSpec) */ {
 public:
  inline PlacementGroupSpec() : PlacementGroupSpec(nullptr) {}
  ~PlacementGroupSpec() override;
  explicit constexpr PlacementGroupSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlacementGroupSpec(const PlacementGroupSpec& from);
  PlacementGroupSpec(PlacementGroupSpec&& from) noexcept
    : PlacementGroupSpec() {
    *this = ::std::move(from);
  }

  inline PlacementGroupSpec& operator=(const PlacementGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlacementGroupSpec& operator=(PlacementGroupSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlacementGroupSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlacementGroupSpec* internal_default_instance() {
    return reinterpret_cast<const PlacementGroupSpec*>(
               &_PlacementGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PlacementGroupSpec& a, PlacementGroupSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(PlacementGroupSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlacementGroupSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlacementGroupSpec* New() const final {
    return new PlacementGroupSpec();
  }

  PlacementGroupSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlacementGroupSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlacementGroupSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlacementGroupSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlacementGroupSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.PlacementGroupSpec";
  }
  protected:
  explicit PlacementGroupSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBundlesFieldNumber = 3,
    kPlacementGroupIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatorJobIdFieldNumber = 5,
    kCreatorActorIdFieldNumber = 6,
    kStrategyFieldNumber = 4,
    kCreatorJobDeadFieldNumber = 7,
    kCreatorActorDeadFieldNumber = 8,
    kIsDetachedFieldNumber = 9,
    kMaxCpuFractionPerNodeFieldNumber = 10,
  };
  // repeated .mcs.rpc.Bundle bundles = 3;
  int bundles_size() const;
  private:
  int _internal_bundles_size() const;
  public:
  void clear_bundles();
  ::mcs::rpc::Bundle* mutable_bundles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >*
      mutable_bundles();
  private:
  const ::mcs::rpc::Bundle& _internal_bundles(int index) const;
  ::mcs::rpc::Bundle* _internal_add_bundles();
  public:
  const ::mcs::rpc::Bundle& bundles(int index) const;
  ::mcs::rpc::Bundle* add_bundles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >&
      bundles() const;

  // bytes placement_group_id = 1;
  void clear_placement_group_id();
  const std::string& placement_group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_placement_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_placement_group_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_placement_group_id();
  void set_allocated_placement_group_id(std::string* placement_group_id);
  private:
  const std::string& _internal_placement_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placement_group_id(const std::string& value);
  std::string* _internal_mutable_placement_group_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes creator_job_id = 5;
  void clear_creator_job_id();
  const std::string& creator_job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_creator_job_id();
  void set_allocated_creator_job_id(std::string* creator_job_id);
  private:
  const std::string& _internal_creator_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_job_id(const std::string& value);
  std::string* _internal_mutable_creator_job_id();
  public:

  // bytes creator_actor_id = 6;
  void clear_creator_actor_id();
  const std::string& creator_actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_creator_actor_id();
  void set_allocated_creator_actor_id(std::string* creator_actor_id);
  private:
  const std::string& _internal_creator_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_actor_id(const std::string& value);
  std::string* _internal_mutable_creator_actor_id();
  public:

  // .mcs.rpc.PlacementStrategy strategy = 4;
  void clear_strategy();
  ::mcs::rpc::PlacementStrategy strategy() const;
  void set_strategy(::mcs::rpc::PlacementStrategy value);
  private:
  ::mcs::rpc::PlacementStrategy _internal_strategy() const;
  void _internal_set_strategy(::mcs::rpc::PlacementStrategy value);
  public:

  // bool creator_job_dead = 7;
  void clear_creator_job_dead();
  bool creator_job_dead() const;
  void set_creator_job_dead(bool value);
  private:
  bool _internal_creator_job_dead() const;
  void _internal_set_creator_job_dead(bool value);
  public:

  // bool creator_actor_dead = 8;
  void clear_creator_actor_dead();
  bool creator_actor_dead() const;
  void set_creator_actor_dead(bool value);
  private:
  bool _internal_creator_actor_dead() const;
  void _internal_set_creator_actor_dead(bool value);
  public:

  // bool is_detached = 9;
  void clear_is_detached();
  bool is_detached() const;
  void set_is_detached(bool value);
  private:
  bool _internal_is_detached() const;
  void _internal_set_is_detached(bool value);
  public:

  // double max_cpu_fraction_per_node = 10;
  void clear_max_cpu_fraction_per_node();
  double max_cpu_fraction_per_node() const;
  void set_max_cpu_fraction_per_node(double value);
  private:
  double _internal_max_cpu_fraction_per_node() const;
  void _internal_set_max_cpu_fraction_per_node(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.PlacementGroupSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle > bundles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placement_group_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_actor_id_;
  int strategy_;
  bool creator_job_dead_;
  bool creator_actor_dead_;
  bool is_detached_;
  double max_cpu_fraction_per_node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ObjectReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ObjectReference) */ {
 public:
  inline ObjectReference() : ObjectReference(nullptr) {}
  ~ObjectReference() override;
  explicit constexpr ObjectReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectReference(const ObjectReference& from);
  ObjectReference(ObjectReference&& from) noexcept
    : ObjectReference() {
    *this = ::std::move(from);
  }

  inline ObjectReference& operator=(const ObjectReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectReference& operator=(ObjectReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectReference* internal_default_instance() {
    return reinterpret_cast<const ObjectReference*>(
               &_ObjectReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ObjectReference& a, ObjectReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectReference* New() const final {
    return new ObjectReference();
  }

  ObjectReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ObjectReference";
  }
  protected:
  explicit ObjectReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kCallSiteFieldNumber = 3,
    kOwnerAddressFieldNumber = 2,
  };
  // bytes object_id = 1;
  void clear_object_id();
  const std::string& object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_object_id();
  void set_allocated_object_id(std::string* object_id);
  private:
  const std::string& _internal_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const std::string& value);
  std::string* _internal_mutable_object_id();
  public:

  // string call_site = 3;
  void clear_call_site();
  const std::string& call_site() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_site(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_site();
  PROTOBUF_MUST_USE_RESULT std::string* release_call_site();
  void set_allocated_call_site(std::string* call_site);
  private:
  const std::string& _internal_call_site() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_site(const std::string& value);
  std::string* _internal_mutable_call_site();
  public:

  // .mcs.rpc.Address owner_address = 2;
  bool has_owner_address() const;
  private:
  bool _internal_has_owner_address() const;
  public:
  void clear_owner_address();
  const ::mcs::rpc::Address& owner_address() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::Address* release_owner_address();
  ::mcs::rpc::Address* mutable_owner_address();
  void set_allocated_owner_address(::mcs::rpc::Address* owner_address);
  private:
  const ::mcs::rpc::Address& _internal_owner_address() const;
  ::mcs::rpc::Address* _internal_mutable_owner_address();
  public:
  void unsafe_arena_set_allocated_owner_address(
      ::mcs::rpc::Address* owner_address);
  ::mcs::rpc::Address* unsafe_arena_release_owner_address();

  // @@protoc_insertion_point(class_scope:mcs.rpc.ObjectReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_site_;
  ::mcs::rpc::Address* owner_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ObjectReferenceCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ObjectReferenceCount) */ {
 public:
  inline ObjectReferenceCount() : ObjectReferenceCount(nullptr) {}
  ~ObjectReferenceCount() override;
  explicit constexpr ObjectReferenceCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectReferenceCount(const ObjectReferenceCount& from);
  ObjectReferenceCount(ObjectReferenceCount&& from) noexcept
    : ObjectReferenceCount() {
    *this = ::std::move(from);
  }

  inline ObjectReferenceCount& operator=(const ObjectReferenceCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectReferenceCount& operator=(ObjectReferenceCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectReferenceCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectReferenceCount* internal_default_instance() {
    return reinterpret_cast<const ObjectReferenceCount*>(
               &_ObjectReferenceCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ObjectReferenceCount& a, ObjectReferenceCount& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectReferenceCount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectReferenceCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectReferenceCount* New() const final {
    return new ObjectReferenceCount();
  }

  ObjectReferenceCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectReferenceCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectReferenceCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectReferenceCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectReferenceCount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ObjectReferenceCount";
  }
  protected:
  explicit ObjectReferenceCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBorrowersFieldNumber = 3,
    kStoredInObjectsFieldNumber = 4,
    kContainedInBorrowedIdsFieldNumber = 5,
    kContainsFieldNumber = 6,
    kReferenceFieldNumber = 1,
    kHasLocalRefFieldNumber = 2,
  };
  // repeated .mcs.rpc.Address borrowers = 3;
  int borrowers_size() const;
  private:
  int _internal_borrowers_size() const;
  public:
  void clear_borrowers();
  ::mcs::rpc::Address* mutable_borrowers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Address >*
      mutable_borrowers();
  private:
  const ::mcs::rpc::Address& _internal_borrowers(int index) const;
  ::mcs::rpc::Address* _internal_add_borrowers();
  public:
  const ::mcs::rpc::Address& borrowers(int index) const;
  ::mcs::rpc::Address* add_borrowers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Address >&
      borrowers() const;

  // repeated .mcs.rpc.ObjectReference stored_in_objects = 4;
  int stored_in_objects_size() const;
  private:
  int _internal_stored_in_objects_size() const;
  public:
  void clear_stored_in_objects();
  ::mcs::rpc::ObjectReference* mutable_stored_in_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >*
      mutable_stored_in_objects();
  private:
  const ::mcs::rpc::ObjectReference& _internal_stored_in_objects(int index) const;
  ::mcs::rpc::ObjectReference* _internal_add_stored_in_objects();
  public:
  const ::mcs::rpc::ObjectReference& stored_in_objects(int index) const;
  ::mcs::rpc::ObjectReference* add_stored_in_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >&
      stored_in_objects() const;

  // repeated bytes contained_in_borrowed_ids = 5;
  int contained_in_borrowed_ids_size() const;
  private:
  int _internal_contained_in_borrowed_ids_size() const;
  public:
  void clear_contained_in_borrowed_ids();
  const std::string& contained_in_borrowed_ids(int index) const;
  std::string* mutable_contained_in_borrowed_ids(int index);
  void set_contained_in_borrowed_ids(int index, const std::string& value);
  void set_contained_in_borrowed_ids(int index, std::string&& value);
  void set_contained_in_borrowed_ids(int index, const char* value);
  void set_contained_in_borrowed_ids(int index, const void* value, size_t size);
  std::string* add_contained_in_borrowed_ids();
  void add_contained_in_borrowed_ids(const std::string& value);
  void add_contained_in_borrowed_ids(std::string&& value);
  void add_contained_in_borrowed_ids(const char* value);
  void add_contained_in_borrowed_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contained_in_borrowed_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contained_in_borrowed_ids();
  private:
  const std::string& _internal_contained_in_borrowed_ids(int index) const;
  std::string* _internal_add_contained_in_borrowed_ids();
  public:

  // repeated bytes contains = 6;
  int contains_size() const;
  private:
  int _internal_contains_size() const;
  public:
  void clear_contains();
  const std::string& contains(int index) const;
  std::string* mutable_contains(int index);
  void set_contains(int index, const std::string& value);
  void set_contains(int index, std::string&& value);
  void set_contains(int index, const char* value);
  void set_contains(int index, const void* value, size_t size);
  std::string* add_contains();
  void add_contains(const std::string& value);
  void add_contains(std::string&& value);
  void add_contains(const char* value);
  void add_contains(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contains() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contains();
  private:
  const std::string& _internal_contains(int index) const;
  std::string* _internal_add_contains();
  public:

  // .mcs.rpc.ObjectReference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::mcs::rpc::ObjectReference& reference() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ObjectReference* release_reference();
  ::mcs::rpc::ObjectReference* mutable_reference();
  void set_allocated_reference(::mcs::rpc::ObjectReference* reference);
  private:
  const ::mcs::rpc::ObjectReference& _internal_reference() const;
  ::mcs::rpc::ObjectReference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::mcs::rpc::ObjectReference* reference);
  ::mcs::rpc::ObjectReference* unsafe_arena_release_reference();

  // bool has_local_ref = 2;
  void clear_has_local_ref();
  bool has_local_ref() const;
  void set_has_local_ref(bool value);
  private:
  bool _internal_has_local_ref() const;
  void _internal_set_has_local_ref(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ObjectReferenceCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Address > borrowers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference > stored_in_objects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contained_in_borrowed_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contains_;
  ::mcs::rpc::ObjectReference* reference_;
  bool has_local_ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TaskArg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.TaskArg) */ {
 public:
  inline TaskArg() : TaskArg(nullptr) {}
  ~TaskArg() override;
  explicit constexpr TaskArg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskArg(const TaskArg& from);
  TaskArg(TaskArg&& from) noexcept
    : TaskArg() {
    *this = ::std::move(from);
  }

  inline TaskArg& operator=(const TaskArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskArg& operator=(TaskArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskArg* internal_default_instance() {
    return reinterpret_cast<const TaskArg*>(
               &_TaskArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TaskArg& a, TaskArg& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskArg* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskArg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskArg* New() const final {
    return new TaskArg();
  }

  TaskArg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskArg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskArg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskArg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskArg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.TaskArg";
  }
  protected:
  explicit TaskArg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNestedInlinedRefsFieldNumber = 4,
    kDataFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kObjectRefFieldNumber = 1,
  };
  // repeated .mcs.rpc.ObjectReference nested_inlined_refs = 4;
  int nested_inlined_refs_size() const;
  private:
  int _internal_nested_inlined_refs_size() const;
  public:
  void clear_nested_inlined_refs();
  ::mcs::rpc::ObjectReference* mutable_nested_inlined_refs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >*
      mutable_nested_inlined_refs();
  private:
  const ::mcs::rpc::ObjectReference& _internal_nested_inlined_refs(int index) const;
  ::mcs::rpc::ObjectReference* _internal_add_nested_inlined_refs();
  public:
  const ::mcs::rpc::ObjectReference& nested_inlined_refs(int index) const;
  ::mcs::rpc::ObjectReference* add_nested_inlined_refs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >&
      nested_inlined_refs() const;

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes metadata = 3;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_MUST_USE_RESULT std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // .mcs.rpc.ObjectReference object_ref = 1;
  bool has_object_ref() const;
  private:
  bool _internal_has_object_ref() const;
  public:
  void clear_object_ref();
  const ::mcs::rpc::ObjectReference& object_ref() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::ObjectReference* release_object_ref();
  ::mcs::rpc::ObjectReference* mutable_object_ref();
  void set_allocated_object_ref(::mcs::rpc::ObjectReference* object_ref);
  private:
  const ::mcs::rpc::ObjectReference& _internal_object_ref() const;
  ::mcs::rpc::ObjectReference* _internal_mutable_object_ref();
  public:
  void unsafe_arena_set_allocated_object_ref(
      ::mcs::rpc::ObjectReference* object_ref);
  ::mcs::rpc::ObjectReference* unsafe_arena_release_object_ref();

  // @@protoc_insertion_point(class_scope:mcs.rpc.TaskArg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference > nested_inlined_refs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
  ::mcs::rpc::ObjectReference* object_ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ActorCreationTaskSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ActorCreationTaskSpec) */ {
 public:
  inline ActorCreationTaskSpec() : ActorCreationTaskSpec(nullptr) {}
  ~ActorCreationTaskSpec() override;
  explicit constexpr ActorCreationTaskSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActorCreationTaskSpec(const ActorCreationTaskSpec& from);
  ActorCreationTaskSpec(ActorCreationTaskSpec&& from) noexcept
    : ActorCreationTaskSpec() {
    *this = ::std::move(from);
  }

  inline ActorCreationTaskSpec& operator=(const ActorCreationTaskSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorCreationTaskSpec& operator=(ActorCreationTaskSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorCreationTaskSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActorCreationTaskSpec* internal_default_instance() {
    return reinterpret_cast<const ActorCreationTaskSpec*>(
               &_ActorCreationTaskSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ActorCreationTaskSpec& a, ActorCreationTaskSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorCreationTaskSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorCreationTaskSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorCreationTaskSpec* New() const final {
    return new ActorCreationTaskSpec();
  }

  ActorCreationTaskSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorCreationTaskSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActorCreationTaskSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActorCreationTaskSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorCreationTaskSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ActorCreationTaskSpec";
  }
  protected:
  explicit ActorCreationTaskSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDynamicWorkerOptionsFieldNumber = 5,
    kConcurrencyGroupsFieldNumber = 13,
    kActorIdFieldNumber = 2,
    kNameFieldNumber = 8,
    kMcsNamespaceFieldNumber = 9,
    kExtensionDataFieldNumber = 11,
    kSerializedActorHandleFieldNumber = 12,
    kMaxActorRestartsFieldNumber = 3,
    kMaxTaskRetriesFieldNumber = 4,
    kMaxConcurrencyFieldNumber = 6,
    kIsDetachedFieldNumber = 7,
    kIsAsyncioFieldNumber = 10,
    kExecuteOutOfOrderFieldNumber = 14,
    kMaxPendingCallsFieldNumber = 15,
  };
  // repeated string dynamic_worker_options = 5;
  int dynamic_worker_options_size() const;
  private:
  int _internal_dynamic_worker_options_size() const;
  public:
  void clear_dynamic_worker_options();
  const std::string& dynamic_worker_options(int index) const;
  std::string* mutable_dynamic_worker_options(int index);
  void set_dynamic_worker_options(int index, const std::string& value);
  void set_dynamic_worker_options(int index, std::string&& value);
  void set_dynamic_worker_options(int index, const char* value);
  void set_dynamic_worker_options(int index, const char* value, size_t size);
  std::string* add_dynamic_worker_options();
  void add_dynamic_worker_options(const std::string& value);
  void add_dynamic_worker_options(std::string&& value);
  void add_dynamic_worker_options(const char* value);
  void add_dynamic_worker_options(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dynamic_worker_options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dynamic_worker_options();
  private:
  const std::string& _internal_dynamic_worker_options(int index) const;
  std::string* _internal_add_dynamic_worker_options();
  public:

  // repeated .mcs.rpc.ConcurrencyGroup concurrency_groups = 13;
  int concurrency_groups_size() const;
  private:
  int _internal_concurrency_groups_size() const;
  public:
  void clear_concurrency_groups();
  ::mcs::rpc::ConcurrencyGroup* mutable_concurrency_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ConcurrencyGroup >*
      mutable_concurrency_groups();
  private:
  const ::mcs::rpc::ConcurrencyGroup& _internal_concurrency_groups(int index) const;
  ::mcs::rpc::ConcurrencyGroup* _internal_add_concurrency_groups();
  public:
  const ::mcs::rpc::ConcurrencyGroup& concurrency_groups(int index) const;
  ::mcs::rpc::ConcurrencyGroup* add_concurrency_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ConcurrencyGroup >&
      concurrency_groups() const;

  // bytes actor_id = 2;
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // string name = 8;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mcs_namespace = 9;
  void clear_mcs_namespace();
  const std::string& mcs_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcs_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcs_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcs_namespace();
  void set_allocated_mcs_namespace(std::string* mcs_namespace);
  private:
  const std::string& _internal_mcs_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcs_namespace(const std::string& value);
  std::string* _internal_mutable_mcs_namespace();
  public:

  // string extension_data = 11;
  void clear_extension_data();
  const std::string& extension_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_extension_data();
  void set_allocated_extension_data(std::string* extension_data);
  private:
  const std::string& _internal_extension_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_data(const std::string& value);
  std::string* _internal_mutable_extension_data();
  public:

  // bytes serialized_actor_handle = 12;
  void clear_serialized_actor_handle();
  const std::string& serialized_actor_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_actor_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_actor_handle();
  PROTOBUF_MUST_USE_RESULT std::string* release_serialized_actor_handle();
  void set_allocated_serialized_actor_handle(std::string* serialized_actor_handle);
  private:
  const std::string& _internal_serialized_actor_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_actor_handle(const std::string& value);
  std::string* _internal_mutable_serialized_actor_handle();
  public:

  // int64 max_actor_restarts = 3;
  void clear_max_actor_restarts();
  ::PROTOBUF_NAMESPACE_ID::int64 max_actor_restarts() const;
  void set_max_actor_restarts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_actor_restarts() const;
  void _internal_set_max_actor_restarts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 max_task_retries = 4;
  void clear_max_task_retries();
  ::PROTOBUF_NAMESPACE_ID::int64 max_task_retries() const;
  void set_max_task_retries(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_task_retries() const;
  void _internal_set_max_task_retries(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 max_concurrency = 6;
  void clear_max_concurrency();
  ::PROTOBUF_NAMESPACE_ID::int32 max_concurrency() const;
  void set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_concurrency() const;
  void _internal_set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_detached = 7;
  void clear_is_detached();
  bool is_detached() const;
  void set_is_detached(bool value);
  private:
  bool _internal_is_detached() const;
  void _internal_set_is_detached(bool value);
  public:

  // bool is_asyncio = 10;
  void clear_is_asyncio();
  bool is_asyncio() const;
  void set_is_asyncio(bool value);
  private:
  bool _internal_is_asyncio() const;
  void _internal_set_is_asyncio(bool value);
  public:

  // bool execute_out_of_order = 14;
  void clear_execute_out_of_order();
  bool execute_out_of_order() const;
  void set_execute_out_of_order(bool value);
  private:
  bool _internal_execute_out_of_order() const;
  void _internal_set_execute_out_of_order(bool value);
  public:

  // int32 max_pending_calls = 15;
  void clear_max_pending_calls();
  ::PROTOBUF_NAMESPACE_ID::int32 max_pending_calls() const;
  void set_max_pending_calls(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_pending_calls() const;
  void _internal_set_max_pending_calls(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ActorCreationTaskSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dynamic_worker_options_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ConcurrencyGroup > concurrency_groups_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcs_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_actor_handle_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_actor_restarts_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_task_retries_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_concurrency_;
  bool is_detached_;
  bool is_asyncio_;
  bool execute_out_of_order_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_pending_calls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ActorTaskSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ActorTaskSpec) */ {
 public:
  inline ActorTaskSpec() : ActorTaskSpec(nullptr) {}
  ~ActorTaskSpec() override;
  explicit constexpr ActorTaskSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActorTaskSpec(const ActorTaskSpec& from);
  ActorTaskSpec(ActorTaskSpec&& from) noexcept
    : ActorTaskSpec() {
    *this = ::std::move(from);
  }

  inline ActorTaskSpec& operator=(const ActorTaskSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorTaskSpec& operator=(ActorTaskSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActorTaskSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActorTaskSpec* internal_default_instance() {
    return reinterpret_cast<const ActorTaskSpec*>(
               &_ActorTaskSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ActorTaskSpec& a, ActorTaskSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorTaskSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActorTaskSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorTaskSpec* New() const final {
    return new ActorTaskSpec();
  }

  ActorTaskSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorTaskSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActorTaskSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActorTaskSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorTaskSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ActorTaskSpec";
  }
  protected:
  explicit ActorTaskSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 2,
    kActorCreationDummyObjectIdFieldNumber = 4,
    kPreviousActorTaskDummyObjectIdFieldNumber = 7,
    kActorCounterFieldNumber = 5,
  };
  // bytes actor_id = 2;
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // bytes actor_creation_dummy_object_id = 4;
  void clear_actor_creation_dummy_object_id();
  const std::string& actor_creation_dummy_object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_creation_dummy_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_creation_dummy_object_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_creation_dummy_object_id();
  void set_allocated_actor_creation_dummy_object_id(std::string* actor_creation_dummy_object_id);
  private:
  const std::string& _internal_actor_creation_dummy_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_creation_dummy_object_id(const std::string& value);
  std::string* _internal_mutable_actor_creation_dummy_object_id();
  public:

  // bytes previous_actor_task_dummy_object_id = 7;
  void clear_previous_actor_task_dummy_object_id();
  const std::string& previous_actor_task_dummy_object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previous_actor_task_dummy_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previous_actor_task_dummy_object_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_previous_actor_task_dummy_object_id();
  void set_allocated_previous_actor_task_dummy_object_id(std::string* previous_actor_task_dummy_object_id);
  private:
  const std::string& _internal_previous_actor_task_dummy_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previous_actor_task_dummy_object_id(const std::string& value);
  std::string* _internal_mutable_previous_actor_task_dummy_object_id();
  public:

  // uint64 actor_counter = 5;
  void clear_actor_counter();
  ::PROTOBUF_NAMESPACE_ID::uint64 actor_counter() const;
  void set_actor_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_actor_counter() const;
  void _internal_set_actor_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ActorTaskSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_creation_dummy_object_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_actor_task_dummy_object_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 actor_counter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit constexpr Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const final {
    return new Task();
  }

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Task& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskSpecFieldNumber = 1,
  };
  // .mcs.rpc.TaskSpec task_spec = 1;
  bool has_task_spec() const;
  private:
  bool _internal_has_task_spec() const;
  public:
  void clear_task_spec();
  const ::mcs::rpc::TaskSpec& task_spec() const;
  PROTOBUF_MUST_USE_RESULT ::mcs::rpc::TaskSpec* release_task_spec();
  ::mcs::rpc::TaskSpec* mutable_task_spec();
  void set_allocated_task_spec(::mcs::rpc::TaskSpec* task_spec);
  private:
  const ::mcs::rpc::TaskSpec& _internal_task_spec() const;
  ::mcs::rpc::TaskSpec* _internal_mutable_task_spec();
  public:
  void unsafe_arena_set_allocated_task_spec(
      ::mcs::rpc::TaskSpec* task_spec);
  ::mcs::rpc::TaskSpec* unsafe_arena_release_task_spec();

  // @@protoc_insertion_point(class_scope:mcs.rpc.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mcs::rpc::TaskSpec* task_spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ResourceId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceId) */ {
 public:
  inline ResourceId() : ResourceId(nullptr) {}
  ~ResourceId() override;
  explicit constexpr ResourceId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceId(const ResourceId& from);
  ResourceId(ResourceId&& from) noexcept
    : ResourceId() {
    *this = ::std::move(from);
  }

  inline ResourceId& operator=(const ResourceId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceId& operator=(ResourceId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceId* internal_default_instance() {
    return reinterpret_cast<const ResourceId*>(
               &_ResourceId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ResourceId& a, ResourceId& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceId* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceId* New() const final {
    return new ResourceId();
  }

  ResourceId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceId";
  }
  protected:
  explicit ResourceId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // int64 index = 1;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int64 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double quantity = 2;
  void clear_quantity();
  double quantity() const;
  void set_quantity(double value);
  private:
  double _internal_quantity() const;
  void _internal_set_quantity(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_;
  double quantity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ResourceMapEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceMapEntry) */ {
 public:
  inline ResourceMapEntry() : ResourceMapEntry(nullptr) {}
  ~ResourceMapEntry() override;
  explicit constexpr ResourceMapEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceMapEntry(const ResourceMapEntry& from);
  ResourceMapEntry(ResourceMapEntry&& from) noexcept
    : ResourceMapEntry() {
    *this = ::std::move(from);
  }

  inline ResourceMapEntry& operator=(const ResourceMapEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceMapEntry& operator=(ResourceMapEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceMapEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceMapEntry* internal_default_instance() {
    return reinterpret_cast<const ResourceMapEntry*>(
               &_ResourceMapEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ResourceMapEntry& a, ResourceMapEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceMapEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceMapEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceMapEntry* New() const final {
    return new ResourceMapEntry();
  }

  ResourceMapEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceMapEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceMapEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceMapEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceMapEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceMapEntry";
  }
  protected:
  explicit ResourceMapEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceIdsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .mcs.rpc.ResourceId resource_ids = 2;
  int resource_ids_size() const;
  private:
  int _internal_resource_ids_size() const;
  public:
  void clear_resource_ids();
  ::mcs::rpc::ResourceId* mutable_resource_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceId >*
      mutable_resource_ids();
  private:
  const ::mcs::rpc::ResourceId& _internal_resource_ids(int index) const;
  ::mcs::rpc::ResourceId* _internal_add_resource_ids();
  public:
  const ::mcs::rpc::ResourceId& resource_ids(int index) const;
  ::mcs::rpc::ResourceId* add_resource_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceId >&
      resource_ids() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceMapEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceId > resource_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ViewData_Measure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ViewData.Measure) */ {
 public:
  inline ViewData_Measure() : ViewData_Measure(nullptr) {}
  ~ViewData_Measure() override;
  explicit constexpr ViewData_Measure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewData_Measure(const ViewData_Measure& from);
  ViewData_Measure(ViewData_Measure&& from) noexcept
    : ViewData_Measure() {
    *this = ::std::move(from);
  }

  inline ViewData_Measure& operator=(const ViewData_Measure& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewData_Measure& operator=(ViewData_Measure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViewData_Measure& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViewData_Measure* internal_default_instance() {
    return reinterpret_cast<const ViewData_Measure*>(
               &_ViewData_Measure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ViewData_Measure& a, ViewData_Measure& b) {
    a.Swap(&b);
  }
  inline void Swap(ViewData_Measure* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewData_Measure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ViewData_Measure* New() const final {
    return new ViewData_Measure();
  }

  ViewData_Measure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ViewData_Measure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViewData_Measure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ViewData_Measure& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViewData_Measure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ViewData.Measure";
  }
  protected:
  explicit ViewData_Measure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistributionBucketBoundariesFieldNumber = 8,
    kDistributionBucketCountsFieldNumber = 9,
    kTagsFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kDoubleValueFieldNumber = 3,
    kDistributionMinFieldNumber = 4,
    kDistributionMeanFieldNumber = 5,
    kDistributionMaxFieldNumber = 6,
    kDistributionCountFieldNumber = 7,
  };
  // repeated double distribution_bucket_boundaries = 8;
  int distribution_bucket_boundaries_size() const;
  private:
  int _internal_distribution_bucket_boundaries_size() const;
  public:
  void clear_distribution_bucket_boundaries();
  private:
  double _internal_distribution_bucket_boundaries(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_distribution_bucket_boundaries() const;
  void _internal_add_distribution_bucket_boundaries(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_distribution_bucket_boundaries();
  public:
  double distribution_bucket_boundaries(int index) const;
  void set_distribution_bucket_boundaries(int index, double value);
  void add_distribution_bucket_boundaries(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      distribution_bucket_boundaries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_distribution_bucket_boundaries();

  // repeated double distribution_bucket_counts = 9;
  int distribution_bucket_counts_size() const;
  private:
  int _internal_distribution_bucket_counts_size() const;
  public:
  void clear_distribution_bucket_counts();
  private:
  double _internal_distribution_bucket_counts(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_distribution_bucket_counts() const;
  void _internal_add_distribution_bucket_counts(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_distribution_bucket_counts();
  public:
  double distribution_bucket_counts(int index) const;
  void set_distribution_bucket_counts(int index, double value);
  void add_distribution_bucket_counts(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      distribution_bucket_counts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_distribution_bucket_counts();

  // string tags = 1;
  void clear_tags();
  const std::string& tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tags();
  PROTOBUF_MUST_USE_RESULT std::string* release_tags();
  void set_allocated_tags(std::string* tags);
  private:
  const std::string& _internal_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tags(const std::string& value);
  std::string* _internal_mutable_tags();
  public:

  // int64 int_value = 2;
  void clear_int_value();
  ::PROTOBUF_NAMESPACE_ID::int64 int_value() const;
  void set_int_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_int_value() const;
  void _internal_set_int_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double double_value = 3;
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // double distribution_min = 4;
  void clear_distribution_min();
  double distribution_min() const;
  void set_distribution_min(double value);
  private:
  double _internal_distribution_min() const;
  void _internal_set_distribution_min(double value);
  public:

  // double distribution_mean = 5;
  void clear_distribution_mean();
  double distribution_mean() const;
  void set_distribution_mean(double value);
  private:
  double _internal_distribution_mean() const;
  void _internal_set_distribution_mean(double value);
  public:

  // double distribution_max = 6;
  void clear_distribution_max();
  double distribution_max() const;
  void set_distribution_max(double value);
  private:
  double _internal_distribution_max() const;
  void _internal_set_distribution_max(double value);
  public:

  // double distribution_count = 7;
  void clear_distribution_count();
  double distribution_count() const;
  void set_distribution_count(double value);
  private:
  double _internal_distribution_count() const;
  void _internal_set_distribution_count(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ViewData.Measure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > distribution_bucket_boundaries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > distribution_bucket_counts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tags_;
  ::PROTOBUF_NAMESPACE_ID::int64 int_value_;
  double double_value_;
  double distribution_min_;
  double distribution_mean_;
  double distribution_max_;
  double distribution_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ViewData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ViewData) */ {
 public:
  inline ViewData() : ViewData(nullptr) {}
  ~ViewData() override;
  explicit constexpr ViewData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewData(const ViewData& from);
  ViewData(ViewData&& from) noexcept
    : ViewData() {
    *this = ::std::move(from);
  }

  inline ViewData& operator=(const ViewData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewData& operator=(ViewData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViewData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViewData* internal_default_instance() {
    return reinterpret_cast<const ViewData*>(
               &_ViewData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ViewData& a, ViewData& b) {
    a.Swap(&b);
  }
  inline void Swap(ViewData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ViewData* New() const final {
    return new ViewData();
  }

  ViewData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ViewData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViewData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ViewData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViewData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ViewData";
  }
  protected:
  explicit ViewData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ViewData_Measure Measure;

  // accessors -------------------------------------------------------

  enum : int {
    kMeasuresFieldNumber = 2,
    kViewNameFieldNumber = 1,
  };
  // repeated .mcs.rpc.ViewData.Measure measures = 2;
  int measures_size() const;
  private:
  int _internal_measures_size() const;
  public:
  void clear_measures();
  ::mcs::rpc::ViewData_Measure* mutable_measures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ViewData_Measure >*
      mutable_measures();
  private:
  const ::mcs::rpc::ViewData_Measure& _internal_measures(int index) const;
  ::mcs::rpc::ViewData_Measure* _internal_add_measures();
  public:
  const ::mcs::rpc::ViewData_Measure& measures(int index) const;
  ::mcs::rpc::ViewData_Measure* add_measures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ViewData_Measure >&
      measures() const;

  // string view_name = 1;
  void clear_view_name();
  const std::string& view_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_view_name();
  void set_allocated_view_name(std::string* view_name);
  private:
  const std::string& _internal_view_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_name(const std::string& value);
  std::string* _internal_mutable_view_name();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ViewData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ViewData_Measure > measures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ObjectRefInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ObjectRefInfo) */ {
 public:
  inline ObjectRefInfo() : ObjectRefInfo(nullptr) {}
  ~ObjectRefInfo() override;
  explicit constexpr ObjectRefInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectRefInfo(const ObjectRefInfo& from);
  ObjectRefInfo(ObjectRefInfo&& from) noexcept
    : ObjectRefInfo() {
    *this = ::std::move(from);
  }

  inline ObjectRefInfo& operator=(const ObjectRefInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectRefInfo& operator=(ObjectRefInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectRefInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectRefInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectRefInfo*>(
               &_ObjectRefInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ObjectRefInfo& a, ObjectRefInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectRefInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectRefInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectRefInfo* New() const final {
    return new ObjectRefInfo();
  }

  ObjectRefInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectRefInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectRefInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectRefInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectRefInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ObjectRefInfo";
  }
  protected:
  explicit ObjectRefInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainedInOwnedFieldNumber = 6,
    kObjectIdFieldNumber = 1,
    kCallSiteFieldNumber = 2,
    kObjectSizeFieldNumber = 3,
    kLocalRefCountFieldNumber = 4,
    kSubmittedTaskRefCountFieldNumber = 5,
    kPinnedInMemoryFieldNumber = 7,
    kTaskStatusFieldNumber = 8,
    kAttemptNumberFieldNumber = 9,
  };
  // repeated bytes contained_in_owned = 6;
  int contained_in_owned_size() const;
  private:
  int _internal_contained_in_owned_size() const;
  public:
  void clear_contained_in_owned();
  const std::string& contained_in_owned(int index) const;
  std::string* mutable_contained_in_owned(int index);
  void set_contained_in_owned(int index, const std::string& value);
  void set_contained_in_owned(int index, std::string&& value);
  void set_contained_in_owned(int index, const char* value);
  void set_contained_in_owned(int index, const void* value, size_t size);
  std::string* add_contained_in_owned();
  void add_contained_in_owned(const std::string& value);
  void add_contained_in_owned(std::string&& value);
  void add_contained_in_owned(const char* value);
  void add_contained_in_owned(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contained_in_owned() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contained_in_owned();
  private:
  const std::string& _internal_contained_in_owned(int index) const;
  std::string* _internal_add_contained_in_owned();
  public:

  // bytes object_id = 1;
  void clear_object_id();
  const std::string& object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_object_id();
  void set_allocated_object_id(std::string* object_id);
  private:
  const std::string& _internal_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const std::string& value);
  std::string* _internal_mutable_object_id();
  public:

  // string call_site = 2;
  void clear_call_site();
  const std::string& call_site() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_call_site(ArgT0&& arg0, ArgT... args);
  std::string* mutable_call_site();
  PROTOBUF_MUST_USE_RESULT std::string* release_call_site();
  void set_allocated_call_site(std::string* call_site);
  private:
  const std::string& _internal_call_site() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_call_site(const std::string& value);
  std::string* _internal_mutable_call_site();
  public:

  // int64 object_size = 3;
  void clear_object_size();
  ::PROTOBUF_NAMESPACE_ID::int64 object_size() const;
  void set_object_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_object_size() const;
  void _internal_set_object_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 local_ref_count = 4;
  void clear_local_ref_count();
  ::PROTOBUF_NAMESPACE_ID::int64 local_ref_count() const;
  void set_local_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_local_ref_count() const;
  void _internal_set_local_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 submitted_task_ref_count = 5;
  void clear_submitted_task_ref_count();
  ::PROTOBUF_NAMESPACE_ID::int64 submitted_task_ref_count() const;
  void set_submitted_task_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_submitted_task_ref_count() const;
  void _internal_set_submitted_task_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool pinned_in_memory = 7;
  void clear_pinned_in_memory();
  bool pinned_in_memory() const;
  void set_pinned_in_memory(bool value);
  private:
  bool _internal_pinned_in_memory() const;
  void _internal_set_pinned_in_memory(bool value);
  public:

  // .mcs.rpc.TaskStatus task_status = 8;
  void clear_task_status();
  ::mcs::rpc::TaskStatus task_status() const;
  void set_task_status(::mcs::rpc::TaskStatus value);
  private:
  ::mcs::rpc::TaskStatus _internal_task_status() const;
  void _internal_set_task_status(::mcs::rpc::TaskStatus value);
  public:

  // uint64 attempt_number = 9;
  void clear_attempt_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 attempt_number() const;
  void set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_attempt_number() const;
  void _internal_set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ObjectRefInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contained_in_owned_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr call_site_;
  ::PROTOBUF_NAMESPACE_ID::int64 object_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 local_ref_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 submitted_task_ref_count_;
  bool pinned_in_memory_;
  int task_status_;
  ::PROTOBUF_NAMESPACE_ID::uint64 attempt_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ResourceAllocations_ResourceSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceAllocations.ResourceSlot) */ {
 public:
  inline ResourceAllocations_ResourceSlot() : ResourceAllocations_ResourceSlot(nullptr) {}
  ~ResourceAllocations_ResourceSlot() override;
  explicit constexpr ResourceAllocations_ResourceSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceAllocations_ResourceSlot(const ResourceAllocations_ResourceSlot& from);
  ResourceAllocations_ResourceSlot(ResourceAllocations_ResourceSlot&& from) noexcept
    : ResourceAllocations_ResourceSlot() {
    *this = ::std::move(from);
  }

  inline ResourceAllocations_ResourceSlot& operator=(const ResourceAllocations_ResourceSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceAllocations_ResourceSlot& operator=(ResourceAllocations_ResourceSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceAllocations_ResourceSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceAllocations_ResourceSlot* internal_default_instance() {
    return reinterpret_cast<const ResourceAllocations_ResourceSlot*>(
               &_ResourceAllocations_ResourceSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ResourceAllocations_ResourceSlot& a, ResourceAllocations_ResourceSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceAllocations_ResourceSlot* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceAllocations_ResourceSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceAllocations_ResourceSlot* New() const final {
    return new ResourceAllocations_ResourceSlot();
  }

  ResourceAllocations_ResourceSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceAllocations_ResourceSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceAllocations_ResourceSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceAllocations_ResourceSlot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceAllocations_ResourceSlot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceAllocations.ResourceSlot";
  }
  protected:
  explicit ResourceAllocations_ResourceSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
    kAllocationFieldNumber = 2,
  };
  // int64 slot = 1;
  void clear_slot();
  ::PROTOBUF_NAMESPACE_ID::int64 slot() const;
  void set_slot(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_slot() const;
  void _internal_set_slot(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double allocation = 2;
  void clear_allocation();
  double allocation() const;
  void set_allocation(double value);
  private:
  double _internal_allocation() const;
  void _internal_set_allocation(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceAllocations.ResourceSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 slot_;
  double allocation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ResourceAllocations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.ResourceAllocations) */ {
 public:
  inline ResourceAllocations() : ResourceAllocations(nullptr) {}
  ~ResourceAllocations() override;
  explicit constexpr ResourceAllocations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceAllocations(const ResourceAllocations& from);
  ResourceAllocations(ResourceAllocations&& from) noexcept
    : ResourceAllocations() {
    *this = ::std::move(from);
  }

  inline ResourceAllocations& operator=(const ResourceAllocations& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceAllocations& operator=(ResourceAllocations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceAllocations& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceAllocations* internal_default_instance() {
    return reinterpret_cast<const ResourceAllocations*>(
               &_ResourceAllocations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ResourceAllocations& a, ResourceAllocations& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceAllocations* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceAllocations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceAllocations* New() const final {
    return new ResourceAllocations();
  }

  ResourceAllocations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceAllocations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceAllocations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceAllocations& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceAllocations* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.ResourceAllocations";
  }
  protected:
  explicit ResourceAllocations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResourceAllocations_ResourceSlot ResourceSlot;

  // accessors -------------------------------------------------------

  enum : int {
    kResourceSlotsFieldNumber = 1,
  };
  // repeated .mcs.rpc.ResourceAllocations.ResourceSlot resource_slots = 1;
  int resource_slots_size() const;
  private:
  int _internal_resource_slots_size() const;
  public:
  void clear_resource_slots();
  ::mcs::rpc::ResourceAllocations_ResourceSlot* mutable_resource_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceAllocations_ResourceSlot >*
      mutable_resource_slots();
  private:
  const ::mcs::rpc::ResourceAllocations_ResourceSlot& _internal_resource_slots(int index) const;
  ::mcs::rpc::ResourceAllocations_ResourceSlot* _internal_add_resource_slots();
  public:
  const ::mcs::rpc::ResourceAllocations_ResourceSlot& resource_slots(int index) const;
  ::mcs::rpc::ResourceAllocations_ResourceSlot* add_resource_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceAllocations_ResourceSlot >&
      resource_slots() const;

  // @@protoc_insertion_point(class_scope:mcs.rpc.ResourceAllocations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceAllocations_ResourceSlot > resource_slots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CoreWorkerStats_UsedResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CoreWorkerStats_UsedResourcesEntry_DoNotUse, 
    std::string, ::mcs::rpc::ResourceAllocations,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CoreWorkerStats_UsedResourcesEntry_DoNotUse, 
    std::string, ::mcs::rpc::ResourceAllocations,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CoreWorkerStats_UsedResourcesEntry_DoNotUse();
  explicit constexpr CoreWorkerStats_UsedResourcesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CoreWorkerStats_UsedResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CoreWorkerStats_UsedResourcesEntry_DoNotUse& other);
  static const CoreWorkerStats_UsedResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CoreWorkerStats_UsedResourcesEntry_DoNotUse*>(&_CoreWorkerStats_UsedResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.CoreWorkerStats.UsedResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CoreWorkerStats_WebuiDisplayEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CoreWorkerStats_WebuiDisplayEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CoreWorkerStats_WebuiDisplayEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CoreWorkerStats_WebuiDisplayEntry_DoNotUse();
  explicit constexpr CoreWorkerStats_WebuiDisplayEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CoreWorkerStats_WebuiDisplayEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CoreWorkerStats_WebuiDisplayEntry_DoNotUse& other);
  static const CoreWorkerStats_WebuiDisplayEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CoreWorkerStats_WebuiDisplayEntry_DoNotUse*>(&_CoreWorkerStats_WebuiDisplayEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.CoreWorkerStats.WebuiDisplayEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.CoreWorkerStats.WebuiDisplayEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CoreWorkerStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.CoreWorkerStats) */ {
 public:
  inline CoreWorkerStats() : CoreWorkerStats(nullptr) {}
  ~CoreWorkerStats() override;
  explicit constexpr CoreWorkerStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoreWorkerStats(const CoreWorkerStats& from);
  CoreWorkerStats(CoreWorkerStats&& from) noexcept
    : CoreWorkerStats() {
    *this = ::std::move(from);
  }

  inline CoreWorkerStats& operator=(const CoreWorkerStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoreWorkerStats& operator=(CoreWorkerStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoreWorkerStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoreWorkerStats* internal_default_instance() {
    return reinterpret_cast<const CoreWorkerStats*>(
               &_CoreWorkerStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CoreWorkerStats& a, CoreWorkerStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CoreWorkerStats* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoreWorkerStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoreWorkerStats* New() const final {
    return new CoreWorkerStats();
  }

  CoreWorkerStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoreWorkerStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoreWorkerStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoreWorkerStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoreWorkerStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.CoreWorkerStats";
  }
  protected:
  explicit CoreWorkerStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kUsedResourcesFieldNumber = 10,
    kWebuiDisplayFieldNumber = 11,
    kObjectRefsFieldNumber = 18,
    kCurrentTaskDescFieldNumber = 1,
    kIpAddressFieldNumber = 7,
    kActorIdFieldNumber = 9,
    kActorTitleFieldNumber = 17,
    kJobIdFieldNumber = 19,
    kWorkerIdFieldNumber = 20,
    kNumPendingTasksFieldNumber = 2,
    kNumObjectRefsInScopeFieldNumber = 3,
    kPortFieldNumber = 8,
    kNumInPlasmaFieldNumber = 12,
    kNumLocalObjectsFieldNumber = 13,
    kUsedObjectStoreMemoryFieldNumber = 14,
    kTaskQueueLengthFieldNumber = 15,
    kNumExecutedTasksFieldNumber = 16,
    kLanguageFieldNumber = 21,
    kPidFieldNumber = 22,
    kWorkerTypeFieldNumber = 23,
    kObjectsTotalFieldNumber = 24,
  };
  // map<string, .mcs.rpc.ResourceAllocations> used_resources = 10;
  int used_resources_size() const;
  private:
  int _internal_used_resources_size() const;
  public:
  void clear_used_resources();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >&
      _internal_used_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >*
      _internal_mutable_used_resources();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >&
      used_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >*
      mutable_used_resources();

  // map<string, string> webui_display = 11;
  int webui_display_size() const;
  private:
  int _internal_webui_display_size() const;
  public:
  void clear_webui_display();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_webui_display() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_webui_display();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      webui_display() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_webui_display();

  // repeated .mcs.rpc.ObjectRefInfo object_refs = 18;
  int object_refs_size() const;
  private:
  int _internal_object_refs_size() const;
  public:
  void clear_object_refs();
  ::mcs::rpc::ObjectRefInfo* mutable_object_refs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectRefInfo >*
      mutable_object_refs();
  private:
  const ::mcs::rpc::ObjectRefInfo& _internal_object_refs(int index) const;
  ::mcs::rpc::ObjectRefInfo* _internal_add_object_refs();
  public:
  const ::mcs::rpc::ObjectRefInfo& object_refs(int index) const;
  ::mcs::rpc::ObjectRefInfo* add_object_refs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectRefInfo >&
      object_refs() const;

  // string current_task_desc = 1;
  void clear_current_task_desc();
  const std::string& current_task_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_task_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_task_desc();
  PROTOBUF_MUST_USE_RESULT std::string* release_current_task_desc();
  void set_allocated_current_task_desc(std::string* current_task_desc);
  private:
  const std::string& _internal_current_task_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_task_desc(const std::string& value);
  std::string* _internal_mutable_current_task_desc();
  public:

  // string ip_address = 7;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // bytes actor_id = 9;
  void clear_actor_id();
  const std::string& actor_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // string actor_title = 17;
  void clear_actor_title();
  const std::string& actor_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actor_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actor_title();
  PROTOBUF_MUST_USE_RESULT std::string* release_actor_title();
  void set_allocated_actor_title(std::string* actor_title);
  private:
  const std::string& _internal_actor_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actor_title(const std::string& value);
  std::string* _internal_mutable_actor_title();
  public:

  // bytes job_id = 19;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // bytes worker_id = 20;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // int32 num_pending_tasks = 2;
  void clear_num_pending_tasks();
  ::PROTOBUF_NAMESPACE_ID::int32 num_pending_tasks() const;
  void set_num_pending_tasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_pending_tasks() const;
  void _internal_set_num_pending_tasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_object_refs_in_scope = 3;
  void clear_num_object_refs_in_scope();
  ::PROTOBUF_NAMESPACE_ID::int32 num_object_refs_in_scope() const;
  void set_num_object_refs_in_scope(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_object_refs_in_scope() const;
  void _internal_set_num_object_refs_in_scope(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 port = 8;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int64 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 num_in_plasma = 12;
  void clear_num_in_plasma();
  ::PROTOBUF_NAMESPACE_ID::int32 num_in_plasma() const;
  void set_num_in_plasma(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_in_plasma() const;
  void _internal_set_num_in_plasma(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_local_objects = 13;
  void clear_num_local_objects();
  ::PROTOBUF_NAMESPACE_ID::int32 num_local_objects() const;
  void set_num_local_objects(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_local_objects() const;
  void _internal_set_num_local_objects(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 used_object_store_memory = 14;
  void clear_used_object_store_memory();
  ::PROTOBUF_NAMESPACE_ID::int64 used_object_store_memory() const;
  void set_used_object_store_memory(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_object_store_memory() const;
  void _internal_set_used_object_store_memory(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 task_queue_length = 15;
  void clear_task_queue_length();
  ::PROTOBUF_NAMESPACE_ID::int32 task_queue_length() const;
  void set_task_queue_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_task_queue_length() const;
  void _internal_set_task_queue_length(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_executed_tasks = 16;
  void clear_num_executed_tasks();
  ::PROTOBUF_NAMESPACE_ID::int32 num_executed_tasks() const;
  void set_num_executed_tasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_executed_tasks() const;
  void _internal_set_num_executed_tasks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .mcs.rpc.Language language = 21;
  void clear_language();
  ::mcs::rpc::Language language() const;
  void set_language(::mcs::rpc::Language value);
  private:
  ::mcs::rpc::Language _internal_language() const;
  void _internal_set_language(::mcs::rpc::Language value);
  public:

  // uint32 pid = 22;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .mcs.rpc.WorkerType worker_type = 23;
  void clear_worker_type();
  ::mcs::rpc::WorkerType worker_type() const;
  void set_worker_type(::mcs::rpc::WorkerType value);
  private:
  ::mcs::rpc::WorkerType _internal_worker_type() const;
  void _internal_set_worker_type(::mcs::rpc::WorkerType value);
  public:

  // int64 objects_total = 24;
  void clear_objects_total();
  ::PROTOBUF_NAMESPACE_ID::int64 objects_total() const;
  void set_objects_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_objects_total() const;
  void _internal_set_objects_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.CoreWorkerStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CoreWorkerStats_UsedResourcesEntry_DoNotUse,
      std::string, ::mcs::rpc::ResourceAllocations,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> used_resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CoreWorkerStats_WebuiDisplayEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> webui_display_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectRefInfo > object_refs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_task_desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_pending_tasks_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_object_refs_in_scope_;
  ::PROTOBUF_NAMESPACE_ID::int64 port_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_in_plasma_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_local_objects_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_object_store_memory_;
  ::PROTOBUF_NAMESPACE_ID::int32 task_queue_length_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_executed_tasks_;
  int language_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  int worker_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 objects_total_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class MetricPoint_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetricPoint_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetricPoint_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MetricPoint_TagsEntry_DoNotUse();
  explicit constexpr MetricPoint_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MetricPoint_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MetricPoint_TagsEntry_DoNotUse& other);
  static const MetricPoint_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetricPoint_TagsEntry_DoNotUse*>(&_MetricPoint_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.MetricPoint.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "mcs.rpc.MetricPoint.TagsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class MetricPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.MetricPoint) */ {
 public:
  inline MetricPoint() : MetricPoint(nullptr) {}
  ~MetricPoint() override;
  explicit constexpr MetricPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricPoint(const MetricPoint& from);
  MetricPoint(MetricPoint&& from) noexcept
    : MetricPoint() {
    *this = ::std::move(from);
  }

  inline MetricPoint& operator=(const MetricPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricPoint& operator=(MetricPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricPoint* internal_default_instance() {
    return reinterpret_cast<const MetricPoint*>(
               &_MetricPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MetricPoint& a, MetricPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricPoint* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetricPoint* New() const final {
    return new MetricPoint();
  }

  MetricPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetricPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.MetricPoint";
  }
  protected:
  explicit MetricPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 4,
    kMetricNameFieldNumber = 1,
    kDescriptionFieldNumber = 5,
    kUnitsFieldNumber = 6,
    kTimestampFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // map<string, string> tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // string metric_name = 1;
  void clear_metric_name();
  const std::string& metric_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metric_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metric_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_metric_name();
  void set_allocated_metric_name(std::string* metric_name);
  private:
  const std::string& _internal_metric_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric_name(const std::string& value);
  std::string* _internal_mutable_metric_name();
  public:

  // string description = 5;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string units = 6;
  void clear_units();
  const std::string& units() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_units(ArgT0&& arg0, ArgT... args);
  std::string* mutable_units();
  PROTOBUF_MUST_USE_RESULT std::string* release_units();
  void set_allocated_units(std::string* units);
  private:
  const std::string& _internal_units() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_units(const std::string& value);
  std::string* _internal_mutable_units();
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double value = 3;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.MetricPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MetricPoint_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr units_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class NamedActorInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mcs.rpc.NamedActorInfo) */ {
 public:
  inline NamedActorInfo() : NamedActorInfo(nullptr) {}
  ~NamedActorInfo() override;
  explicit constexpr NamedActorInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedActorInfo(const NamedActorInfo& from);
  NamedActorInfo(NamedActorInfo&& from) noexcept
    : NamedActorInfo() {
    *this = ::std::move(from);
  }

  inline NamedActorInfo& operator=(const NamedActorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedActorInfo& operator=(NamedActorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedActorInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedActorInfo* internal_default_instance() {
    return reinterpret_cast<const NamedActorInfo*>(
               &_NamedActorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(NamedActorInfo& a, NamedActorInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedActorInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedActorInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NamedActorInfo* New() const final {
    return new NamedActorInfo();
  }

  NamedActorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamedActorInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedActorInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NamedActorInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedActorInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mcs.rpc.NamedActorInfo";
  }
  protected:
  explicit NamedActorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMcsNamespaceFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string mcs_namespace = 1;
  void clear_mcs_namespace();
  const std::string& mcs_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcs_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcs_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_mcs_namespace();
  void set_allocated_mcs_namespace(std::string* mcs_namespace);
  private:
  const std::string& _internal_mcs_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcs_namespace(const std::string& value);
  std::string* _internal_mutable_mcs_namespace();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mcs.rpc.NamedActorInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcs_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NodeAffinitySchedulingStrategy

// bytes node_id = 1;
inline void NodeAffinitySchedulingStrategy::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& NodeAffinitySchedulingStrategy::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NodeAffinitySchedulingStrategy.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAffinitySchedulingStrategy::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.NodeAffinitySchedulingStrategy.node_id)
}
inline std::string* NodeAffinitySchedulingStrategy::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.NodeAffinitySchedulingStrategy.node_id)
  return _s;
}
inline const std::string& NodeAffinitySchedulingStrategy::_internal_node_id() const {
  return node_id_.Get();
}
inline void NodeAffinitySchedulingStrategy::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeAffinitySchedulingStrategy::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeAffinitySchedulingStrategy::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.NodeAffinitySchedulingStrategy.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeAffinitySchedulingStrategy::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.NodeAffinitySchedulingStrategy.node_id)
}

// bool soft = 2;
inline void NodeAffinitySchedulingStrategy::clear_soft() {
  soft_ = false;
}
inline bool NodeAffinitySchedulingStrategy::_internal_soft() const {
  return soft_;
}
inline bool NodeAffinitySchedulingStrategy::soft() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NodeAffinitySchedulingStrategy.soft)
  return _internal_soft();
}
inline void NodeAffinitySchedulingStrategy::_internal_set_soft(bool value) {
  
  soft_ = value;
}
inline void NodeAffinitySchedulingStrategy::set_soft(bool value) {
  _internal_set_soft(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.NodeAffinitySchedulingStrategy.soft)
}

// -------------------------------------------------------------------

// PlacementGroupSchedulingStrategy

// bytes placement_group_id = 1;
inline void PlacementGroupSchedulingStrategy::clear_placement_group_id() {
  placement_group_id_.ClearToEmpty();
}
inline const std::string& PlacementGroupSchedulingStrategy::placement_group_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_id)
  return _internal_placement_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupSchedulingStrategy::set_placement_group_id(ArgT0&& arg0, ArgT... args) {
 
 placement_group_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_id)
}
inline std::string* PlacementGroupSchedulingStrategy::mutable_placement_group_id() {
  std::string* _s = _internal_mutable_placement_group_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_id)
  return _s;
}
inline const std::string& PlacementGroupSchedulingStrategy::_internal_placement_group_id() const {
  return placement_group_id_.Get();
}
inline void PlacementGroupSchedulingStrategy::_internal_set_placement_group_id(const std::string& value) {
  
  placement_group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupSchedulingStrategy::_internal_mutable_placement_group_id() {
  
  return placement_group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupSchedulingStrategy::release_placement_group_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_id)
  return placement_group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupSchedulingStrategy::set_allocated_placement_group_id(std::string* placement_group_id) {
  if (placement_group_id != nullptr) {
    
  } else {
    
  }
  placement_group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), placement_group_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_id)
}

// int64 placement_group_bundle_index = 2;
inline void PlacementGroupSchedulingStrategy::clear_placement_group_bundle_index() {
  placement_group_bundle_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupSchedulingStrategy::_internal_placement_group_bundle_index() const {
  return placement_group_bundle_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlacementGroupSchedulingStrategy::placement_group_bundle_index() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_bundle_index)
  return _internal_placement_group_bundle_index();
}
inline void PlacementGroupSchedulingStrategy::_internal_set_placement_group_bundle_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  placement_group_bundle_index_ = value;
}
inline void PlacementGroupSchedulingStrategy::set_placement_group_bundle_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_placement_group_bundle_index(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_bundle_index)
}

// bool placement_group_capture_child_tasks = 3;
inline void PlacementGroupSchedulingStrategy::clear_placement_group_capture_child_tasks() {
  placement_group_capture_child_tasks_ = false;
}
inline bool PlacementGroupSchedulingStrategy::_internal_placement_group_capture_child_tasks() const {
  return placement_group_capture_child_tasks_;
}
inline bool PlacementGroupSchedulingStrategy::placement_group_capture_child_tasks() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_capture_child_tasks)
  return _internal_placement_group_capture_child_tasks();
}
inline void PlacementGroupSchedulingStrategy::_internal_set_placement_group_capture_child_tasks(bool value) {
  
  placement_group_capture_child_tasks_ = value;
}
inline void PlacementGroupSchedulingStrategy::set_placement_group_capture_child_tasks(bool value) {
  _internal_set_placement_group_capture_child_tasks(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSchedulingStrategy.placement_group_capture_child_tasks)
}

// -------------------------------------------------------------------

// DefaultSchedulingStrategy

// -------------------------------------------------------------------

// SpreadSchedulingStrategy

// -------------------------------------------------------------------

// SchedulingStrategy

// .mcs.rpc.DefaultSchedulingStrategy default_scheduling_strategy = 1;
inline bool SchedulingStrategy::_internal_has_default_scheduling_strategy() const {
  return scheduling_strategy_case() == kDefaultSchedulingStrategy;
}
inline bool SchedulingStrategy::has_default_scheduling_strategy() const {
  return _internal_has_default_scheduling_strategy();
}
inline void SchedulingStrategy::set_has_default_scheduling_strategy() {
  _oneof_case_[0] = kDefaultSchedulingStrategy;
}
inline void SchedulingStrategy::clear_default_scheduling_strategy() {
  if (_internal_has_default_scheduling_strategy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete scheduling_strategy_.default_scheduling_strategy_;
    }
    clear_has_scheduling_strategy();
  }
}
inline ::mcs::rpc::DefaultSchedulingStrategy* SchedulingStrategy::release_default_scheduling_strategy() {
  // @@protoc_insertion_point(field_release:mcs.rpc.SchedulingStrategy.default_scheduling_strategy)
  if (_internal_has_default_scheduling_strategy()) {
    clear_has_scheduling_strategy();
      ::mcs::rpc::DefaultSchedulingStrategy* temp = scheduling_strategy_.default_scheduling_strategy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    scheduling_strategy_.default_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::DefaultSchedulingStrategy& SchedulingStrategy::_internal_default_scheduling_strategy() const {
  return _internal_has_default_scheduling_strategy()
      ? *scheduling_strategy_.default_scheduling_strategy_
      : reinterpret_cast< ::mcs::rpc::DefaultSchedulingStrategy&>(::mcs::rpc::_DefaultSchedulingStrategy_default_instance_);
}
inline const ::mcs::rpc::DefaultSchedulingStrategy& SchedulingStrategy::default_scheduling_strategy() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.SchedulingStrategy.default_scheduling_strategy)
  return _internal_default_scheduling_strategy();
}
inline ::mcs::rpc::DefaultSchedulingStrategy* SchedulingStrategy::unsafe_arena_release_default_scheduling_strategy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.SchedulingStrategy.default_scheduling_strategy)
  if (_internal_has_default_scheduling_strategy()) {
    clear_has_scheduling_strategy();
    ::mcs::rpc::DefaultSchedulingStrategy* temp = scheduling_strategy_.default_scheduling_strategy_;
    scheduling_strategy_.default_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulingStrategy::unsafe_arena_set_allocated_default_scheduling_strategy(::mcs::rpc::DefaultSchedulingStrategy* default_scheduling_strategy) {
  clear_scheduling_strategy();
  if (default_scheduling_strategy) {
    set_has_default_scheduling_strategy();
    scheduling_strategy_.default_scheduling_strategy_ = default_scheduling_strategy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.SchedulingStrategy.default_scheduling_strategy)
}
inline ::mcs::rpc::DefaultSchedulingStrategy* SchedulingStrategy::_internal_mutable_default_scheduling_strategy() {
  if (!_internal_has_default_scheduling_strategy()) {
    clear_scheduling_strategy();
    set_has_default_scheduling_strategy();
    scheduling_strategy_.default_scheduling_strategy_ = CreateMaybeMessage< ::mcs::rpc::DefaultSchedulingStrategy >(GetArenaForAllocation());
  }
  return scheduling_strategy_.default_scheduling_strategy_;
}
inline ::mcs::rpc::DefaultSchedulingStrategy* SchedulingStrategy::mutable_default_scheduling_strategy() {
  ::mcs::rpc::DefaultSchedulingStrategy* _msg = _internal_mutable_default_scheduling_strategy();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.SchedulingStrategy.default_scheduling_strategy)
  return _msg;
}

// .mcs.rpc.PlacementGroupSchedulingStrategy placement_group_scheduling_strategy = 2;
inline bool SchedulingStrategy::_internal_has_placement_group_scheduling_strategy() const {
  return scheduling_strategy_case() == kPlacementGroupSchedulingStrategy;
}
inline bool SchedulingStrategy::has_placement_group_scheduling_strategy() const {
  return _internal_has_placement_group_scheduling_strategy();
}
inline void SchedulingStrategy::set_has_placement_group_scheduling_strategy() {
  _oneof_case_[0] = kPlacementGroupSchedulingStrategy;
}
inline void SchedulingStrategy::clear_placement_group_scheduling_strategy() {
  if (_internal_has_placement_group_scheduling_strategy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete scheduling_strategy_.placement_group_scheduling_strategy_;
    }
    clear_has_scheduling_strategy();
  }
}
inline ::mcs::rpc::PlacementGroupSchedulingStrategy* SchedulingStrategy::release_placement_group_scheduling_strategy() {
  // @@protoc_insertion_point(field_release:mcs.rpc.SchedulingStrategy.placement_group_scheduling_strategy)
  if (_internal_has_placement_group_scheduling_strategy()) {
    clear_has_scheduling_strategy();
      ::mcs::rpc::PlacementGroupSchedulingStrategy* temp = scheduling_strategy_.placement_group_scheduling_strategy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    scheduling_strategy_.placement_group_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::PlacementGroupSchedulingStrategy& SchedulingStrategy::_internal_placement_group_scheduling_strategy() const {
  return _internal_has_placement_group_scheduling_strategy()
      ? *scheduling_strategy_.placement_group_scheduling_strategy_
      : reinterpret_cast< ::mcs::rpc::PlacementGroupSchedulingStrategy&>(::mcs::rpc::_PlacementGroupSchedulingStrategy_default_instance_);
}
inline const ::mcs::rpc::PlacementGroupSchedulingStrategy& SchedulingStrategy::placement_group_scheduling_strategy() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.SchedulingStrategy.placement_group_scheduling_strategy)
  return _internal_placement_group_scheduling_strategy();
}
inline ::mcs::rpc::PlacementGroupSchedulingStrategy* SchedulingStrategy::unsafe_arena_release_placement_group_scheduling_strategy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.SchedulingStrategy.placement_group_scheduling_strategy)
  if (_internal_has_placement_group_scheduling_strategy()) {
    clear_has_scheduling_strategy();
    ::mcs::rpc::PlacementGroupSchedulingStrategy* temp = scheduling_strategy_.placement_group_scheduling_strategy_;
    scheduling_strategy_.placement_group_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulingStrategy::unsafe_arena_set_allocated_placement_group_scheduling_strategy(::mcs::rpc::PlacementGroupSchedulingStrategy* placement_group_scheduling_strategy) {
  clear_scheduling_strategy();
  if (placement_group_scheduling_strategy) {
    set_has_placement_group_scheduling_strategy();
    scheduling_strategy_.placement_group_scheduling_strategy_ = placement_group_scheduling_strategy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.SchedulingStrategy.placement_group_scheduling_strategy)
}
inline ::mcs::rpc::PlacementGroupSchedulingStrategy* SchedulingStrategy::_internal_mutable_placement_group_scheduling_strategy() {
  if (!_internal_has_placement_group_scheduling_strategy()) {
    clear_scheduling_strategy();
    set_has_placement_group_scheduling_strategy();
    scheduling_strategy_.placement_group_scheduling_strategy_ = CreateMaybeMessage< ::mcs::rpc::PlacementGroupSchedulingStrategy >(GetArenaForAllocation());
  }
  return scheduling_strategy_.placement_group_scheduling_strategy_;
}
inline ::mcs::rpc::PlacementGroupSchedulingStrategy* SchedulingStrategy::mutable_placement_group_scheduling_strategy() {
  ::mcs::rpc::PlacementGroupSchedulingStrategy* _msg = _internal_mutable_placement_group_scheduling_strategy();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.SchedulingStrategy.placement_group_scheduling_strategy)
  return _msg;
}

// .mcs.rpc.SpreadSchedulingStrategy spread_scheduling_strategy = 3;
inline bool SchedulingStrategy::_internal_has_spread_scheduling_strategy() const {
  return scheduling_strategy_case() == kSpreadSchedulingStrategy;
}
inline bool SchedulingStrategy::has_spread_scheduling_strategy() const {
  return _internal_has_spread_scheduling_strategy();
}
inline void SchedulingStrategy::set_has_spread_scheduling_strategy() {
  _oneof_case_[0] = kSpreadSchedulingStrategy;
}
inline void SchedulingStrategy::clear_spread_scheduling_strategy() {
  if (_internal_has_spread_scheduling_strategy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete scheduling_strategy_.spread_scheduling_strategy_;
    }
    clear_has_scheduling_strategy();
  }
}
inline ::mcs::rpc::SpreadSchedulingStrategy* SchedulingStrategy::release_spread_scheduling_strategy() {
  // @@protoc_insertion_point(field_release:mcs.rpc.SchedulingStrategy.spread_scheduling_strategy)
  if (_internal_has_spread_scheduling_strategy()) {
    clear_has_scheduling_strategy();
      ::mcs::rpc::SpreadSchedulingStrategy* temp = scheduling_strategy_.spread_scheduling_strategy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    scheduling_strategy_.spread_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::SpreadSchedulingStrategy& SchedulingStrategy::_internal_spread_scheduling_strategy() const {
  return _internal_has_spread_scheduling_strategy()
      ? *scheduling_strategy_.spread_scheduling_strategy_
      : reinterpret_cast< ::mcs::rpc::SpreadSchedulingStrategy&>(::mcs::rpc::_SpreadSchedulingStrategy_default_instance_);
}
inline const ::mcs::rpc::SpreadSchedulingStrategy& SchedulingStrategy::spread_scheduling_strategy() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.SchedulingStrategy.spread_scheduling_strategy)
  return _internal_spread_scheduling_strategy();
}
inline ::mcs::rpc::SpreadSchedulingStrategy* SchedulingStrategy::unsafe_arena_release_spread_scheduling_strategy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.SchedulingStrategy.spread_scheduling_strategy)
  if (_internal_has_spread_scheduling_strategy()) {
    clear_has_scheduling_strategy();
    ::mcs::rpc::SpreadSchedulingStrategy* temp = scheduling_strategy_.spread_scheduling_strategy_;
    scheduling_strategy_.spread_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulingStrategy::unsafe_arena_set_allocated_spread_scheduling_strategy(::mcs::rpc::SpreadSchedulingStrategy* spread_scheduling_strategy) {
  clear_scheduling_strategy();
  if (spread_scheduling_strategy) {
    set_has_spread_scheduling_strategy();
    scheduling_strategy_.spread_scheduling_strategy_ = spread_scheduling_strategy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.SchedulingStrategy.spread_scheduling_strategy)
}
inline ::mcs::rpc::SpreadSchedulingStrategy* SchedulingStrategy::_internal_mutable_spread_scheduling_strategy() {
  if (!_internal_has_spread_scheduling_strategy()) {
    clear_scheduling_strategy();
    set_has_spread_scheduling_strategy();
    scheduling_strategy_.spread_scheduling_strategy_ = CreateMaybeMessage< ::mcs::rpc::SpreadSchedulingStrategy >(GetArenaForAllocation());
  }
  return scheduling_strategy_.spread_scheduling_strategy_;
}
inline ::mcs::rpc::SpreadSchedulingStrategy* SchedulingStrategy::mutable_spread_scheduling_strategy() {
  ::mcs::rpc::SpreadSchedulingStrategy* _msg = _internal_mutable_spread_scheduling_strategy();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.SchedulingStrategy.spread_scheduling_strategy)
  return _msg;
}

// .mcs.rpc.NodeAffinitySchedulingStrategy node_affinity_scheduling_strategy = 4;
inline bool SchedulingStrategy::_internal_has_node_affinity_scheduling_strategy() const {
  return scheduling_strategy_case() == kNodeAffinitySchedulingStrategy;
}
inline bool SchedulingStrategy::has_node_affinity_scheduling_strategy() const {
  return _internal_has_node_affinity_scheduling_strategy();
}
inline void SchedulingStrategy::set_has_node_affinity_scheduling_strategy() {
  _oneof_case_[0] = kNodeAffinitySchedulingStrategy;
}
inline void SchedulingStrategy::clear_node_affinity_scheduling_strategy() {
  if (_internal_has_node_affinity_scheduling_strategy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete scheduling_strategy_.node_affinity_scheduling_strategy_;
    }
    clear_has_scheduling_strategy();
  }
}
inline ::mcs::rpc::NodeAffinitySchedulingStrategy* SchedulingStrategy::release_node_affinity_scheduling_strategy() {
  // @@protoc_insertion_point(field_release:mcs.rpc.SchedulingStrategy.node_affinity_scheduling_strategy)
  if (_internal_has_node_affinity_scheduling_strategy()) {
    clear_has_scheduling_strategy();
      ::mcs::rpc::NodeAffinitySchedulingStrategy* temp = scheduling_strategy_.node_affinity_scheduling_strategy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    scheduling_strategy_.node_affinity_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::NodeAffinitySchedulingStrategy& SchedulingStrategy::_internal_node_affinity_scheduling_strategy() const {
  return _internal_has_node_affinity_scheduling_strategy()
      ? *scheduling_strategy_.node_affinity_scheduling_strategy_
      : reinterpret_cast< ::mcs::rpc::NodeAffinitySchedulingStrategy&>(::mcs::rpc::_NodeAffinitySchedulingStrategy_default_instance_);
}
inline const ::mcs::rpc::NodeAffinitySchedulingStrategy& SchedulingStrategy::node_affinity_scheduling_strategy() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.SchedulingStrategy.node_affinity_scheduling_strategy)
  return _internal_node_affinity_scheduling_strategy();
}
inline ::mcs::rpc::NodeAffinitySchedulingStrategy* SchedulingStrategy::unsafe_arena_release_node_affinity_scheduling_strategy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.SchedulingStrategy.node_affinity_scheduling_strategy)
  if (_internal_has_node_affinity_scheduling_strategy()) {
    clear_has_scheduling_strategy();
    ::mcs::rpc::NodeAffinitySchedulingStrategy* temp = scheduling_strategy_.node_affinity_scheduling_strategy_;
    scheduling_strategy_.node_affinity_scheduling_strategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SchedulingStrategy::unsafe_arena_set_allocated_node_affinity_scheduling_strategy(::mcs::rpc::NodeAffinitySchedulingStrategy* node_affinity_scheduling_strategy) {
  clear_scheduling_strategy();
  if (node_affinity_scheduling_strategy) {
    set_has_node_affinity_scheduling_strategy();
    scheduling_strategy_.node_affinity_scheduling_strategy_ = node_affinity_scheduling_strategy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.SchedulingStrategy.node_affinity_scheduling_strategy)
}
inline ::mcs::rpc::NodeAffinitySchedulingStrategy* SchedulingStrategy::_internal_mutable_node_affinity_scheduling_strategy() {
  if (!_internal_has_node_affinity_scheduling_strategy()) {
    clear_scheduling_strategy();
    set_has_node_affinity_scheduling_strategy();
    scheduling_strategy_.node_affinity_scheduling_strategy_ = CreateMaybeMessage< ::mcs::rpc::NodeAffinitySchedulingStrategy >(GetArenaForAllocation());
  }
  return scheduling_strategy_.node_affinity_scheduling_strategy_;
}
inline ::mcs::rpc::NodeAffinitySchedulingStrategy* SchedulingStrategy::mutable_node_affinity_scheduling_strategy() {
  ::mcs::rpc::NodeAffinitySchedulingStrategy* _msg = _internal_mutable_node_affinity_scheduling_strategy();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.SchedulingStrategy.node_affinity_scheduling_strategy)
  return _msg;
}

inline bool SchedulingStrategy::has_scheduling_strategy() const {
  return scheduling_strategy_case() != SCHEDULING_STRATEGY_NOT_SET;
}
inline void SchedulingStrategy::clear_has_scheduling_strategy() {
  _oneof_case_[0] = SCHEDULING_STRATEGY_NOT_SET;
}
inline SchedulingStrategy::SchedulingStrategyCase SchedulingStrategy::scheduling_strategy_case() const {
  return SchedulingStrategy::SchedulingStrategyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Address

// bytes mcslet_id = 1;
inline void Address::clear_mcslet_id() {
  mcslet_id_.ClearToEmpty();
}
inline const std::string& Address::mcslet_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Address.mcslet_id)
  return _internal_mcslet_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_mcslet_id(ArgT0&& arg0, ArgT... args) {
 
 mcslet_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.Address.mcslet_id)
}
inline std::string* Address::mutable_mcslet_id() {
  std::string* _s = _internal_mutable_mcslet_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.Address.mcslet_id)
  return _s;
}
inline const std::string& Address::_internal_mcslet_id() const {
  return mcslet_id_.Get();
}
inline void Address::_internal_set_mcslet_id(const std::string& value) {
  
  mcslet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_mcslet_id() {
  
  return mcslet_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Address::release_mcslet_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.Address.mcslet_id)
  return mcslet_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Address::set_allocated_mcslet_id(std::string* mcslet_id) {
  if (mcslet_id != nullptr) {
    
  } else {
    
  }
  mcslet_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcslet_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.Address.mcslet_id)
}

// string ip_address = 2;
inline void Address::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& Address::ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Address.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.Address.ip_address)
}
inline std::string* Address::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.Address.ip_address)
  return _s;
}
inline const std::string& Address::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void Address::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Address::release_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.Address.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Address::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.Address.ip_address)
}

// int32 port = 3;
inline void Address::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Address::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Address.port)
  return _internal_port();
}
inline void Address::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void Address::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.Address.port)
}

// bytes worker_id = 4;
inline void Address::clear_worker_id() {
  worker_id_.ClearToEmpty();
}
inline const std::string& Address::worker_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Address.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 worker_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.Address.worker_id)
}
inline std::string* Address::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.Address.worker_id)
  return _s;
}
inline const std::string& Address::_internal_worker_id() const {
  return worker_id_.Get();
}
inline void Address::_internal_set_worker_id(const std::string& value) {
  
  worker_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_worker_id() {
  
  return worker_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Address::release_worker_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.Address.worker_id)
  return worker_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Address::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  worker_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worker_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.Address.worker_id)
}

// -------------------------------------------------------------------

// JavaFunctionDescriptor

// string class_name = 1;
inline void JavaFunctionDescriptor::clear_class_name() {
  class_name_.ClearToEmpty();
}
inline const std::string& JavaFunctionDescriptor::class_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JavaFunctionDescriptor.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JavaFunctionDescriptor::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.JavaFunctionDescriptor.class_name)
}
inline std::string* JavaFunctionDescriptor::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JavaFunctionDescriptor.class_name)
  return _s;
}
inline const std::string& JavaFunctionDescriptor::_internal_class_name() const {
  return class_name_.Get();
}
inline void JavaFunctionDescriptor::_internal_set_class_name(const std::string& value) {
  
  class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JavaFunctionDescriptor::_internal_mutable_class_name() {
  
  return class_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JavaFunctionDescriptor::release_class_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JavaFunctionDescriptor.class_name)
  return class_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JavaFunctionDescriptor::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  class_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), class_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JavaFunctionDescriptor.class_name)
}

// string function_name = 2;
inline void JavaFunctionDescriptor::clear_function_name() {
  function_name_.ClearToEmpty();
}
inline const std::string& JavaFunctionDescriptor::function_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JavaFunctionDescriptor.function_name)
  return _internal_function_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JavaFunctionDescriptor::set_function_name(ArgT0&& arg0, ArgT... args) {
 
 function_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.JavaFunctionDescriptor.function_name)
}
inline std::string* JavaFunctionDescriptor::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JavaFunctionDescriptor.function_name)
  return _s;
}
inline const std::string& JavaFunctionDescriptor::_internal_function_name() const {
  return function_name_.Get();
}
inline void JavaFunctionDescriptor::_internal_set_function_name(const std::string& value) {
  
  function_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JavaFunctionDescriptor::_internal_mutable_function_name() {
  
  return function_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JavaFunctionDescriptor::release_function_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JavaFunctionDescriptor.function_name)
  return function_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JavaFunctionDescriptor::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JavaFunctionDescriptor.function_name)
}

// string signature = 3;
inline void JavaFunctionDescriptor::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& JavaFunctionDescriptor::signature() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.JavaFunctionDescriptor.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JavaFunctionDescriptor::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.JavaFunctionDescriptor.signature)
}
inline std::string* JavaFunctionDescriptor::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.JavaFunctionDescriptor.signature)
  return _s;
}
inline const std::string& JavaFunctionDescriptor::_internal_signature() const {
  return signature_.Get();
}
inline void JavaFunctionDescriptor::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JavaFunctionDescriptor::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JavaFunctionDescriptor::release_signature() {
  // @@protoc_insertion_point(field_release:mcs.rpc.JavaFunctionDescriptor.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JavaFunctionDescriptor::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.JavaFunctionDescriptor.signature)
}

// -------------------------------------------------------------------

// PythonFunctionDescriptor

// string module_name = 1;
inline void PythonFunctionDescriptor::clear_module_name() {
  module_name_.ClearToEmpty();
}
inline const std::string& PythonFunctionDescriptor::module_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PythonFunctionDescriptor.module_name)
  return _internal_module_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PythonFunctionDescriptor::set_module_name(ArgT0&& arg0, ArgT... args) {
 
 module_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PythonFunctionDescriptor.module_name)
}
inline std::string* PythonFunctionDescriptor::mutable_module_name() {
  std::string* _s = _internal_mutable_module_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PythonFunctionDescriptor.module_name)
  return _s;
}
inline const std::string& PythonFunctionDescriptor::_internal_module_name() const {
  return module_name_.Get();
}
inline void PythonFunctionDescriptor::_internal_set_module_name(const std::string& value) {
  
  module_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::_internal_mutable_module_name() {
  
  return module_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::release_module_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PythonFunctionDescriptor.module_name)
  return module_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PythonFunctionDescriptor::set_allocated_module_name(std::string* module_name) {
  if (module_name != nullptr) {
    
  } else {
    
  }
  module_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), module_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PythonFunctionDescriptor.module_name)
}

// string class_name = 2;
inline void PythonFunctionDescriptor::clear_class_name() {
  class_name_.ClearToEmpty();
}
inline const std::string& PythonFunctionDescriptor::class_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PythonFunctionDescriptor.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PythonFunctionDescriptor::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PythonFunctionDescriptor.class_name)
}
inline std::string* PythonFunctionDescriptor::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PythonFunctionDescriptor.class_name)
  return _s;
}
inline const std::string& PythonFunctionDescriptor::_internal_class_name() const {
  return class_name_.Get();
}
inline void PythonFunctionDescriptor::_internal_set_class_name(const std::string& value) {
  
  class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::_internal_mutable_class_name() {
  
  return class_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::release_class_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PythonFunctionDescriptor.class_name)
  return class_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PythonFunctionDescriptor::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  class_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), class_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PythonFunctionDescriptor.class_name)
}

// string function_name = 3;
inline void PythonFunctionDescriptor::clear_function_name() {
  function_name_.ClearToEmpty();
}
inline const std::string& PythonFunctionDescriptor::function_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PythonFunctionDescriptor.function_name)
  return _internal_function_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PythonFunctionDescriptor::set_function_name(ArgT0&& arg0, ArgT... args) {
 
 function_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PythonFunctionDescriptor.function_name)
}
inline std::string* PythonFunctionDescriptor::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PythonFunctionDescriptor.function_name)
  return _s;
}
inline const std::string& PythonFunctionDescriptor::_internal_function_name() const {
  return function_name_.Get();
}
inline void PythonFunctionDescriptor::_internal_set_function_name(const std::string& value) {
  
  function_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::_internal_mutable_function_name() {
  
  return function_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::release_function_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PythonFunctionDescriptor.function_name)
  return function_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PythonFunctionDescriptor::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PythonFunctionDescriptor.function_name)
}

// string function_hash = 4;
inline void PythonFunctionDescriptor::clear_function_hash() {
  function_hash_.ClearToEmpty();
}
inline const std::string& PythonFunctionDescriptor::function_hash() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PythonFunctionDescriptor.function_hash)
  return _internal_function_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PythonFunctionDescriptor::set_function_hash(ArgT0&& arg0, ArgT... args) {
 
 function_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PythonFunctionDescriptor.function_hash)
}
inline std::string* PythonFunctionDescriptor::mutable_function_hash() {
  std::string* _s = _internal_mutable_function_hash();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PythonFunctionDescriptor.function_hash)
  return _s;
}
inline const std::string& PythonFunctionDescriptor::_internal_function_hash() const {
  return function_hash_.Get();
}
inline void PythonFunctionDescriptor::_internal_set_function_hash(const std::string& value) {
  
  function_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::_internal_mutable_function_hash() {
  
  return function_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PythonFunctionDescriptor::release_function_hash() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PythonFunctionDescriptor.function_hash)
  return function_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PythonFunctionDescriptor::set_allocated_function_hash(std::string* function_hash) {
  if (function_hash != nullptr) {
    
  } else {
    
  }
  function_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PythonFunctionDescriptor.function_hash)
}

// -------------------------------------------------------------------

// CppFunctionDescriptor

// string function_name = 1;
inline void CppFunctionDescriptor::clear_function_name() {
  function_name_.ClearToEmpty();
}
inline const std::string& CppFunctionDescriptor::function_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CppFunctionDescriptor.function_name)
  return _internal_function_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CppFunctionDescriptor::set_function_name(ArgT0&& arg0, ArgT... args) {
 
 function_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CppFunctionDescriptor.function_name)
}
inline std::string* CppFunctionDescriptor::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CppFunctionDescriptor.function_name)
  return _s;
}
inline const std::string& CppFunctionDescriptor::_internal_function_name() const {
  return function_name_.Get();
}
inline void CppFunctionDescriptor::_internal_set_function_name(const std::string& value) {
  
  function_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CppFunctionDescriptor::_internal_mutable_function_name() {
  
  return function_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CppFunctionDescriptor::release_function_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CppFunctionDescriptor.function_name)
  return function_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CppFunctionDescriptor::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  function_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CppFunctionDescriptor.function_name)
}

// string caller = 2;
inline void CppFunctionDescriptor::clear_caller() {
  caller_.ClearToEmpty();
}
inline const std::string& CppFunctionDescriptor::caller() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CppFunctionDescriptor.caller)
  return _internal_caller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CppFunctionDescriptor::set_caller(ArgT0&& arg0, ArgT... args) {
 
 caller_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CppFunctionDescriptor.caller)
}
inline std::string* CppFunctionDescriptor::mutable_caller() {
  std::string* _s = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CppFunctionDescriptor.caller)
  return _s;
}
inline const std::string& CppFunctionDescriptor::_internal_caller() const {
  return caller_.Get();
}
inline void CppFunctionDescriptor::_internal_set_caller(const std::string& value) {
  
  caller_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CppFunctionDescriptor::_internal_mutable_caller() {
  
  return caller_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CppFunctionDescriptor::release_caller() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CppFunctionDescriptor.caller)
  return caller_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CppFunctionDescriptor::set_allocated_caller(std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  caller_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CppFunctionDescriptor.caller)
}

// string class_name = 3;
inline void CppFunctionDescriptor::clear_class_name() {
  class_name_.ClearToEmpty();
}
inline const std::string& CppFunctionDescriptor::class_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CppFunctionDescriptor.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CppFunctionDescriptor::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CppFunctionDescriptor.class_name)
}
inline std::string* CppFunctionDescriptor::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CppFunctionDescriptor.class_name)
  return _s;
}
inline const std::string& CppFunctionDescriptor::_internal_class_name() const {
  return class_name_.Get();
}
inline void CppFunctionDescriptor::_internal_set_class_name(const std::string& value) {
  
  class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CppFunctionDescriptor::_internal_mutable_class_name() {
  
  return class_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CppFunctionDescriptor::release_class_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CppFunctionDescriptor.class_name)
  return class_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CppFunctionDescriptor::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  class_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), class_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CppFunctionDescriptor.class_name)
}

// -------------------------------------------------------------------

// FunctionDescriptor

// .mcs.rpc.JavaFunctionDescriptor java_function_descriptor = 1;
inline bool FunctionDescriptor::_internal_has_java_function_descriptor() const {
  return function_descriptor_case() == kJavaFunctionDescriptor;
}
inline bool FunctionDescriptor::has_java_function_descriptor() const {
  return _internal_has_java_function_descriptor();
}
inline void FunctionDescriptor::set_has_java_function_descriptor() {
  _oneof_case_[0] = kJavaFunctionDescriptor;
}
inline void FunctionDescriptor::clear_java_function_descriptor() {
  if (_internal_has_java_function_descriptor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_descriptor_.java_function_descriptor_;
    }
    clear_has_function_descriptor();
  }
}
inline ::mcs::rpc::JavaFunctionDescriptor* FunctionDescriptor::release_java_function_descriptor() {
  // @@protoc_insertion_point(field_release:mcs.rpc.FunctionDescriptor.java_function_descriptor)
  if (_internal_has_java_function_descriptor()) {
    clear_has_function_descriptor();
      ::mcs::rpc::JavaFunctionDescriptor* temp = function_descriptor_.java_function_descriptor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_descriptor_.java_function_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::JavaFunctionDescriptor& FunctionDescriptor::_internal_java_function_descriptor() const {
  return _internal_has_java_function_descriptor()
      ? *function_descriptor_.java_function_descriptor_
      : reinterpret_cast< ::mcs::rpc::JavaFunctionDescriptor&>(::mcs::rpc::_JavaFunctionDescriptor_default_instance_);
}
inline const ::mcs::rpc::JavaFunctionDescriptor& FunctionDescriptor::java_function_descriptor() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.FunctionDescriptor.java_function_descriptor)
  return _internal_java_function_descriptor();
}
inline ::mcs::rpc::JavaFunctionDescriptor* FunctionDescriptor::unsafe_arena_release_java_function_descriptor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.FunctionDescriptor.java_function_descriptor)
  if (_internal_has_java_function_descriptor()) {
    clear_has_function_descriptor();
    ::mcs::rpc::JavaFunctionDescriptor* temp = function_descriptor_.java_function_descriptor_;
    function_descriptor_.java_function_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FunctionDescriptor::unsafe_arena_set_allocated_java_function_descriptor(::mcs::rpc::JavaFunctionDescriptor* java_function_descriptor) {
  clear_function_descriptor();
  if (java_function_descriptor) {
    set_has_java_function_descriptor();
    function_descriptor_.java_function_descriptor_ = java_function_descriptor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.FunctionDescriptor.java_function_descriptor)
}
inline ::mcs::rpc::JavaFunctionDescriptor* FunctionDescriptor::_internal_mutable_java_function_descriptor() {
  if (!_internal_has_java_function_descriptor()) {
    clear_function_descriptor();
    set_has_java_function_descriptor();
    function_descriptor_.java_function_descriptor_ = CreateMaybeMessage< ::mcs::rpc::JavaFunctionDescriptor >(GetArenaForAllocation());
  }
  return function_descriptor_.java_function_descriptor_;
}
inline ::mcs::rpc::JavaFunctionDescriptor* FunctionDescriptor::mutable_java_function_descriptor() {
  ::mcs::rpc::JavaFunctionDescriptor* _msg = _internal_mutable_java_function_descriptor();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.FunctionDescriptor.java_function_descriptor)
  return _msg;
}

// .mcs.rpc.PythonFunctionDescriptor python_function_descriptor = 2;
inline bool FunctionDescriptor::_internal_has_python_function_descriptor() const {
  return function_descriptor_case() == kPythonFunctionDescriptor;
}
inline bool FunctionDescriptor::has_python_function_descriptor() const {
  return _internal_has_python_function_descriptor();
}
inline void FunctionDescriptor::set_has_python_function_descriptor() {
  _oneof_case_[0] = kPythonFunctionDescriptor;
}
inline void FunctionDescriptor::clear_python_function_descriptor() {
  if (_internal_has_python_function_descriptor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_descriptor_.python_function_descriptor_;
    }
    clear_has_function_descriptor();
  }
}
inline ::mcs::rpc::PythonFunctionDescriptor* FunctionDescriptor::release_python_function_descriptor() {
  // @@protoc_insertion_point(field_release:mcs.rpc.FunctionDescriptor.python_function_descriptor)
  if (_internal_has_python_function_descriptor()) {
    clear_has_function_descriptor();
      ::mcs::rpc::PythonFunctionDescriptor* temp = function_descriptor_.python_function_descriptor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_descriptor_.python_function_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::PythonFunctionDescriptor& FunctionDescriptor::_internal_python_function_descriptor() const {
  return _internal_has_python_function_descriptor()
      ? *function_descriptor_.python_function_descriptor_
      : reinterpret_cast< ::mcs::rpc::PythonFunctionDescriptor&>(::mcs::rpc::_PythonFunctionDescriptor_default_instance_);
}
inline const ::mcs::rpc::PythonFunctionDescriptor& FunctionDescriptor::python_function_descriptor() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.FunctionDescriptor.python_function_descriptor)
  return _internal_python_function_descriptor();
}
inline ::mcs::rpc::PythonFunctionDescriptor* FunctionDescriptor::unsafe_arena_release_python_function_descriptor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.FunctionDescriptor.python_function_descriptor)
  if (_internal_has_python_function_descriptor()) {
    clear_has_function_descriptor();
    ::mcs::rpc::PythonFunctionDescriptor* temp = function_descriptor_.python_function_descriptor_;
    function_descriptor_.python_function_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FunctionDescriptor::unsafe_arena_set_allocated_python_function_descriptor(::mcs::rpc::PythonFunctionDescriptor* python_function_descriptor) {
  clear_function_descriptor();
  if (python_function_descriptor) {
    set_has_python_function_descriptor();
    function_descriptor_.python_function_descriptor_ = python_function_descriptor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.FunctionDescriptor.python_function_descriptor)
}
inline ::mcs::rpc::PythonFunctionDescriptor* FunctionDescriptor::_internal_mutable_python_function_descriptor() {
  if (!_internal_has_python_function_descriptor()) {
    clear_function_descriptor();
    set_has_python_function_descriptor();
    function_descriptor_.python_function_descriptor_ = CreateMaybeMessage< ::mcs::rpc::PythonFunctionDescriptor >(GetArenaForAllocation());
  }
  return function_descriptor_.python_function_descriptor_;
}
inline ::mcs::rpc::PythonFunctionDescriptor* FunctionDescriptor::mutable_python_function_descriptor() {
  ::mcs::rpc::PythonFunctionDescriptor* _msg = _internal_mutable_python_function_descriptor();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.FunctionDescriptor.python_function_descriptor)
  return _msg;
}

// .mcs.rpc.CppFunctionDescriptor cpp_function_descriptor = 3;
inline bool FunctionDescriptor::_internal_has_cpp_function_descriptor() const {
  return function_descriptor_case() == kCppFunctionDescriptor;
}
inline bool FunctionDescriptor::has_cpp_function_descriptor() const {
  return _internal_has_cpp_function_descriptor();
}
inline void FunctionDescriptor::set_has_cpp_function_descriptor() {
  _oneof_case_[0] = kCppFunctionDescriptor;
}
inline void FunctionDescriptor::clear_cpp_function_descriptor() {
  if (_internal_has_cpp_function_descriptor()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_descriptor_.cpp_function_descriptor_;
    }
    clear_has_function_descriptor();
  }
}
inline ::mcs::rpc::CppFunctionDescriptor* FunctionDescriptor::release_cpp_function_descriptor() {
  // @@protoc_insertion_point(field_release:mcs.rpc.FunctionDescriptor.cpp_function_descriptor)
  if (_internal_has_cpp_function_descriptor()) {
    clear_has_function_descriptor();
      ::mcs::rpc::CppFunctionDescriptor* temp = function_descriptor_.cpp_function_descriptor_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_descriptor_.cpp_function_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::CppFunctionDescriptor& FunctionDescriptor::_internal_cpp_function_descriptor() const {
  return _internal_has_cpp_function_descriptor()
      ? *function_descriptor_.cpp_function_descriptor_
      : reinterpret_cast< ::mcs::rpc::CppFunctionDescriptor&>(::mcs::rpc::_CppFunctionDescriptor_default_instance_);
}
inline const ::mcs::rpc::CppFunctionDescriptor& FunctionDescriptor::cpp_function_descriptor() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.FunctionDescriptor.cpp_function_descriptor)
  return _internal_cpp_function_descriptor();
}
inline ::mcs::rpc::CppFunctionDescriptor* FunctionDescriptor::unsafe_arena_release_cpp_function_descriptor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.FunctionDescriptor.cpp_function_descriptor)
  if (_internal_has_cpp_function_descriptor()) {
    clear_has_function_descriptor();
    ::mcs::rpc::CppFunctionDescriptor* temp = function_descriptor_.cpp_function_descriptor_;
    function_descriptor_.cpp_function_descriptor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FunctionDescriptor::unsafe_arena_set_allocated_cpp_function_descriptor(::mcs::rpc::CppFunctionDescriptor* cpp_function_descriptor) {
  clear_function_descriptor();
  if (cpp_function_descriptor) {
    set_has_cpp_function_descriptor();
    function_descriptor_.cpp_function_descriptor_ = cpp_function_descriptor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.FunctionDescriptor.cpp_function_descriptor)
}
inline ::mcs::rpc::CppFunctionDescriptor* FunctionDescriptor::_internal_mutable_cpp_function_descriptor() {
  if (!_internal_has_cpp_function_descriptor()) {
    clear_function_descriptor();
    set_has_cpp_function_descriptor();
    function_descriptor_.cpp_function_descriptor_ = CreateMaybeMessage< ::mcs::rpc::CppFunctionDescriptor >(GetArenaForAllocation());
  }
  return function_descriptor_.cpp_function_descriptor_;
}
inline ::mcs::rpc::CppFunctionDescriptor* FunctionDescriptor::mutable_cpp_function_descriptor() {
  ::mcs::rpc::CppFunctionDescriptor* _msg = _internal_mutable_cpp_function_descriptor();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.FunctionDescriptor.cpp_function_descriptor)
  return _msg;
}

inline bool FunctionDescriptor::has_function_descriptor() const {
  return function_descriptor_case() != FUNCTION_DESCRIPTOR_NOT_SET;
}
inline void FunctionDescriptor::clear_has_function_descriptor() {
  _oneof_case_[0] = FUNCTION_DESCRIPTOR_NOT_SET;
}
inline FunctionDescriptor::FunctionDescriptorCase FunctionDescriptor::function_descriptor_case() const {
  return FunctionDescriptor::FunctionDescriptorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConcurrencyGroup

// string name = 1;
inline void ConcurrencyGroup::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ConcurrencyGroup::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ConcurrencyGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConcurrencyGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ConcurrencyGroup.name)
}
inline std::string* ConcurrencyGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ConcurrencyGroup.name)
  return _s;
}
inline const std::string& ConcurrencyGroup::_internal_name() const {
  return name_.Get();
}
inline void ConcurrencyGroup::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConcurrencyGroup::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConcurrencyGroup::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ConcurrencyGroup.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConcurrencyGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ConcurrencyGroup.name)
}

// int32 max_concurrency = 2;
inline void ConcurrencyGroup::clear_max_concurrency() {
  max_concurrency_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConcurrencyGroup::_internal_max_concurrency() const {
  return max_concurrency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConcurrencyGroup::max_concurrency() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ConcurrencyGroup.max_concurrency)
  return _internal_max_concurrency();
}
inline void ConcurrencyGroup::_internal_set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_concurrency_ = value;
}
inline void ConcurrencyGroup::set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_concurrency(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ConcurrencyGroup.max_concurrency)
}

// repeated .mcs.rpc.FunctionDescriptor function_descriptors = 3;
inline int ConcurrencyGroup::_internal_function_descriptors_size() const {
  return function_descriptors_.size();
}
inline int ConcurrencyGroup::function_descriptors_size() const {
  return _internal_function_descriptors_size();
}
inline void ConcurrencyGroup::clear_function_descriptors() {
  function_descriptors_.Clear();
}
inline ::mcs::rpc::FunctionDescriptor* ConcurrencyGroup::mutable_function_descriptors(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ConcurrencyGroup.function_descriptors)
  return function_descriptors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::FunctionDescriptor >*
ConcurrencyGroup::mutable_function_descriptors() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ConcurrencyGroup.function_descriptors)
  return &function_descriptors_;
}
inline const ::mcs::rpc::FunctionDescriptor& ConcurrencyGroup::_internal_function_descriptors(int index) const {
  return function_descriptors_.Get(index);
}
inline const ::mcs::rpc::FunctionDescriptor& ConcurrencyGroup::function_descriptors(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ConcurrencyGroup.function_descriptors)
  return _internal_function_descriptors(index);
}
inline ::mcs::rpc::FunctionDescriptor* ConcurrencyGroup::_internal_add_function_descriptors() {
  return function_descriptors_.Add();
}
inline ::mcs::rpc::FunctionDescriptor* ConcurrencyGroup::add_function_descriptors() {
  ::mcs::rpc::FunctionDescriptor* _add = _internal_add_function_descriptors();
  // @@protoc_insertion_point(field_add:mcs.rpc.ConcurrencyGroup.function_descriptors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::FunctionDescriptor >&
ConcurrencyGroup::function_descriptors() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ConcurrencyGroup.function_descriptors)
  return function_descriptors_;
}

// -------------------------------------------------------------------

// McsErrorInfo

// .mcs.rpc.ActorDeathCause actor_died_error = 2;
inline bool McsErrorInfo::_internal_has_actor_died_error() const {
  return error_case() == kActorDiedError;
}
inline bool McsErrorInfo::has_actor_died_error() const {
  return _internal_has_actor_died_error();
}
inline void McsErrorInfo::set_has_actor_died_error() {
  _oneof_case_[0] = kActorDiedError;
}
inline void McsErrorInfo::clear_actor_died_error() {
  if (_internal_has_actor_died_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete error_.actor_died_error_;
    }
    clear_has_error();
  }
}
inline ::mcs::rpc::ActorDeathCause* McsErrorInfo::release_actor_died_error() {
  // @@protoc_insertion_point(field_release:mcs.rpc.McsErrorInfo.actor_died_error)
  if (_internal_has_actor_died_error()) {
    clear_has_error();
      ::mcs::rpc::ActorDeathCause* temp = error_.actor_died_error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    error_.actor_died_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::ActorDeathCause& McsErrorInfo::_internal_actor_died_error() const {
  return _internal_has_actor_died_error()
      ? *error_.actor_died_error_
      : reinterpret_cast< ::mcs::rpc::ActorDeathCause&>(::mcs::rpc::_ActorDeathCause_default_instance_);
}
inline const ::mcs::rpc::ActorDeathCause& McsErrorInfo::actor_died_error() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.McsErrorInfo.actor_died_error)
  return _internal_actor_died_error();
}
inline ::mcs::rpc::ActorDeathCause* McsErrorInfo::unsafe_arena_release_actor_died_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.McsErrorInfo.actor_died_error)
  if (_internal_has_actor_died_error()) {
    clear_has_error();
    ::mcs::rpc::ActorDeathCause* temp = error_.actor_died_error_;
    error_.actor_died_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void McsErrorInfo::unsafe_arena_set_allocated_actor_died_error(::mcs::rpc::ActorDeathCause* actor_died_error) {
  clear_error();
  if (actor_died_error) {
    set_has_actor_died_error();
    error_.actor_died_error_ = actor_died_error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.McsErrorInfo.actor_died_error)
}
inline ::mcs::rpc::ActorDeathCause* McsErrorInfo::_internal_mutable_actor_died_error() {
  if (!_internal_has_actor_died_error()) {
    clear_error();
    set_has_actor_died_error();
    error_.actor_died_error_ = CreateMaybeMessage< ::mcs::rpc::ActorDeathCause >(GetArenaForAllocation());
  }
  return error_.actor_died_error_;
}
inline ::mcs::rpc::ActorDeathCause* McsErrorInfo::mutable_actor_died_error() {
  ::mcs::rpc::ActorDeathCause* _msg = _internal_mutable_actor_died_error();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.McsErrorInfo.actor_died_error)
  return _msg;
}

// .mcs.rpc.RuntimeEnvFailedContext runtime_env_setup_failed_error = 3;
inline bool McsErrorInfo::_internal_has_runtime_env_setup_failed_error() const {
  return error_case() == kRuntimeEnvSetupFailedError;
}
inline bool McsErrorInfo::has_runtime_env_setup_failed_error() const {
  return _internal_has_runtime_env_setup_failed_error();
}
inline void McsErrorInfo::set_has_runtime_env_setup_failed_error() {
  _oneof_case_[0] = kRuntimeEnvSetupFailedError;
}
inline void McsErrorInfo::clear_runtime_env_setup_failed_error() {
  if (_internal_has_runtime_env_setup_failed_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete error_.runtime_env_setup_failed_error_;
    }
    clear_has_error();
  }
}
inline ::mcs::rpc::RuntimeEnvFailedContext* McsErrorInfo::release_runtime_env_setup_failed_error() {
  // @@protoc_insertion_point(field_release:mcs.rpc.McsErrorInfo.runtime_env_setup_failed_error)
  if (_internal_has_runtime_env_setup_failed_error()) {
    clear_has_error();
      ::mcs::rpc::RuntimeEnvFailedContext* temp = error_.runtime_env_setup_failed_error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    error_.runtime_env_setup_failed_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::RuntimeEnvFailedContext& McsErrorInfo::_internal_runtime_env_setup_failed_error() const {
  return _internal_has_runtime_env_setup_failed_error()
      ? *error_.runtime_env_setup_failed_error_
      : reinterpret_cast< ::mcs::rpc::RuntimeEnvFailedContext&>(::mcs::rpc::_RuntimeEnvFailedContext_default_instance_);
}
inline const ::mcs::rpc::RuntimeEnvFailedContext& McsErrorInfo::runtime_env_setup_failed_error() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.McsErrorInfo.runtime_env_setup_failed_error)
  return _internal_runtime_env_setup_failed_error();
}
inline ::mcs::rpc::RuntimeEnvFailedContext* McsErrorInfo::unsafe_arena_release_runtime_env_setup_failed_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.McsErrorInfo.runtime_env_setup_failed_error)
  if (_internal_has_runtime_env_setup_failed_error()) {
    clear_has_error();
    ::mcs::rpc::RuntimeEnvFailedContext* temp = error_.runtime_env_setup_failed_error_;
    error_.runtime_env_setup_failed_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void McsErrorInfo::unsafe_arena_set_allocated_runtime_env_setup_failed_error(::mcs::rpc::RuntimeEnvFailedContext* runtime_env_setup_failed_error) {
  clear_error();
  if (runtime_env_setup_failed_error) {
    set_has_runtime_env_setup_failed_error();
    error_.runtime_env_setup_failed_error_ = runtime_env_setup_failed_error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.McsErrorInfo.runtime_env_setup_failed_error)
}
inline ::mcs::rpc::RuntimeEnvFailedContext* McsErrorInfo::_internal_mutable_runtime_env_setup_failed_error() {
  if (!_internal_has_runtime_env_setup_failed_error()) {
    clear_error();
    set_has_runtime_env_setup_failed_error();
    error_.runtime_env_setup_failed_error_ = CreateMaybeMessage< ::mcs::rpc::RuntimeEnvFailedContext >(GetArenaForAllocation());
  }
  return error_.runtime_env_setup_failed_error_;
}
inline ::mcs::rpc::RuntimeEnvFailedContext* McsErrorInfo::mutable_runtime_env_setup_failed_error() {
  ::mcs::rpc::RuntimeEnvFailedContext* _msg = _internal_mutable_runtime_env_setup_failed_error();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.McsErrorInfo.runtime_env_setup_failed_error)
  return _msg;
}

// string error_message = 4;
inline bool McsErrorInfo::_internal_has_error_message() const {
  return error_case() == kErrorMessage;
}
inline bool McsErrorInfo::has_error_message() const {
  return _internal_has_error_message();
}
inline void McsErrorInfo::set_has_error_message() {
  _oneof_case_[0] = kErrorMessage;
}
inline void McsErrorInfo::clear_error_message() {
  if (_internal_has_error_message()) {
    error_.error_message_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_error();
  }
}
inline const std::string& McsErrorInfo::error_message() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.McsErrorInfo.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline void McsErrorInfo::set_error_message(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error_message()) {
    clear_error();
    set_has_error_message();
    error_.error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  error_.error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.McsErrorInfo.error_message)
}
inline std::string* McsErrorInfo::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.McsErrorInfo.error_message)
  return _s;
}
inline const std::string& McsErrorInfo::_internal_error_message() const {
  if (_internal_has_error_message()) {
    return error_.error_message_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void McsErrorInfo::_internal_set_error_message(const std::string& value) {
  if (!_internal_has_error_message()) {
    clear_error();
    set_has_error_message();
    error_.error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  error_.error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* McsErrorInfo::_internal_mutable_error_message() {
  if (!_internal_has_error_message()) {
    clear_error();
    set_has_error_message();
    error_.error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return error_.error_message_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* McsErrorInfo::release_error_message() {
  // @@protoc_insertion_point(field_release:mcs.rpc.McsErrorInfo.error_message)
  if (_internal_has_error_message()) {
    clear_has_error();
    return error_.error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void McsErrorInfo::set_allocated_error_message(std::string* error_message) {
  if (has_error()) {
    clear_error();
  }
  if (error_message != nullptr) {
    set_has_error_message();
    error_.error_message_.UnsafeSetDefault(error_message);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(error_message);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.McsErrorInfo.error_message)
}

// optional .mcs.rpc.ErrorType error_type = 11;
inline bool McsErrorInfo::_internal_has_error_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool McsErrorInfo::has_error_type() const {
  return _internal_has_error_type();
}
inline void McsErrorInfo::clear_error_type() {
  error_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::mcs::rpc::ErrorType McsErrorInfo::_internal_error_type() const {
  return static_cast< ::mcs::rpc::ErrorType >(error_type_);
}
inline ::mcs::rpc::ErrorType McsErrorInfo::error_type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.McsErrorInfo.error_type)
  return _internal_error_type();
}
inline void McsErrorInfo::_internal_set_error_type(::mcs::rpc::ErrorType value) {
  _has_bits_[0] |= 0x00000001u;
  error_type_ = value;
}
inline void McsErrorInfo::set_error_type(::mcs::rpc::ErrorType value) {
  _internal_set_error_type(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.McsErrorInfo.error_type)
}

inline bool McsErrorInfo::has_error() const {
  return error_case() != ERROR_NOT_SET;
}
inline void McsErrorInfo::clear_has_error() {
  _oneof_case_[0] = ERROR_NOT_SET;
}
inline McsErrorInfo::ErrorCase McsErrorInfo::error_case() const {
  return McsErrorInfo::ErrorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OutOfMemoryErrorContext

// bytes task_id = 1;
inline void OutOfMemoryErrorContext::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& OutOfMemoryErrorContext::task_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.OutOfMemoryErrorContext.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutOfMemoryErrorContext::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.OutOfMemoryErrorContext.task_id)
}
inline std::string* OutOfMemoryErrorContext::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.OutOfMemoryErrorContext.task_id)
  return _s;
}
inline const std::string& OutOfMemoryErrorContext::_internal_task_id() const {
  return task_id_.Get();
}
inline void OutOfMemoryErrorContext::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutOfMemoryErrorContext::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutOfMemoryErrorContext::release_task_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.OutOfMemoryErrorContext.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutOfMemoryErrorContext::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.OutOfMemoryErrorContext.task_id)
}

// string task_name = 2;
inline void OutOfMemoryErrorContext::clear_task_name() {
  task_name_.ClearToEmpty();
}
inline const std::string& OutOfMemoryErrorContext::task_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.OutOfMemoryErrorContext.task_name)
  return _internal_task_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutOfMemoryErrorContext::set_task_name(ArgT0&& arg0, ArgT... args) {
 
 task_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.OutOfMemoryErrorContext.task_name)
}
inline std::string* OutOfMemoryErrorContext::mutable_task_name() {
  std::string* _s = _internal_mutable_task_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.OutOfMemoryErrorContext.task_name)
  return _s;
}
inline const std::string& OutOfMemoryErrorContext::_internal_task_name() const {
  return task_name_.Get();
}
inline void OutOfMemoryErrorContext::_internal_set_task_name(const std::string& value) {
  
  task_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutOfMemoryErrorContext::_internal_mutable_task_name() {
  
  return task_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutOfMemoryErrorContext::release_task_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.OutOfMemoryErrorContext.task_name)
  return task_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutOfMemoryErrorContext::set_allocated_task_name(std::string* task_name) {
  if (task_name != nullptr) {
    
  } else {
    
  }
  task_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.OutOfMemoryErrorContext.task_name)
}

// string node_ip_address = 3;
inline void OutOfMemoryErrorContext::clear_node_ip_address() {
  node_ip_address_.ClearToEmpty();
}
inline const std::string& OutOfMemoryErrorContext::node_ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.OutOfMemoryErrorContext.node_ip_address)
  return _internal_node_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutOfMemoryErrorContext::set_node_ip_address(ArgT0&& arg0, ArgT... args) {
 
 node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.OutOfMemoryErrorContext.node_ip_address)
}
inline std::string* OutOfMemoryErrorContext::mutable_node_ip_address() {
  std::string* _s = _internal_mutable_node_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.OutOfMemoryErrorContext.node_ip_address)
  return _s;
}
inline const std::string& OutOfMemoryErrorContext::_internal_node_ip_address() const {
  return node_ip_address_.Get();
}
inline void OutOfMemoryErrorContext::_internal_set_node_ip_address(const std::string& value) {
  
  node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutOfMemoryErrorContext::_internal_mutable_node_ip_address() {
  
  return node_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutOfMemoryErrorContext::release_node_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.OutOfMemoryErrorContext.node_ip_address)
  return node_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutOfMemoryErrorContext::set_allocated_node_ip_address(std::string* node_ip_address) {
  if (node_ip_address != nullptr) {
    
  } else {
    
  }
  node_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.OutOfMemoryErrorContext.node_ip_address)
}

// uint64 memory_used_bytes = 4;
inline void OutOfMemoryErrorContext::clear_memory_used_bytes() {
  memory_used_bytes_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OutOfMemoryErrorContext::_internal_memory_used_bytes() const {
  return memory_used_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OutOfMemoryErrorContext::memory_used_bytes() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.OutOfMemoryErrorContext.memory_used_bytes)
  return _internal_memory_used_bytes();
}
inline void OutOfMemoryErrorContext::_internal_set_memory_used_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memory_used_bytes_ = value;
}
inline void OutOfMemoryErrorContext::set_memory_used_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memory_used_bytes(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.OutOfMemoryErrorContext.memory_used_bytes)
}

// uint64 memory_total_bytes = 5;
inline void OutOfMemoryErrorContext::clear_memory_total_bytes() {
  memory_total_bytes_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OutOfMemoryErrorContext::_internal_memory_total_bytes() const {
  return memory_total_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OutOfMemoryErrorContext::memory_total_bytes() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.OutOfMemoryErrorContext.memory_total_bytes)
  return _internal_memory_total_bytes();
}
inline void OutOfMemoryErrorContext::_internal_set_memory_total_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  memory_total_bytes_ = value;
}
inline void OutOfMemoryErrorContext::set_memory_total_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memory_total_bytes(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.OutOfMemoryErrorContext.memory_total_bytes)
}

// double memory_usage_fraction = 6;
inline void OutOfMemoryErrorContext::clear_memory_usage_fraction() {
  memory_usage_fraction_ = 0;
}
inline double OutOfMemoryErrorContext::_internal_memory_usage_fraction() const {
  return memory_usage_fraction_;
}
inline double OutOfMemoryErrorContext::memory_usage_fraction() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.OutOfMemoryErrorContext.memory_usage_fraction)
  return _internal_memory_usage_fraction();
}
inline void OutOfMemoryErrorContext::_internal_set_memory_usage_fraction(double value) {
  
  memory_usage_fraction_ = value;
}
inline void OutOfMemoryErrorContext::set_memory_usage_fraction(double value) {
  _internal_set_memory_usage_fraction(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.OutOfMemoryErrorContext.memory_usage_fraction)
}

// double memory_threshold = 7;
inline void OutOfMemoryErrorContext::clear_memory_threshold() {
  memory_threshold_ = 0;
}
inline double OutOfMemoryErrorContext::_internal_memory_threshold() const {
  return memory_threshold_;
}
inline double OutOfMemoryErrorContext::memory_threshold() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.OutOfMemoryErrorContext.memory_threshold)
  return _internal_memory_threshold();
}
inline void OutOfMemoryErrorContext::_internal_set_memory_threshold(double value) {
  
  memory_threshold_ = value;
}
inline void OutOfMemoryErrorContext::set_memory_threshold(double value) {
  _internal_set_memory_threshold(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.OutOfMemoryErrorContext.memory_threshold)
}

// -------------------------------------------------------------------

// NodeDiedErrorContext

// bytes node_id = 1;
inline void NodeDiedErrorContext::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& NodeDiedErrorContext::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NodeDiedErrorContext.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeDiedErrorContext::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.NodeDiedErrorContext.node_id)
}
inline std::string* NodeDiedErrorContext::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.NodeDiedErrorContext.node_id)
  return _s;
}
inline const std::string& NodeDiedErrorContext::_internal_node_id() const {
  return node_id_.Get();
}
inline void NodeDiedErrorContext::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeDiedErrorContext::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeDiedErrorContext::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.NodeDiedErrorContext.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeDiedErrorContext::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.NodeDiedErrorContext.node_id)
}

// string node_ip_address = 2;
inline void NodeDiedErrorContext::clear_node_ip_address() {
  node_ip_address_.ClearToEmpty();
}
inline const std::string& NodeDiedErrorContext::node_ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NodeDiedErrorContext.node_ip_address)
  return _internal_node_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeDiedErrorContext::set_node_ip_address(ArgT0&& arg0, ArgT... args) {
 
 node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.NodeDiedErrorContext.node_ip_address)
}
inline std::string* NodeDiedErrorContext::mutable_node_ip_address() {
  std::string* _s = _internal_mutable_node_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.NodeDiedErrorContext.node_ip_address)
  return _s;
}
inline const std::string& NodeDiedErrorContext::_internal_node_ip_address() const {
  return node_ip_address_.Get();
}
inline void NodeDiedErrorContext::_internal_set_node_ip_address(const std::string& value) {
  
  node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeDiedErrorContext::_internal_mutable_node_ip_address() {
  
  return node_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeDiedErrorContext::release_node_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.NodeDiedErrorContext.node_ip_address)
  return node_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeDiedErrorContext::set_allocated_node_ip_address(std::string* node_ip_address) {
  if (node_ip_address != nullptr) {
    
  } else {
    
  }
  node_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.NodeDiedErrorContext.node_ip_address)
}

// -------------------------------------------------------------------

// McsException

// .mcs.rpc.Language language = 1;
inline void McsException::clear_language() {
  language_ = 0;
}
inline ::mcs::rpc::Language McsException::_internal_language() const {
  return static_cast< ::mcs::rpc::Language >(language_);
}
inline ::mcs::rpc::Language McsException::language() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.McsException.language)
  return _internal_language();
}
inline void McsException::_internal_set_language(::mcs::rpc::Language value) {
  
  language_ = value;
}
inline void McsException::set_language(::mcs::rpc::Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.McsException.language)
}

// bytes serialized_exception = 2;
inline void McsException::clear_serialized_exception() {
  serialized_exception_.ClearToEmpty();
}
inline const std::string& McsException::serialized_exception() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.McsException.serialized_exception)
  return _internal_serialized_exception();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void McsException::set_serialized_exception(ArgT0&& arg0, ArgT... args) {
 
 serialized_exception_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.McsException.serialized_exception)
}
inline std::string* McsException::mutable_serialized_exception() {
  std::string* _s = _internal_mutable_serialized_exception();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.McsException.serialized_exception)
  return _s;
}
inline const std::string& McsException::_internal_serialized_exception() const {
  return serialized_exception_.Get();
}
inline void McsException::_internal_set_serialized_exception(const std::string& value) {
  
  serialized_exception_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* McsException::_internal_mutable_serialized_exception() {
  
  return serialized_exception_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* McsException::release_serialized_exception() {
  // @@protoc_insertion_point(field_release:mcs.rpc.McsException.serialized_exception)
  return serialized_exception_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void McsException::set_allocated_serialized_exception(std::string* serialized_exception) {
  if (serialized_exception != nullptr) {
    
  } else {
    
  }
  serialized_exception_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_exception,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.McsException.serialized_exception)
}

// string formatted_exception_string = 3;
inline void McsException::clear_formatted_exception_string() {
  formatted_exception_string_.ClearToEmpty();
}
inline const std::string& McsException::formatted_exception_string() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.McsException.formatted_exception_string)
  return _internal_formatted_exception_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void McsException::set_formatted_exception_string(ArgT0&& arg0, ArgT... args) {
 
 formatted_exception_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.McsException.formatted_exception_string)
}
inline std::string* McsException::mutable_formatted_exception_string() {
  std::string* _s = _internal_mutable_formatted_exception_string();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.McsException.formatted_exception_string)
  return _s;
}
inline const std::string& McsException::_internal_formatted_exception_string() const {
  return formatted_exception_string_.Get();
}
inline void McsException::_internal_set_formatted_exception_string(const std::string& value) {
  
  formatted_exception_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* McsException::_internal_mutable_formatted_exception_string() {
  
  return formatted_exception_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* McsException::release_formatted_exception_string() {
  // @@protoc_insertion_point(field_release:mcs.rpc.McsException.formatted_exception_string)
  return formatted_exception_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void McsException::set_allocated_formatted_exception_string(std::string* formatted_exception_string) {
  if (formatted_exception_string != nullptr) {
    
  } else {
    
  }
  formatted_exception_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), formatted_exception_string,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.McsException.formatted_exception_string)
}

// -------------------------------------------------------------------

// ActorDeathCause

// .mcs.rpc.McsException creation_task_failure_context = 1;
inline bool ActorDeathCause::_internal_has_creation_task_failure_context() const {
  return context_case() == kCreationTaskFailureContext;
}
inline bool ActorDeathCause::has_creation_task_failure_context() const {
  return _internal_has_creation_task_failure_context();
}
inline void ActorDeathCause::set_has_creation_task_failure_context() {
  _oneof_case_[0] = kCreationTaskFailureContext;
}
inline void ActorDeathCause::clear_creation_task_failure_context() {
  if (_internal_has_creation_task_failure_context()) {
    if (GetArenaForAllocation() == nullptr) {
      delete context_.creation_task_failure_context_;
    }
    clear_has_context();
  }
}
inline ::mcs::rpc::McsException* ActorDeathCause::release_creation_task_failure_context() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDeathCause.creation_task_failure_context)
  if (_internal_has_creation_task_failure_context()) {
    clear_has_context();
      ::mcs::rpc::McsException* temp = context_.creation_task_failure_context_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    context_.creation_task_failure_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::McsException& ActorDeathCause::_internal_creation_task_failure_context() const {
  return _internal_has_creation_task_failure_context()
      ? *context_.creation_task_failure_context_
      : reinterpret_cast< ::mcs::rpc::McsException&>(::mcs::rpc::_McsException_default_instance_);
}
inline const ::mcs::rpc::McsException& ActorDeathCause::creation_task_failure_context() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDeathCause.creation_task_failure_context)
  return _internal_creation_task_failure_context();
}
inline ::mcs::rpc::McsException* ActorDeathCause::unsafe_arena_release_creation_task_failure_context() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.ActorDeathCause.creation_task_failure_context)
  if (_internal_has_creation_task_failure_context()) {
    clear_has_context();
    ::mcs::rpc::McsException* temp = context_.creation_task_failure_context_;
    context_.creation_task_failure_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActorDeathCause::unsafe_arena_set_allocated_creation_task_failure_context(::mcs::rpc::McsException* creation_task_failure_context) {
  clear_context();
  if (creation_task_failure_context) {
    set_has_creation_task_failure_context();
    context_.creation_task_failure_context_ = creation_task_failure_context;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorDeathCause.creation_task_failure_context)
}
inline ::mcs::rpc::McsException* ActorDeathCause::_internal_mutable_creation_task_failure_context() {
  if (!_internal_has_creation_task_failure_context()) {
    clear_context();
    set_has_creation_task_failure_context();
    context_.creation_task_failure_context_ = CreateMaybeMessage< ::mcs::rpc::McsException >(GetArenaForAllocation());
  }
  return context_.creation_task_failure_context_;
}
inline ::mcs::rpc::McsException* ActorDeathCause::mutable_creation_task_failure_context() {
  ::mcs::rpc::McsException* _msg = _internal_mutable_creation_task_failure_context();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDeathCause.creation_task_failure_context)
  return _msg;
}

// .mcs.rpc.RuntimeEnvFailedContext runtime_env_failed_context = 2;
inline bool ActorDeathCause::_internal_has_runtime_env_failed_context() const {
  return context_case() == kRuntimeEnvFailedContext;
}
inline bool ActorDeathCause::has_runtime_env_failed_context() const {
  return _internal_has_runtime_env_failed_context();
}
inline void ActorDeathCause::set_has_runtime_env_failed_context() {
  _oneof_case_[0] = kRuntimeEnvFailedContext;
}
inline void ActorDeathCause::clear_runtime_env_failed_context() {
  if (_internal_has_runtime_env_failed_context()) {
    if (GetArenaForAllocation() == nullptr) {
      delete context_.runtime_env_failed_context_;
    }
    clear_has_context();
  }
}
inline ::mcs::rpc::RuntimeEnvFailedContext* ActorDeathCause::release_runtime_env_failed_context() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDeathCause.runtime_env_failed_context)
  if (_internal_has_runtime_env_failed_context()) {
    clear_has_context();
      ::mcs::rpc::RuntimeEnvFailedContext* temp = context_.runtime_env_failed_context_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    context_.runtime_env_failed_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::RuntimeEnvFailedContext& ActorDeathCause::_internal_runtime_env_failed_context() const {
  return _internal_has_runtime_env_failed_context()
      ? *context_.runtime_env_failed_context_
      : reinterpret_cast< ::mcs::rpc::RuntimeEnvFailedContext&>(::mcs::rpc::_RuntimeEnvFailedContext_default_instance_);
}
inline const ::mcs::rpc::RuntimeEnvFailedContext& ActorDeathCause::runtime_env_failed_context() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDeathCause.runtime_env_failed_context)
  return _internal_runtime_env_failed_context();
}
inline ::mcs::rpc::RuntimeEnvFailedContext* ActorDeathCause::unsafe_arena_release_runtime_env_failed_context() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.ActorDeathCause.runtime_env_failed_context)
  if (_internal_has_runtime_env_failed_context()) {
    clear_has_context();
    ::mcs::rpc::RuntimeEnvFailedContext* temp = context_.runtime_env_failed_context_;
    context_.runtime_env_failed_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActorDeathCause::unsafe_arena_set_allocated_runtime_env_failed_context(::mcs::rpc::RuntimeEnvFailedContext* runtime_env_failed_context) {
  clear_context();
  if (runtime_env_failed_context) {
    set_has_runtime_env_failed_context();
    context_.runtime_env_failed_context_ = runtime_env_failed_context;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorDeathCause.runtime_env_failed_context)
}
inline ::mcs::rpc::RuntimeEnvFailedContext* ActorDeathCause::_internal_mutable_runtime_env_failed_context() {
  if (!_internal_has_runtime_env_failed_context()) {
    clear_context();
    set_has_runtime_env_failed_context();
    context_.runtime_env_failed_context_ = CreateMaybeMessage< ::mcs::rpc::RuntimeEnvFailedContext >(GetArenaForAllocation());
  }
  return context_.runtime_env_failed_context_;
}
inline ::mcs::rpc::RuntimeEnvFailedContext* ActorDeathCause::mutable_runtime_env_failed_context() {
  ::mcs::rpc::RuntimeEnvFailedContext* _msg = _internal_mutable_runtime_env_failed_context();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDeathCause.runtime_env_failed_context)
  return _msg;
}

// .mcs.rpc.ActorDiedErrorContext actor_died_error_context = 3;
inline bool ActorDeathCause::_internal_has_actor_died_error_context() const {
  return context_case() == kActorDiedErrorContext;
}
inline bool ActorDeathCause::has_actor_died_error_context() const {
  return _internal_has_actor_died_error_context();
}
inline void ActorDeathCause::set_has_actor_died_error_context() {
  _oneof_case_[0] = kActorDiedErrorContext;
}
inline void ActorDeathCause::clear_actor_died_error_context() {
  if (_internal_has_actor_died_error_context()) {
    if (GetArenaForAllocation() == nullptr) {
      delete context_.actor_died_error_context_;
    }
    clear_has_context();
  }
}
inline ::mcs::rpc::ActorDiedErrorContext* ActorDeathCause::release_actor_died_error_context() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDeathCause.actor_died_error_context)
  if (_internal_has_actor_died_error_context()) {
    clear_has_context();
      ::mcs::rpc::ActorDiedErrorContext* temp = context_.actor_died_error_context_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    context_.actor_died_error_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::ActorDiedErrorContext& ActorDeathCause::_internal_actor_died_error_context() const {
  return _internal_has_actor_died_error_context()
      ? *context_.actor_died_error_context_
      : reinterpret_cast< ::mcs::rpc::ActorDiedErrorContext&>(::mcs::rpc::_ActorDiedErrorContext_default_instance_);
}
inline const ::mcs::rpc::ActorDiedErrorContext& ActorDeathCause::actor_died_error_context() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDeathCause.actor_died_error_context)
  return _internal_actor_died_error_context();
}
inline ::mcs::rpc::ActorDiedErrorContext* ActorDeathCause::unsafe_arena_release_actor_died_error_context() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.ActorDeathCause.actor_died_error_context)
  if (_internal_has_actor_died_error_context()) {
    clear_has_context();
    ::mcs::rpc::ActorDiedErrorContext* temp = context_.actor_died_error_context_;
    context_.actor_died_error_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActorDeathCause::unsafe_arena_set_allocated_actor_died_error_context(::mcs::rpc::ActorDiedErrorContext* actor_died_error_context) {
  clear_context();
  if (actor_died_error_context) {
    set_has_actor_died_error_context();
    context_.actor_died_error_context_ = actor_died_error_context;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorDeathCause.actor_died_error_context)
}
inline ::mcs::rpc::ActorDiedErrorContext* ActorDeathCause::_internal_mutable_actor_died_error_context() {
  if (!_internal_has_actor_died_error_context()) {
    clear_context();
    set_has_actor_died_error_context();
    context_.actor_died_error_context_ = CreateMaybeMessage< ::mcs::rpc::ActorDiedErrorContext >(GetArenaForAllocation());
  }
  return context_.actor_died_error_context_;
}
inline ::mcs::rpc::ActorDiedErrorContext* ActorDeathCause::mutable_actor_died_error_context() {
  ::mcs::rpc::ActorDiedErrorContext* _msg = _internal_mutable_actor_died_error_context();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDeathCause.actor_died_error_context)
  return _msg;
}

// .mcs.rpc.ActorUnschedulableContext actor_unschedulable_context = 4;
inline bool ActorDeathCause::_internal_has_actor_unschedulable_context() const {
  return context_case() == kActorUnschedulableContext;
}
inline bool ActorDeathCause::has_actor_unschedulable_context() const {
  return _internal_has_actor_unschedulable_context();
}
inline void ActorDeathCause::set_has_actor_unschedulable_context() {
  _oneof_case_[0] = kActorUnschedulableContext;
}
inline void ActorDeathCause::clear_actor_unschedulable_context() {
  if (_internal_has_actor_unschedulable_context()) {
    if (GetArenaForAllocation() == nullptr) {
      delete context_.actor_unschedulable_context_;
    }
    clear_has_context();
  }
}
inline ::mcs::rpc::ActorUnschedulableContext* ActorDeathCause::release_actor_unschedulable_context() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDeathCause.actor_unschedulable_context)
  if (_internal_has_actor_unschedulable_context()) {
    clear_has_context();
      ::mcs::rpc::ActorUnschedulableContext* temp = context_.actor_unschedulable_context_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    context_.actor_unschedulable_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mcs::rpc::ActorUnschedulableContext& ActorDeathCause::_internal_actor_unschedulable_context() const {
  return _internal_has_actor_unschedulable_context()
      ? *context_.actor_unschedulable_context_
      : reinterpret_cast< ::mcs::rpc::ActorUnschedulableContext&>(::mcs::rpc::_ActorUnschedulableContext_default_instance_);
}
inline const ::mcs::rpc::ActorUnschedulableContext& ActorDeathCause::actor_unschedulable_context() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDeathCause.actor_unschedulable_context)
  return _internal_actor_unschedulable_context();
}
inline ::mcs::rpc::ActorUnschedulableContext* ActorDeathCause::unsafe_arena_release_actor_unschedulable_context() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mcs.rpc.ActorDeathCause.actor_unschedulable_context)
  if (_internal_has_actor_unschedulable_context()) {
    clear_has_context();
    ::mcs::rpc::ActorUnschedulableContext* temp = context_.actor_unschedulable_context_;
    context_.actor_unschedulable_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActorDeathCause::unsafe_arena_set_allocated_actor_unschedulable_context(::mcs::rpc::ActorUnschedulableContext* actor_unschedulable_context) {
  clear_context();
  if (actor_unschedulable_context) {
    set_has_actor_unschedulable_context();
    context_.actor_unschedulable_context_ = actor_unschedulable_context;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ActorDeathCause.actor_unschedulable_context)
}
inline ::mcs::rpc::ActorUnschedulableContext* ActorDeathCause::_internal_mutable_actor_unschedulable_context() {
  if (!_internal_has_actor_unschedulable_context()) {
    clear_context();
    set_has_actor_unschedulable_context();
    context_.actor_unschedulable_context_ = CreateMaybeMessage< ::mcs::rpc::ActorUnschedulableContext >(GetArenaForAllocation());
  }
  return context_.actor_unschedulable_context_;
}
inline ::mcs::rpc::ActorUnschedulableContext* ActorDeathCause::mutable_actor_unschedulable_context() {
  ::mcs::rpc::ActorUnschedulableContext* _msg = _internal_mutable_actor_unschedulable_context();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDeathCause.actor_unschedulable_context)
  return _msg;
}

inline bool ActorDeathCause::has_context() const {
  return context_case() != CONTEXT_NOT_SET;
}
inline void ActorDeathCause::clear_has_context() {
  _oneof_case_[0] = CONTEXT_NOT_SET;
}
inline ActorDeathCause::ContextCase ActorDeathCause::context_case() const {
  return ActorDeathCause::ContextCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RuntimeEnvFailedContext

// string error_message = 1;
inline void RuntimeEnvFailedContext::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& RuntimeEnvFailedContext::error_message() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.RuntimeEnvFailedContext.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RuntimeEnvFailedContext::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.RuntimeEnvFailedContext.error_message)
}
inline std::string* RuntimeEnvFailedContext::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.RuntimeEnvFailedContext.error_message)
  return _s;
}
inline const std::string& RuntimeEnvFailedContext::_internal_error_message() const {
  return error_message_.Get();
}
inline void RuntimeEnvFailedContext::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RuntimeEnvFailedContext::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RuntimeEnvFailedContext::release_error_message() {
  // @@protoc_insertion_point(field_release:mcs.rpc.RuntimeEnvFailedContext.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RuntimeEnvFailedContext::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.RuntimeEnvFailedContext.error_message)
}

// -------------------------------------------------------------------

// ActorUnschedulableContext

// string error_message = 1;
inline void ActorUnschedulableContext::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& ActorUnschedulableContext::error_message() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorUnschedulableContext.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorUnschedulableContext::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorUnschedulableContext.error_message)
}
inline std::string* ActorUnschedulableContext::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorUnschedulableContext.error_message)
  return _s;
}
inline const std::string& ActorUnschedulableContext::_internal_error_message() const {
  return error_message_.Get();
}
inline void ActorUnschedulableContext::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorUnschedulableContext::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorUnschedulableContext::release_error_message() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorUnschedulableContext.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorUnschedulableContext::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorUnschedulableContext.error_message)
}

// -------------------------------------------------------------------

// ActorDiedErrorContext

// string error_message = 1;
inline void ActorDiedErrorContext::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::error_message() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.error_message)
}
inline std::string* ActorDiedErrorContext::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.error_message)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_error_message() const {
  return error_message_.Get();
}
inline void ActorDiedErrorContext::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_error_message() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.error_message)
}

// bytes owner_id = 2;
inline void ActorDiedErrorContext::clear_owner_id() {
  owner_id_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::owner_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.owner_id)
  return _internal_owner_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_owner_id(ArgT0&& arg0, ArgT... args) {
 
 owner_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.owner_id)
}
inline std::string* ActorDiedErrorContext::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.owner_id)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_owner_id() const {
  return owner_id_.Get();
}
inline void ActorDiedErrorContext::_internal_set_owner_id(const std::string& value) {
  
  owner_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_owner_id() {
  
  return owner_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_owner_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.owner_id)
  return owner_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_owner_id(std::string* owner_id) {
  if (owner_id != nullptr) {
    
  } else {
    
  }
  owner_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.owner_id)
}

// string owner_ip_address = 3;
inline void ActorDiedErrorContext::clear_owner_ip_address() {
  owner_ip_address_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::owner_ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.owner_ip_address)
  return _internal_owner_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_owner_ip_address(ArgT0&& arg0, ArgT... args) {
 
 owner_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.owner_ip_address)
}
inline std::string* ActorDiedErrorContext::mutable_owner_ip_address() {
  std::string* _s = _internal_mutable_owner_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.owner_ip_address)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_owner_ip_address() const {
  return owner_ip_address_.Get();
}
inline void ActorDiedErrorContext::_internal_set_owner_ip_address(const std::string& value) {
  
  owner_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_owner_ip_address() {
  
  return owner_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_owner_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.owner_ip_address)
  return owner_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_owner_ip_address(std::string* owner_ip_address) {
  if (owner_ip_address != nullptr) {
    
  } else {
    
  }
  owner_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.owner_ip_address)
}

// string node_ip_address = 4;
inline void ActorDiedErrorContext::clear_node_ip_address() {
  node_ip_address_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::node_ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.node_ip_address)
  return _internal_node_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_node_ip_address(ArgT0&& arg0, ArgT... args) {
 
 node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.node_ip_address)
}
inline std::string* ActorDiedErrorContext::mutable_node_ip_address() {
  std::string* _s = _internal_mutable_node_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.node_ip_address)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_node_ip_address() const {
  return node_ip_address_.Get();
}
inline void ActorDiedErrorContext::_internal_set_node_ip_address(const std::string& value) {
  
  node_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_node_ip_address() {
  
  return node_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_node_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.node_ip_address)
  return node_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_node_ip_address(std::string* node_ip_address) {
  if (node_ip_address != nullptr) {
    
  } else {
    
  }
  node_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.node_ip_address)
}

// uint32 pid = 5;
inline void ActorDiedErrorContext::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActorDiedErrorContext::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActorDiedErrorContext::pid() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.pid)
  return _internal_pid();
}
inline void ActorDiedErrorContext::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void ActorDiedErrorContext::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.pid)
}

// string name = 6;
inline void ActorDiedErrorContext::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.name)
}
inline std::string* ActorDiedErrorContext::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.name)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_name() const {
  return name_.Get();
}
inline void ActorDiedErrorContext::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.name)
}

// string mcs_namespace = 7;
inline void ActorDiedErrorContext::clear_mcs_namespace() {
  mcs_namespace_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::mcs_namespace() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.mcs_namespace)
  return _internal_mcs_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_mcs_namespace(ArgT0&& arg0, ArgT... args) {
 
 mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.mcs_namespace)
}
inline std::string* ActorDiedErrorContext::mutable_mcs_namespace() {
  std::string* _s = _internal_mutable_mcs_namespace();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.mcs_namespace)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_mcs_namespace() const {
  return mcs_namespace_.Get();
}
inline void ActorDiedErrorContext::_internal_set_mcs_namespace(const std::string& value) {
  
  mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_mcs_namespace() {
  
  return mcs_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_mcs_namespace() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.mcs_namespace)
  return mcs_namespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_mcs_namespace(std::string* mcs_namespace) {
  if (mcs_namespace != nullptr) {
    
  } else {
    
  }
  mcs_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcs_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.mcs_namespace)
}

// string class_name = 8;
inline void ActorDiedErrorContext::clear_class_name() {
  class_name_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::class_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.class_name)
}
inline std::string* ActorDiedErrorContext::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.class_name)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_class_name() const {
  return class_name_.Get();
}
inline void ActorDiedErrorContext::_internal_set_class_name(const std::string& value) {
  
  class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_class_name() {
  
  return class_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_class_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.class_name)
  return class_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  class_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), class_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.class_name)
}

// bytes actor_id = 9;
inline void ActorDiedErrorContext::clear_actor_id() {
  actor_id_.ClearToEmpty();
}
inline const std::string& ActorDiedErrorContext::actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorDiedErrorContext::set_actor_id(ArgT0&& arg0, ArgT... args) {
 
 actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.actor_id)
}
inline std::string* ActorDiedErrorContext::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorDiedErrorContext.actor_id)
  return _s;
}
inline const std::string& ActorDiedErrorContext::_internal_actor_id() const {
  return actor_id_.Get();
}
inline void ActorDiedErrorContext::_internal_set_actor_id(const std::string& value) {
  
  actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::_internal_mutable_actor_id() {
  
  return actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorDiedErrorContext::release_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorDiedErrorContext.actor_id)
  return actor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorDiedErrorContext::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorDiedErrorContext.actor_id)
}

// bool never_started = 10;
inline void ActorDiedErrorContext::clear_never_started() {
  never_started_ = false;
}
inline bool ActorDiedErrorContext::_internal_never_started() const {
  return never_started_;
}
inline bool ActorDiedErrorContext::never_started() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorDiedErrorContext.never_started)
  return _internal_never_started();
}
inline void ActorDiedErrorContext::_internal_set_never_started(bool value) {
  
  never_started_ = value;
}
inline void ActorDiedErrorContext::set_never_started(bool value) {
  _internal_set_never_started(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorDiedErrorContext.never_started)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskSpec

// .mcs.rpc.TaskType type = 1;
inline void TaskSpec::clear_type() {
  type_ = 0;
}
inline ::mcs::rpc::TaskType TaskSpec::_internal_type() const {
  return static_cast< ::mcs::rpc::TaskType >(type_);
}
inline ::mcs::rpc::TaskType TaskSpec::type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.type)
  return _internal_type();
}
inline void TaskSpec::_internal_set_type(::mcs::rpc::TaskType value) {
  
  type_ = value;
}
inline void TaskSpec::set_type(::mcs::rpc::TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.type)
}

// string name = 2;
inline void TaskSpec::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TaskSpec::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.name)
}
inline std::string* TaskSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.name)
  return _s;
}
inline const std::string& TaskSpec::_internal_name() const {
  return name_.Get();
}
inline void TaskSpec::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.name)
}

// .mcs.rpc.Language language = 3;
inline void TaskSpec::clear_language() {
  language_ = 0;
}
inline ::mcs::rpc::Language TaskSpec::_internal_language() const {
  return static_cast< ::mcs::rpc::Language >(language_);
}
inline ::mcs::rpc::Language TaskSpec::language() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.language)
  return _internal_language();
}
inline void TaskSpec::_internal_set_language(::mcs::rpc::Language value) {
  
  language_ = value;
}
inline void TaskSpec::set_language(::mcs::rpc::Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.language)
}

// .mcs.rpc.FunctionDescriptor function_descriptor = 4;
inline bool TaskSpec::_internal_has_function_descriptor() const {
  return this != internal_default_instance() && function_descriptor_ != nullptr;
}
inline bool TaskSpec::has_function_descriptor() const {
  return _internal_has_function_descriptor();
}
inline void TaskSpec::clear_function_descriptor() {
  if (GetArenaForAllocation() == nullptr && function_descriptor_ != nullptr) {
    delete function_descriptor_;
  }
  function_descriptor_ = nullptr;
}
inline const ::mcs::rpc::FunctionDescriptor& TaskSpec::_internal_function_descriptor() const {
  const ::mcs::rpc::FunctionDescriptor* p = function_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::FunctionDescriptor&>(
      ::mcs::rpc::_FunctionDescriptor_default_instance_);
}
inline const ::mcs::rpc::FunctionDescriptor& TaskSpec::function_descriptor() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.function_descriptor)
  return _internal_function_descriptor();
}
inline void TaskSpec::unsafe_arena_set_allocated_function_descriptor(
    ::mcs::rpc::FunctionDescriptor* function_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_descriptor_);
  }
  function_descriptor_ = function_descriptor;
  if (function_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskSpec.function_descriptor)
}
inline ::mcs::rpc::FunctionDescriptor* TaskSpec::release_function_descriptor() {
  
  ::mcs::rpc::FunctionDescriptor* temp = function_descriptor_;
  function_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::FunctionDescriptor* TaskSpec::unsafe_arena_release_function_descriptor() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.function_descriptor)
  
  ::mcs::rpc::FunctionDescriptor* temp = function_descriptor_;
  function_descriptor_ = nullptr;
  return temp;
}
inline ::mcs::rpc::FunctionDescriptor* TaskSpec::_internal_mutable_function_descriptor() {
  
  if (function_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::FunctionDescriptor>(GetArenaForAllocation());
    function_descriptor_ = p;
  }
  return function_descriptor_;
}
inline ::mcs::rpc::FunctionDescriptor* TaskSpec::mutable_function_descriptor() {
  ::mcs::rpc::FunctionDescriptor* _msg = _internal_mutable_function_descriptor();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.function_descriptor)
  return _msg;
}
inline void TaskSpec::set_allocated_function_descriptor(::mcs::rpc::FunctionDescriptor* function_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete function_descriptor_;
  }
  if (function_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::FunctionDescriptor>::GetOwningArena(function_descriptor);
    if (message_arena != submessage_arena) {
      function_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  function_descriptor_ = function_descriptor;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.function_descriptor)
}

// bytes job_id = 5;
inline void TaskSpec::clear_job_id() {
  job_id_.ClearToEmpty();
}
inline const std::string& TaskSpec::job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.job_id)
}
inline std::string* TaskSpec::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.job_id)
  return _s;
}
inline const std::string& TaskSpec::_internal_job_id() const {
  return job_id_.Get();
}
inline void TaskSpec::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_job_id() {
  
  return job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.job_id)
}

// bytes task_id = 6;
inline void TaskSpec::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& TaskSpec::task_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.task_id)
}
inline std::string* TaskSpec::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.task_id)
  return _s;
}
inline const std::string& TaskSpec::_internal_task_id() const {
  return task_id_.Get();
}
inline void TaskSpec::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_task_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.task_id)
}

// bytes parent_task_id = 7;
inline void TaskSpec::clear_parent_task_id() {
  parent_task_id_.ClearToEmpty();
}
inline const std::string& TaskSpec::parent_task_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.parent_task_id)
  return _internal_parent_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_parent_task_id(ArgT0&& arg0, ArgT... args) {
 
 parent_task_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.parent_task_id)
}
inline std::string* TaskSpec::mutable_parent_task_id() {
  std::string* _s = _internal_mutable_parent_task_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.parent_task_id)
  return _s;
}
inline const std::string& TaskSpec::_internal_parent_task_id() const {
  return parent_task_id_.Get();
}
inline void TaskSpec::_internal_set_parent_task_id(const std::string& value) {
  
  parent_task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_parent_task_id() {
  
  return parent_task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_parent_task_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.parent_task_id)
  return parent_task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_parent_task_id(std::string* parent_task_id) {
  if (parent_task_id != nullptr) {
    
  } else {
    
  }
  parent_task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.parent_task_id)
}

// uint64 parent_counter = 8;
inline void TaskSpec::clear_parent_counter() {
  parent_counter_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskSpec::_internal_parent_counter() const {
  return parent_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskSpec::parent_counter() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.parent_counter)
  return _internal_parent_counter();
}
inline void TaskSpec::_internal_set_parent_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  parent_counter_ = value;
}
inline void TaskSpec::set_parent_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_parent_counter(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.parent_counter)
}

// bytes caller_id = 9;
inline void TaskSpec::clear_caller_id() {
  caller_id_.ClearToEmpty();
}
inline const std::string& TaskSpec::caller_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.caller_id)
  return _internal_caller_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_caller_id(ArgT0&& arg0, ArgT... args) {
 
 caller_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.caller_id)
}
inline std::string* TaskSpec::mutable_caller_id() {
  std::string* _s = _internal_mutable_caller_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.caller_id)
  return _s;
}
inline const std::string& TaskSpec::_internal_caller_id() const {
  return caller_id_.Get();
}
inline void TaskSpec::_internal_set_caller_id(const std::string& value) {
  
  caller_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_caller_id() {
  
  return caller_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_caller_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.caller_id)
  return caller_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_caller_id(std::string* caller_id) {
  if (caller_id != nullptr) {
    
  } else {
    
  }
  caller_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.caller_id)
}

// .mcs.rpc.Address caller_address = 10;
inline bool TaskSpec::_internal_has_caller_address() const {
  return this != internal_default_instance() && caller_address_ != nullptr;
}
inline bool TaskSpec::has_caller_address() const {
  return _internal_has_caller_address();
}
inline void TaskSpec::clear_caller_address() {
  if (GetArenaForAllocation() == nullptr && caller_address_ != nullptr) {
    delete caller_address_;
  }
  caller_address_ = nullptr;
}
inline const ::mcs::rpc::Address& TaskSpec::_internal_caller_address() const {
  const ::mcs::rpc::Address* p = caller_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::Address&>(
      ::mcs::rpc::_Address_default_instance_);
}
inline const ::mcs::rpc::Address& TaskSpec::caller_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.caller_address)
  return _internal_caller_address();
}
inline void TaskSpec::unsafe_arena_set_allocated_caller_address(
    ::mcs::rpc::Address* caller_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caller_address_);
  }
  caller_address_ = caller_address;
  if (caller_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskSpec.caller_address)
}
inline ::mcs::rpc::Address* TaskSpec::release_caller_address() {
  
  ::mcs::rpc::Address* temp = caller_address_;
  caller_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::Address* TaskSpec::unsafe_arena_release_caller_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.caller_address)
  
  ::mcs::rpc::Address* temp = caller_address_;
  caller_address_ = nullptr;
  return temp;
}
inline ::mcs::rpc::Address* TaskSpec::_internal_mutable_caller_address() {
  
  if (caller_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::Address>(GetArenaForAllocation());
    caller_address_ = p;
  }
  return caller_address_;
}
inline ::mcs::rpc::Address* TaskSpec::mutable_caller_address() {
  ::mcs::rpc::Address* _msg = _internal_mutable_caller_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.caller_address)
  return _msg;
}
inline void TaskSpec::set_allocated_caller_address(::mcs::rpc::Address* caller_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete caller_address_;
  }
  if (caller_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::Address>::GetOwningArena(caller_address);
    if (message_arena != submessage_arena) {
      caller_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caller_address, submessage_arena);
    }
    
  } else {
    
  }
  caller_address_ = caller_address;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.caller_address)
}

// repeated .mcs.rpc.TaskArg args = 11;
inline int TaskSpec::_internal_args_size() const {
  return args_.size();
}
inline int TaskSpec::args_size() const {
  return _internal_args_size();
}
inline void TaskSpec::clear_args() {
  args_.Clear();
}
inline ::mcs::rpc::TaskArg* TaskSpec::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskArg >*
TaskSpec::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.TaskSpec.args)
  return &args_;
}
inline const ::mcs::rpc::TaskArg& TaskSpec::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::mcs::rpc::TaskArg& TaskSpec::args(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.args)
  return _internal_args(index);
}
inline ::mcs::rpc::TaskArg* TaskSpec::_internal_add_args() {
  return args_.Add();
}
inline ::mcs::rpc::TaskArg* TaskSpec::add_args() {
  ::mcs::rpc::TaskArg* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:mcs.rpc.TaskSpec.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::TaskArg >&
TaskSpec::args() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.TaskSpec.args)
  return args_;
}

// uint64 num_returns = 12;
inline void TaskSpec::clear_num_returns() {
  num_returns_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskSpec::_internal_num_returns() const {
  return num_returns_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskSpec::num_returns() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.num_returns)
  return _internal_num_returns();
}
inline void TaskSpec::_internal_set_num_returns(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  num_returns_ = value;
}
inline void TaskSpec::set_num_returns(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_num_returns(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.num_returns)
}

// map<string, double> required_resources = 13;
inline int TaskSpec::_internal_required_resources_size() const {
  return required_resources_.size();
}
inline int TaskSpec::required_resources_size() const {
  return _internal_required_resources_size();
}
inline void TaskSpec::clear_required_resources() {
  required_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TaskSpec::_internal_required_resources() const {
  return required_resources_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TaskSpec::required_resources() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.TaskSpec.required_resources)
  return _internal_required_resources();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TaskSpec::_internal_mutable_required_resources() {
  return required_resources_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TaskSpec::mutable_required_resources() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.TaskSpec.required_resources)
  return _internal_mutable_required_resources();
}

// map<string, double> required_placement_resources = 14;
inline int TaskSpec::_internal_required_placement_resources_size() const {
  return required_placement_resources_.size();
}
inline int TaskSpec::required_placement_resources_size() const {
  return _internal_required_placement_resources_size();
}
inline void TaskSpec::clear_required_placement_resources() {
  required_placement_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TaskSpec::_internal_required_placement_resources() const {
  return required_placement_resources_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TaskSpec::required_placement_resources() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.TaskSpec.required_placement_resources)
  return _internal_required_placement_resources();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TaskSpec::_internal_mutable_required_placement_resources() {
  return required_placement_resources_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TaskSpec::mutable_required_placement_resources() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.TaskSpec.required_placement_resources)
  return _internal_mutable_required_placement_resources();
}

// .mcs.rpc.ActorCreationTaskSpec actor_creation_task_spec = 15;
inline bool TaskSpec::_internal_has_actor_creation_task_spec() const {
  return this != internal_default_instance() && actor_creation_task_spec_ != nullptr;
}
inline bool TaskSpec::has_actor_creation_task_spec() const {
  return _internal_has_actor_creation_task_spec();
}
inline void TaskSpec::clear_actor_creation_task_spec() {
  if (GetArenaForAllocation() == nullptr && actor_creation_task_spec_ != nullptr) {
    delete actor_creation_task_spec_;
  }
  actor_creation_task_spec_ = nullptr;
}
inline const ::mcs::rpc::ActorCreationTaskSpec& TaskSpec::_internal_actor_creation_task_spec() const {
  const ::mcs::rpc::ActorCreationTaskSpec* p = actor_creation_task_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ActorCreationTaskSpec&>(
      ::mcs::rpc::_ActorCreationTaskSpec_default_instance_);
}
inline const ::mcs::rpc::ActorCreationTaskSpec& TaskSpec::actor_creation_task_spec() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.actor_creation_task_spec)
  return _internal_actor_creation_task_spec();
}
inline void TaskSpec::unsafe_arena_set_allocated_actor_creation_task_spec(
    ::mcs::rpc::ActorCreationTaskSpec* actor_creation_task_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actor_creation_task_spec_);
  }
  actor_creation_task_spec_ = actor_creation_task_spec;
  if (actor_creation_task_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskSpec.actor_creation_task_spec)
}
inline ::mcs::rpc::ActorCreationTaskSpec* TaskSpec::release_actor_creation_task_spec() {
  
  ::mcs::rpc::ActorCreationTaskSpec* temp = actor_creation_task_spec_;
  actor_creation_task_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ActorCreationTaskSpec* TaskSpec::unsafe_arena_release_actor_creation_task_spec() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.actor_creation_task_spec)
  
  ::mcs::rpc::ActorCreationTaskSpec* temp = actor_creation_task_spec_;
  actor_creation_task_spec_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ActorCreationTaskSpec* TaskSpec::_internal_mutable_actor_creation_task_spec() {
  
  if (actor_creation_task_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ActorCreationTaskSpec>(GetArenaForAllocation());
    actor_creation_task_spec_ = p;
  }
  return actor_creation_task_spec_;
}
inline ::mcs::rpc::ActorCreationTaskSpec* TaskSpec::mutable_actor_creation_task_spec() {
  ::mcs::rpc::ActorCreationTaskSpec* _msg = _internal_mutable_actor_creation_task_spec();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.actor_creation_task_spec)
  return _msg;
}
inline void TaskSpec::set_allocated_actor_creation_task_spec(::mcs::rpc::ActorCreationTaskSpec* actor_creation_task_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete actor_creation_task_spec_;
  }
  if (actor_creation_task_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::ActorCreationTaskSpec>::GetOwningArena(actor_creation_task_spec);
    if (message_arena != submessage_arena) {
      actor_creation_task_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actor_creation_task_spec, submessage_arena);
    }
    
  } else {
    
  }
  actor_creation_task_spec_ = actor_creation_task_spec;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.actor_creation_task_spec)
}

// .mcs.rpc.ActorTaskSpec actor_task_spec = 16;
inline bool TaskSpec::_internal_has_actor_task_spec() const {
  return this != internal_default_instance() && actor_task_spec_ != nullptr;
}
inline bool TaskSpec::has_actor_task_spec() const {
  return _internal_has_actor_task_spec();
}
inline void TaskSpec::clear_actor_task_spec() {
  if (GetArenaForAllocation() == nullptr && actor_task_spec_ != nullptr) {
    delete actor_task_spec_;
  }
  actor_task_spec_ = nullptr;
}
inline const ::mcs::rpc::ActorTaskSpec& TaskSpec::_internal_actor_task_spec() const {
  const ::mcs::rpc::ActorTaskSpec* p = actor_task_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ActorTaskSpec&>(
      ::mcs::rpc::_ActorTaskSpec_default_instance_);
}
inline const ::mcs::rpc::ActorTaskSpec& TaskSpec::actor_task_spec() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.actor_task_spec)
  return _internal_actor_task_spec();
}
inline void TaskSpec::unsafe_arena_set_allocated_actor_task_spec(
    ::mcs::rpc::ActorTaskSpec* actor_task_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actor_task_spec_);
  }
  actor_task_spec_ = actor_task_spec;
  if (actor_task_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskSpec.actor_task_spec)
}
inline ::mcs::rpc::ActorTaskSpec* TaskSpec::release_actor_task_spec() {
  
  ::mcs::rpc::ActorTaskSpec* temp = actor_task_spec_;
  actor_task_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ActorTaskSpec* TaskSpec::unsafe_arena_release_actor_task_spec() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.actor_task_spec)
  
  ::mcs::rpc::ActorTaskSpec* temp = actor_task_spec_;
  actor_task_spec_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ActorTaskSpec* TaskSpec::_internal_mutable_actor_task_spec() {
  
  if (actor_task_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ActorTaskSpec>(GetArenaForAllocation());
    actor_task_spec_ = p;
  }
  return actor_task_spec_;
}
inline ::mcs::rpc::ActorTaskSpec* TaskSpec::mutable_actor_task_spec() {
  ::mcs::rpc::ActorTaskSpec* _msg = _internal_mutable_actor_task_spec();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.actor_task_spec)
  return _msg;
}
inline void TaskSpec::set_allocated_actor_task_spec(::mcs::rpc::ActorTaskSpec* actor_task_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete actor_task_spec_;
  }
  if (actor_task_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::ActorTaskSpec>::GetOwningArena(actor_task_spec);
    if (message_arena != submessage_arena) {
      actor_task_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actor_task_spec, submessage_arena);
    }
    
  } else {
    
  }
  actor_task_spec_ = actor_task_spec;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.actor_task_spec)
}

// int32 max_retries = 17;
inline void TaskSpec::clear_max_retries() {
  max_retries_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskSpec::_internal_max_retries() const {
  return max_retries_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskSpec::max_retries() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.max_retries)
  return _internal_max_retries();
}
inline void TaskSpec::_internal_set_max_retries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_retries_ = value;
}
inline void TaskSpec::set_max_retries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_retries(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.max_retries)
}

// bool skip_execution = 21;
inline void TaskSpec::clear_skip_execution() {
  skip_execution_ = false;
}
inline bool TaskSpec::_internal_skip_execution() const {
  return skip_execution_;
}
inline bool TaskSpec::skip_execution() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.skip_execution)
  return _internal_skip_execution();
}
inline void TaskSpec::_internal_set_skip_execution(bool value) {
  
  skip_execution_ = value;
}
inline void TaskSpec::set_skip_execution(bool value) {
  _internal_set_skip_execution(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.skip_execution)
}

// bytes debugger_breakpoint = 22;
inline void TaskSpec::clear_debugger_breakpoint() {
  debugger_breakpoint_.ClearToEmpty();
}
inline const std::string& TaskSpec::debugger_breakpoint() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.debugger_breakpoint)
  return _internal_debugger_breakpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_debugger_breakpoint(ArgT0&& arg0, ArgT... args) {
 
 debugger_breakpoint_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.debugger_breakpoint)
}
inline std::string* TaskSpec::mutable_debugger_breakpoint() {
  std::string* _s = _internal_mutable_debugger_breakpoint();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.debugger_breakpoint)
  return _s;
}
inline const std::string& TaskSpec::_internal_debugger_breakpoint() const {
  return debugger_breakpoint_.Get();
}
inline void TaskSpec::_internal_set_debugger_breakpoint(const std::string& value) {
  
  debugger_breakpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_debugger_breakpoint() {
  
  return debugger_breakpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_debugger_breakpoint() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.debugger_breakpoint)
  return debugger_breakpoint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_debugger_breakpoint(std::string* debugger_breakpoint) {
  if (debugger_breakpoint != nullptr) {
    
  } else {
    
  }
  debugger_breakpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), debugger_breakpoint,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.debugger_breakpoint)
}

// .mcs.rpc.RuntimeEnvInfo runtime_env_info = 23;
inline bool TaskSpec::_internal_has_runtime_env_info() const {
  return this != internal_default_instance() && runtime_env_info_ != nullptr;
}
inline bool TaskSpec::has_runtime_env_info() const {
  return _internal_has_runtime_env_info();
}
inline const ::mcs::rpc::RuntimeEnvInfo& TaskSpec::_internal_runtime_env_info() const {
  const ::mcs::rpc::RuntimeEnvInfo* p = runtime_env_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::RuntimeEnvInfo&>(
      ::mcs::rpc::_RuntimeEnvInfo_default_instance_);
}
inline const ::mcs::rpc::RuntimeEnvInfo& TaskSpec::runtime_env_info() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.runtime_env_info)
  return _internal_runtime_env_info();
}
inline void TaskSpec::unsafe_arena_set_allocated_runtime_env_info(
    ::mcs::rpc::RuntimeEnvInfo* runtime_env_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info_);
  }
  runtime_env_info_ = runtime_env_info;
  if (runtime_env_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskSpec.runtime_env_info)
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskSpec::release_runtime_env_info() {
  
  ::mcs::rpc::RuntimeEnvInfo* temp = runtime_env_info_;
  runtime_env_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskSpec::unsafe_arena_release_runtime_env_info() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.runtime_env_info)
  
  ::mcs::rpc::RuntimeEnvInfo* temp = runtime_env_info_;
  runtime_env_info_ = nullptr;
  return temp;
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskSpec::_internal_mutable_runtime_env_info() {
  
  if (runtime_env_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::RuntimeEnvInfo>(GetArenaForAllocation());
    runtime_env_info_ = p;
  }
  return runtime_env_info_;
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskSpec::mutable_runtime_env_info() {
  ::mcs::rpc::RuntimeEnvInfo* _msg = _internal_mutable_runtime_env_info();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.runtime_env_info)
  return _msg;
}
inline void TaskSpec::set_allocated_runtime_env_info(::mcs::rpc::RuntimeEnvInfo* runtime_env_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info_);
  }
  if (runtime_env_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info));
    if (message_arena != submessage_arena) {
      runtime_env_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime_env_info, submessage_arena);
    }
    
  } else {
    
  }
  runtime_env_info_ = runtime_env_info;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.runtime_env_info)
}

// string concurrency_group_name = 24;
inline void TaskSpec::clear_concurrency_group_name() {
  concurrency_group_name_.ClearToEmpty();
}
inline const std::string& TaskSpec::concurrency_group_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.concurrency_group_name)
  return _internal_concurrency_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_concurrency_group_name(ArgT0&& arg0, ArgT... args) {
 
 concurrency_group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.concurrency_group_name)
}
inline std::string* TaskSpec::mutable_concurrency_group_name() {
  std::string* _s = _internal_mutable_concurrency_group_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.concurrency_group_name)
  return _s;
}
inline const std::string& TaskSpec::_internal_concurrency_group_name() const {
  return concurrency_group_name_.Get();
}
inline void TaskSpec::_internal_set_concurrency_group_name(const std::string& value) {
  
  concurrency_group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_concurrency_group_name() {
  
  return concurrency_group_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_concurrency_group_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.concurrency_group_name)
  return concurrency_group_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_concurrency_group_name(std::string* concurrency_group_name) {
  if (concurrency_group_name != nullptr) {
    
  } else {
    
  }
  concurrency_group_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), concurrency_group_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.concurrency_group_name)
}

// bool retry_exceptions = 25;
inline void TaskSpec::clear_retry_exceptions() {
  retry_exceptions_ = false;
}
inline bool TaskSpec::_internal_retry_exceptions() const {
  return retry_exceptions_;
}
inline bool TaskSpec::retry_exceptions() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.retry_exceptions)
  return _internal_retry_exceptions();
}
inline void TaskSpec::_internal_set_retry_exceptions(bool value) {
  
  retry_exceptions_ = value;
}
inline void TaskSpec::set_retry_exceptions(bool value) {
  _internal_set_retry_exceptions(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.retry_exceptions)
}

// bytes serialized_retry_exception_allowlist = 26;
inline void TaskSpec::clear_serialized_retry_exception_allowlist() {
  serialized_retry_exception_allowlist_.ClearToEmpty();
}
inline const std::string& TaskSpec::serialized_retry_exception_allowlist() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.serialized_retry_exception_allowlist)
  return _internal_serialized_retry_exception_allowlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskSpec::set_serialized_retry_exception_allowlist(ArgT0&& arg0, ArgT... args) {
 
 serialized_retry_exception_allowlist_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.serialized_retry_exception_allowlist)
}
inline std::string* TaskSpec::mutable_serialized_retry_exception_allowlist() {
  std::string* _s = _internal_mutable_serialized_retry_exception_allowlist();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.serialized_retry_exception_allowlist)
  return _s;
}
inline const std::string& TaskSpec::_internal_serialized_retry_exception_allowlist() const {
  return serialized_retry_exception_allowlist_.Get();
}
inline void TaskSpec::_internal_set_serialized_retry_exception_allowlist(const std::string& value) {
  
  serialized_retry_exception_allowlist_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskSpec::_internal_mutable_serialized_retry_exception_allowlist() {
  
  return serialized_retry_exception_allowlist_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskSpec::release_serialized_retry_exception_allowlist() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.serialized_retry_exception_allowlist)
  return serialized_retry_exception_allowlist_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskSpec::set_allocated_serialized_retry_exception_allowlist(std::string* serialized_retry_exception_allowlist) {
  if (serialized_retry_exception_allowlist != nullptr) {
    
  } else {
    
  }
  serialized_retry_exception_allowlist_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_retry_exception_allowlist,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.serialized_retry_exception_allowlist)
}

// int64 depth = 27;
inline void TaskSpec::clear_depth() {
  depth_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskSpec::_internal_depth() const {
  return depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskSpec::depth() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.depth)
  return _internal_depth();
}
inline void TaskSpec::_internal_set_depth(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  depth_ = value;
}
inline void TaskSpec::set_depth(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.depth)
}

// .mcs.rpc.SchedulingStrategy scheduling_strategy = 28;
inline bool TaskSpec::_internal_has_scheduling_strategy() const {
  return this != internal_default_instance() && scheduling_strategy_ != nullptr;
}
inline bool TaskSpec::has_scheduling_strategy() const {
  return _internal_has_scheduling_strategy();
}
inline void TaskSpec::clear_scheduling_strategy() {
  if (GetArenaForAllocation() == nullptr && scheduling_strategy_ != nullptr) {
    delete scheduling_strategy_;
  }
  scheduling_strategy_ = nullptr;
}
inline const ::mcs::rpc::SchedulingStrategy& TaskSpec::_internal_scheduling_strategy() const {
  const ::mcs::rpc::SchedulingStrategy* p = scheduling_strategy_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::SchedulingStrategy&>(
      ::mcs::rpc::_SchedulingStrategy_default_instance_);
}
inline const ::mcs::rpc::SchedulingStrategy& TaskSpec::scheduling_strategy() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.scheduling_strategy)
  return _internal_scheduling_strategy();
}
inline void TaskSpec::unsafe_arena_set_allocated_scheduling_strategy(
    ::mcs::rpc::SchedulingStrategy* scheduling_strategy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scheduling_strategy_);
  }
  scheduling_strategy_ = scheduling_strategy;
  if (scheduling_strategy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskSpec.scheduling_strategy)
}
inline ::mcs::rpc::SchedulingStrategy* TaskSpec::release_scheduling_strategy() {
  
  ::mcs::rpc::SchedulingStrategy* temp = scheduling_strategy_;
  scheduling_strategy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::SchedulingStrategy* TaskSpec::unsafe_arena_release_scheduling_strategy() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskSpec.scheduling_strategy)
  
  ::mcs::rpc::SchedulingStrategy* temp = scheduling_strategy_;
  scheduling_strategy_ = nullptr;
  return temp;
}
inline ::mcs::rpc::SchedulingStrategy* TaskSpec::_internal_mutable_scheduling_strategy() {
  
  if (scheduling_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::SchedulingStrategy>(GetArenaForAllocation());
    scheduling_strategy_ = p;
  }
  return scheduling_strategy_;
}
inline ::mcs::rpc::SchedulingStrategy* TaskSpec::mutable_scheduling_strategy() {
  ::mcs::rpc::SchedulingStrategy* _msg = _internal_mutable_scheduling_strategy();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.scheduling_strategy)
  return _msg;
}
inline void TaskSpec::set_allocated_scheduling_strategy(::mcs::rpc::SchedulingStrategy* scheduling_strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete scheduling_strategy_;
  }
  if (scheduling_strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::SchedulingStrategy>::GetOwningArena(scheduling_strategy);
    if (message_arena != submessage_arena) {
      scheduling_strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scheduling_strategy, submessage_arena);
    }
    
  } else {
    
  }
  scheduling_strategy_ = scheduling_strategy;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskSpec.scheduling_strategy)
}

// uint64 attempt_number = 29;
inline void TaskSpec::clear_attempt_number() {
  attempt_number_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskSpec::_internal_attempt_number() const {
  return attempt_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskSpec::attempt_number() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.attempt_number)
  return _internal_attempt_number();
}
inline void TaskSpec::_internal_set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  attempt_number_ = value;
}
inline void TaskSpec::set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_attempt_number(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.attempt_number)
}

// bool returns_dynamic = 30;
inline void TaskSpec::clear_returns_dynamic() {
  returns_dynamic_ = false;
}
inline bool TaskSpec::_internal_returns_dynamic() const {
  return returns_dynamic_;
}
inline bool TaskSpec::returns_dynamic() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.returns_dynamic)
  return _internal_returns_dynamic();
}
inline void TaskSpec::_internal_set_returns_dynamic(bool value) {
  
  returns_dynamic_ = value;
}
inline void TaskSpec::set_returns_dynamic(bool value) {
  _internal_set_returns_dynamic(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.returns_dynamic)
}

// repeated bytes dynamic_return_ids = 31;
inline int TaskSpec::_internal_dynamic_return_ids_size() const {
  return dynamic_return_ids_.size();
}
inline int TaskSpec::dynamic_return_ids_size() const {
  return _internal_dynamic_return_ids_size();
}
inline void TaskSpec::clear_dynamic_return_ids() {
  dynamic_return_ids_.Clear();
}
inline std::string* TaskSpec::add_dynamic_return_ids() {
  std::string* _s = _internal_add_dynamic_return_ids();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.TaskSpec.dynamic_return_ids)
  return _s;
}
inline const std::string& TaskSpec::_internal_dynamic_return_ids(int index) const {
  return dynamic_return_ids_.Get(index);
}
inline const std::string& TaskSpec::dynamic_return_ids(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskSpec.dynamic_return_ids)
  return _internal_dynamic_return_ids(index);
}
inline std::string* TaskSpec::mutable_dynamic_return_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskSpec.dynamic_return_ids)
  return dynamic_return_ids_.Mutable(index);
}
inline void TaskSpec::set_dynamic_return_ids(int index, const std::string& value) {
  dynamic_return_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline void TaskSpec::set_dynamic_return_ids(int index, std::string&& value) {
  dynamic_return_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline void TaskSpec::set_dynamic_return_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dynamic_return_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline void TaskSpec::set_dynamic_return_ids(int index, const void* value, size_t size) {
  dynamic_return_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline std::string* TaskSpec::_internal_add_dynamic_return_ids() {
  return dynamic_return_ids_.Add();
}
inline void TaskSpec::add_dynamic_return_ids(const std::string& value) {
  dynamic_return_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline void TaskSpec::add_dynamic_return_ids(std::string&& value) {
  dynamic_return_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline void TaskSpec::add_dynamic_return_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dynamic_return_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline void TaskSpec::add_dynamic_return_ids(const void* value, size_t size) {
  dynamic_return_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.TaskSpec.dynamic_return_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskSpec::dynamic_return_ids() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.TaskSpec.dynamic_return_ids)
  return dynamic_return_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskSpec::mutable_dynamic_return_ids() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.TaskSpec.dynamic_return_ids)
  return &dynamic_return_ids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskInfoEntry

// .mcs.rpc.TaskType type = 1;
inline void TaskInfoEntry::clear_type() {
  type_ = 0;
}
inline ::mcs::rpc::TaskType TaskInfoEntry::_internal_type() const {
  return static_cast< ::mcs::rpc::TaskType >(type_);
}
inline ::mcs::rpc::TaskType TaskInfoEntry::type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.type)
  return _internal_type();
}
inline void TaskInfoEntry::_internal_set_type(::mcs::rpc::TaskType value) {
  
  type_ = value;
}
inline void TaskInfoEntry::set_type(::mcs::rpc::TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.type)
}

// string name = 2;
inline void TaskInfoEntry::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TaskInfoEntry::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfoEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.name)
}
inline std::string* TaskInfoEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.name)
  return _s;
}
inline const std::string& TaskInfoEntry::_internal_name() const {
  return name_.Get();
}
inline void TaskInfoEntry::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfoEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.name)
}

// .mcs.rpc.Language language = 3;
inline void TaskInfoEntry::clear_language() {
  language_ = 0;
}
inline ::mcs::rpc::Language TaskInfoEntry::_internal_language() const {
  return static_cast< ::mcs::rpc::Language >(language_);
}
inline ::mcs::rpc::Language TaskInfoEntry::language() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.language)
  return _internal_language();
}
inline void TaskInfoEntry::_internal_set_language(::mcs::rpc::Language value) {
  
  language_ = value;
}
inline void TaskInfoEntry::set_language(::mcs::rpc::Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.language)
}

// string func_or_class_name = 4;
inline void TaskInfoEntry::clear_func_or_class_name() {
  func_or_class_name_.ClearToEmpty();
}
inline const std::string& TaskInfoEntry::func_or_class_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.func_or_class_name)
  return _internal_func_or_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfoEntry::set_func_or_class_name(ArgT0&& arg0, ArgT... args) {
 
 func_or_class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.func_or_class_name)
}
inline std::string* TaskInfoEntry::mutable_func_or_class_name() {
  std::string* _s = _internal_mutable_func_or_class_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.func_or_class_name)
  return _s;
}
inline const std::string& TaskInfoEntry::_internal_func_or_class_name() const {
  return func_or_class_name_.Get();
}
inline void TaskInfoEntry::_internal_set_func_or_class_name(const std::string& value) {
  
  func_or_class_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::_internal_mutable_func_or_class_name() {
  
  return func_or_class_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::release_func_or_class_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.func_or_class_name)
  return func_or_class_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfoEntry::set_allocated_func_or_class_name(std::string* func_or_class_name) {
  if (func_or_class_name != nullptr) {
    
  } else {
    
  }
  func_or_class_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), func_or_class_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.func_or_class_name)
}

// .mcs.rpc.TaskStatus scheduling_state = 5;
inline void TaskInfoEntry::clear_scheduling_state() {
  scheduling_state_ = 0;
}
inline ::mcs::rpc::TaskStatus TaskInfoEntry::_internal_scheduling_state() const {
  return static_cast< ::mcs::rpc::TaskStatus >(scheduling_state_);
}
inline ::mcs::rpc::TaskStatus TaskInfoEntry::scheduling_state() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.scheduling_state)
  return _internal_scheduling_state();
}
inline void TaskInfoEntry::_internal_set_scheduling_state(::mcs::rpc::TaskStatus value) {
  
  scheduling_state_ = value;
}
inline void TaskInfoEntry::set_scheduling_state(::mcs::rpc::TaskStatus value) {
  _internal_set_scheduling_state(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.scheduling_state)
}

// bytes job_id = 6;
inline void TaskInfoEntry::clear_job_id() {
  job_id_.ClearToEmpty();
}
inline const std::string& TaskInfoEntry::job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfoEntry::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.job_id)
}
inline std::string* TaskInfoEntry::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.job_id)
  return _s;
}
inline const std::string& TaskInfoEntry::_internal_job_id() const {
  return job_id_.Get();
}
inline void TaskInfoEntry::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::_internal_mutable_job_id() {
  
  return job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::release_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfoEntry::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.job_id)
}

// bytes task_id = 7;
inline void TaskInfoEntry::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& TaskInfoEntry::task_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfoEntry::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.task_id)
}
inline std::string* TaskInfoEntry::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.task_id)
  return _s;
}
inline const std::string& TaskInfoEntry::_internal_task_id() const {
  return task_id_.Get();
}
inline void TaskInfoEntry::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::release_task_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfoEntry::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.task_id)
}

// bytes parent_task_id = 8;
inline void TaskInfoEntry::clear_parent_task_id() {
  parent_task_id_.ClearToEmpty();
}
inline const std::string& TaskInfoEntry::parent_task_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.parent_task_id)
  return _internal_parent_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfoEntry::set_parent_task_id(ArgT0&& arg0, ArgT... args) {
 
 parent_task_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.parent_task_id)
}
inline std::string* TaskInfoEntry::mutable_parent_task_id() {
  std::string* _s = _internal_mutable_parent_task_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.parent_task_id)
  return _s;
}
inline const std::string& TaskInfoEntry::_internal_parent_task_id() const {
  return parent_task_id_.Get();
}
inline void TaskInfoEntry::_internal_set_parent_task_id(const std::string& value) {
  
  parent_task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::_internal_mutable_parent_task_id() {
  
  return parent_task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::release_parent_task_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.parent_task_id)
  return parent_task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfoEntry::set_allocated_parent_task_id(std::string* parent_task_id) {
  if (parent_task_id != nullptr) {
    
  } else {
    
  }
  parent_task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_task_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.parent_task_id)
}

// map<string, double> required_resources = 13;
inline int TaskInfoEntry::_internal_required_resources_size() const {
  return required_resources_.size();
}
inline int TaskInfoEntry::required_resources_size() const {
  return _internal_required_resources_size();
}
inline void TaskInfoEntry::clear_required_resources() {
  required_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TaskInfoEntry::_internal_required_resources() const {
  return required_resources_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
TaskInfoEntry::required_resources() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.TaskInfoEntry.required_resources)
  return _internal_required_resources();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TaskInfoEntry::_internal_mutable_required_resources() {
  return required_resources_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
TaskInfoEntry::mutable_required_resources() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.TaskInfoEntry.required_resources)
  return _internal_mutable_required_resources();
}

// .mcs.rpc.RuntimeEnvInfo runtime_env_info = 23;
inline bool TaskInfoEntry::_internal_has_runtime_env_info() const {
  return this != internal_default_instance() && runtime_env_info_ != nullptr;
}
inline bool TaskInfoEntry::has_runtime_env_info() const {
  return _internal_has_runtime_env_info();
}
inline const ::mcs::rpc::RuntimeEnvInfo& TaskInfoEntry::_internal_runtime_env_info() const {
  const ::mcs::rpc::RuntimeEnvInfo* p = runtime_env_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::RuntimeEnvInfo&>(
      ::mcs::rpc::_RuntimeEnvInfo_default_instance_);
}
inline const ::mcs::rpc::RuntimeEnvInfo& TaskInfoEntry::runtime_env_info() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.runtime_env_info)
  return _internal_runtime_env_info();
}
inline void TaskInfoEntry::unsafe_arena_set_allocated_runtime_env_info(
    ::mcs::rpc::RuntimeEnvInfo* runtime_env_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info_);
  }
  runtime_env_info_ = runtime_env_info;
  if (runtime_env_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskInfoEntry.runtime_env_info)
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskInfoEntry::release_runtime_env_info() {
  
  ::mcs::rpc::RuntimeEnvInfo* temp = runtime_env_info_;
  runtime_env_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskInfoEntry::unsafe_arena_release_runtime_env_info() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.runtime_env_info)
  
  ::mcs::rpc::RuntimeEnvInfo* temp = runtime_env_info_;
  runtime_env_info_ = nullptr;
  return temp;
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskInfoEntry::_internal_mutable_runtime_env_info() {
  
  if (runtime_env_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::RuntimeEnvInfo>(GetArenaForAllocation());
    runtime_env_info_ = p;
  }
  return runtime_env_info_;
}
inline ::mcs::rpc::RuntimeEnvInfo* TaskInfoEntry::mutable_runtime_env_info() {
  ::mcs::rpc::RuntimeEnvInfo* _msg = _internal_mutable_runtime_env_info();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.runtime_env_info)
  return _msg;
}
inline void TaskInfoEntry::set_allocated_runtime_env_info(::mcs::rpc::RuntimeEnvInfo* runtime_env_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info_);
  }
  if (runtime_env_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_env_info));
    if (message_arena != submessage_arena) {
      runtime_env_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime_env_info, submessage_arena);
    }
    
  } else {
    
  }
  runtime_env_info_ = runtime_env_info;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.runtime_env_info)
}

// optional bytes node_id = 24;
inline bool TaskInfoEntry::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TaskInfoEntry::has_node_id() const {
  return _internal_has_node_id();
}
inline void TaskInfoEntry::clear_node_id() {
  node_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaskInfoEntry::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfoEntry::set_node_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.node_id)
}
inline std::string* TaskInfoEntry::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.node_id)
  return _s;
}
inline const std::string& TaskInfoEntry::_internal_node_id() const {
  return node_id_.Get();
}
inline void TaskInfoEntry::_internal_set_node_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::_internal_mutable_node_id() {
  _has_bits_[0] |= 0x00000001u;
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.node_id)
  if (!_internal_has_node_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return node_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfoEntry::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.node_id)
}

// optional bytes actor_id = 25;
inline bool TaskInfoEntry::_internal_has_actor_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TaskInfoEntry::has_actor_id() const {
  return _internal_has_actor_id();
}
inline void TaskInfoEntry::clear_actor_id() {
  actor_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TaskInfoEntry::actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskInfoEntry.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfoEntry::set_actor_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskInfoEntry.actor_id)
}
inline std::string* TaskInfoEntry::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskInfoEntry.actor_id)
  return _s;
}
inline const std::string& TaskInfoEntry::_internal_actor_id() const {
  return actor_id_.Get();
}
inline void TaskInfoEntry::_internal_set_actor_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::_internal_mutable_actor_id() {
  _has_bits_[0] |= 0x00000002u;
  return actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskInfoEntry::release_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskInfoEntry.actor_id)
  if (!_internal_has_actor_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return actor_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskInfoEntry::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskInfoEntry.actor_id)
}

// -------------------------------------------------------------------

// Bundle_BundleIdentifier

// bytes placement_group_id = 1;
inline void Bundle_BundleIdentifier::clear_placement_group_id() {
  placement_group_id_.ClearToEmpty();
}
inline const std::string& Bundle_BundleIdentifier::placement_group_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Bundle.BundleIdentifier.placement_group_id)
  return _internal_placement_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Bundle_BundleIdentifier::set_placement_group_id(ArgT0&& arg0, ArgT... args) {
 
 placement_group_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.Bundle.BundleIdentifier.placement_group_id)
}
inline std::string* Bundle_BundleIdentifier::mutable_placement_group_id() {
  std::string* _s = _internal_mutable_placement_group_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.Bundle.BundleIdentifier.placement_group_id)
  return _s;
}
inline const std::string& Bundle_BundleIdentifier::_internal_placement_group_id() const {
  return placement_group_id_.Get();
}
inline void Bundle_BundleIdentifier::_internal_set_placement_group_id(const std::string& value) {
  
  placement_group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Bundle_BundleIdentifier::_internal_mutable_placement_group_id() {
  
  return placement_group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Bundle_BundleIdentifier::release_placement_group_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.Bundle.BundleIdentifier.placement_group_id)
  return placement_group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Bundle_BundleIdentifier::set_allocated_placement_group_id(std::string* placement_group_id) {
  if (placement_group_id != nullptr) {
    
  } else {
    
  }
  placement_group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), placement_group_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.Bundle.BundleIdentifier.placement_group_id)
}

// int32 bundle_index = 2;
inline void Bundle_BundleIdentifier::clear_bundle_index() {
  bundle_index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bundle_BundleIdentifier::_internal_bundle_index() const {
  return bundle_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bundle_BundleIdentifier::bundle_index() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Bundle.BundleIdentifier.bundle_index)
  return _internal_bundle_index();
}
inline void Bundle_BundleIdentifier::_internal_set_bundle_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  bundle_index_ = value;
}
inline void Bundle_BundleIdentifier::set_bundle_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bundle_index(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.Bundle.BundleIdentifier.bundle_index)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Bundle

// .mcs.rpc.Bundle.BundleIdentifier bundle_id = 1;
inline bool Bundle::_internal_has_bundle_id() const {
  return this != internal_default_instance() && bundle_id_ != nullptr;
}
inline bool Bundle::has_bundle_id() const {
  return _internal_has_bundle_id();
}
inline void Bundle::clear_bundle_id() {
  if (GetArenaForAllocation() == nullptr && bundle_id_ != nullptr) {
    delete bundle_id_;
  }
  bundle_id_ = nullptr;
}
inline const ::mcs::rpc::Bundle_BundleIdentifier& Bundle::_internal_bundle_id() const {
  const ::mcs::rpc::Bundle_BundleIdentifier* p = bundle_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::Bundle_BundleIdentifier&>(
      ::mcs::rpc::_Bundle_BundleIdentifier_default_instance_);
}
inline const ::mcs::rpc::Bundle_BundleIdentifier& Bundle::bundle_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Bundle.bundle_id)
  return _internal_bundle_id();
}
inline void Bundle::unsafe_arena_set_allocated_bundle_id(
    ::mcs::rpc::Bundle_BundleIdentifier* bundle_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bundle_id_);
  }
  bundle_id_ = bundle_id;
  if (bundle_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.Bundle.bundle_id)
}
inline ::mcs::rpc::Bundle_BundleIdentifier* Bundle::release_bundle_id() {
  
  ::mcs::rpc::Bundle_BundleIdentifier* temp = bundle_id_;
  bundle_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::Bundle_BundleIdentifier* Bundle::unsafe_arena_release_bundle_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.Bundle.bundle_id)
  
  ::mcs::rpc::Bundle_BundleIdentifier* temp = bundle_id_;
  bundle_id_ = nullptr;
  return temp;
}
inline ::mcs::rpc::Bundle_BundleIdentifier* Bundle::_internal_mutable_bundle_id() {
  
  if (bundle_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::Bundle_BundleIdentifier>(GetArenaForAllocation());
    bundle_id_ = p;
  }
  return bundle_id_;
}
inline ::mcs::rpc::Bundle_BundleIdentifier* Bundle::mutable_bundle_id() {
  ::mcs::rpc::Bundle_BundleIdentifier* _msg = _internal_mutable_bundle_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.Bundle.bundle_id)
  return _msg;
}
inline void Bundle::set_allocated_bundle_id(::mcs::rpc::Bundle_BundleIdentifier* bundle_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bundle_id_;
  }
  if (bundle_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::Bundle_BundleIdentifier>::GetOwningArena(bundle_id);
    if (message_arena != submessage_arena) {
      bundle_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bundle_id, submessage_arena);
    }
    
  } else {
    
  }
  bundle_id_ = bundle_id;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.Bundle.bundle_id)
}

// map<string, double> unit_resources = 2;
inline int Bundle::_internal_unit_resources_size() const {
  return unit_resources_.size();
}
inline int Bundle::unit_resources_size() const {
  return _internal_unit_resources_size();
}
inline void Bundle::clear_unit_resources() {
  unit_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Bundle::_internal_unit_resources() const {
  return unit_resources_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Bundle::unit_resources() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.Bundle.unit_resources)
  return _internal_unit_resources();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Bundle::_internal_mutable_unit_resources() {
  return unit_resources_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Bundle::mutable_unit_resources() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.Bundle.unit_resources)
  return _internal_mutable_unit_resources();
}

// bytes node_id = 3;
inline void Bundle::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& Bundle::node_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Bundle.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Bundle::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.Bundle.node_id)
}
inline std::string* Bundle::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.Bundle.node_id)
  return _s;
}
inline const std::string& Bundle::_internal_node_id() const {
  return node_id_.Get();
}
inline void Bundle::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Bundle::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Bundle::release_node_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.Bundle.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Bundle::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.Bundle.node_id)
}

// -------------------------------------------------------------------

// PlacementGroupSpec

// bytes placement_group_id = 1;
inline void PlacementGroupSpec::clear_placement_group_id() {
  placement_group_id_.ClearToEmpty();
}
inline const std::string& PlacementGroupSpec::placement_group_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.placement_group_id)
  return _internal_placement_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupSpec::set_placement_group_id(ArgT0&& arg0, ArgT... args) {
 
 placement_group_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.placement_group_id)
}
inline std::string* PlacementGroupSpec::mutable_placement_group_id() {
  std::string* _s = _internal_mutable_placement_group_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupSpec.placement_group_id)
  return _s;
}
inline const std::string& PlacementGroupSpec::_internal_placement_group_id() const {
  return placement_group_id_.Get();
}
inline void PlacementGroupSpec::_internal_set_placement_group_id(const std::string& value) {
  
  placement_group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::_internal_mutable_placement_group_id() {
  
  return placement_group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::release_placement_group_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupSpec.placement_group_id)
  return placement_group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupSpec::set_allocated_placement_group_id(std::string* placement_group_id) {
  if (placement_group_id != nullptr) {
    
  } else {
    
  }
  placement_group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), placement_group_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupSpec.placement_group_id)
}

// string name = 2;
inline void PlacementGroupSpec::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PlacementGroupSpec::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupSpec::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.name)
}
inline std::string* PlacementGroupSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupSpec.name)
  return _s;
}
inline const std::string& PlacementGroupSpec::_internal_name() const {
  return name_.Get();
}
inline void PlacementGroupSpec::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupSpec.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupSpec.name)
}

// repeated .mcs.rpc.Bundle bundles = 3;
inline int PlacementGroupSpec::_internal_bundles_size() const {
  return bundles_.size();
}
inline int PlacementGroupSpec::bundles_size() const {
  return _internal_bundles_size();
}
inline void PlacementGroupSpec::clear_bundles() {
  bundles_.Clear();
}
inline ::mcs::rpc::Bundle* PlacementGroupSpec::mutable_bundles(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupSpec.bundles)
  return bundles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >*
PlacementGroupSpec::mutable_bundles() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.PlacementGroupSpec.bundles)
  return &bundles_;
}
inline const ::mcs::rpc::Bundle& PlacementGroupSpec::_internal_bundles(int index) const {
  return bundles_.Get(index);
}
inline const ::mcs::rpc::Bundle& PlacementGroupSpec::bundles(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.bundles)
  return _internal_bundles(index);
}
inline ::mcs::rpc::Bundle* PlacementGroupSpec::_internal_add_bundles() {
  return bundles_.Add();
}
inline ::mcs::rpc::Bundle* PlacementGroupSpec::add_bundles() {
  ::mcs::rpc::Bundle* _add = _internal_add_bundles();
  // @@protoc_insertion_point(field_add:mcs.rpc.PlacementGroupSpec.bundles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Bundle >&
PlacementGroupSpec::bundles() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.PlacementGroupSpec.bundles)
  return bundles_;
}

// .mcs.rpc.PlacementStrategy strategy = 4;
inline void PlacementGroupSpec::clear_strategy() {
  strategy_ = 0;
}
inline ::mcs::rpc::PlacementStrategy PlacementGroupSpec::_internal_strategy() const {
  return static_cast< ::mcs::rpc::PlacementStrategy >(strategy_);
}
inline ::mcs::rpc::PlacementStrategy PlacementGroupSpec::strategy() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.strategy)
  return _internal_strategy();
}
inline void PlacementGroupSpec::_internal_set_strategy(::mcs::rpc::PlacementStrategy value) {
  
  strategy_ = value;
}
inline void PlacementGroupSpec::set_strategy(::mcs::rpc::PlacementStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.strategy)
}

// bytes creator_job_id = 5;
inline void PlacementGroupSpec::clear_creator_job_id() {
  creator_job_id_.ClearToEmpty();
}
inline const std::string& PlacementGroupSpec::creator_job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.creator_job_id)
  return _internal_creator_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupSpec::set_creator_job_id(ArgT0&& arg0, ArgT... args) {
 
 creator_job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.creator_job_id)
}
inline std::string* PlacementGroupSpec::mutable_creator_job_id() {
  std::string* _s = _internal_mutable_creator_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupSpec.creator_job_id)
  return _s;
}
inline const std::string& PlacementGroupSpec::_internal_creator_job_id() const {
  return creator_job_id_.Get();
}
inline void PlacementGroupSpec::_internal_set_creator_job_id(const std::string& value) {
  
  creator_job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::_internal_mutable_creator_job_id() {
  
  return creator_job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::release_creator_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupSpec.creator_job_id)
  return creator_job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupSpec::set_allocated_creator_job_id(std::string* creator_job_id) {
  if (creator_job_id != nullptr) {
    
  } else {
    
  }
  creator_job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator_job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupSpec.creator_job_id)
}

// bytes creator_actor_id = 6;
inline void PlacementGroupSpec::clear_creator_actor_id() {
  creator_actor_id_.ClearToEmpty();
}
inline const std::string& PlacementGroupSpec::creator_actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.creator_actor_id)
  return _internal_creator_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlacementGroupSpec::set_creator_actor_id(ArgT0&& arg0, ArgT... args) {
 
 creator_actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.creator_actor_id)
}
inline std::string* PlacementGroupSpec::mutable_creator_actor_id() {
  std::string* _s = _internal_mutable_creator_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.PlacementGroupSpec.creator_actor_id)
  return _s;
}
inline const std::string& PlacementGroupSpec::_internal_creator_actor_id() const {
  return creator_actor_id_.Get();
}
inline void PlacementGroupSpec::_internal_set_creator_actor_id(const std::string& value) {
  
  creator_actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::_internal_mutable_creator_actor_id() {
  
  return creator_actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PlacementGroupSpec::release_creator_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.PlacementGroupSpec.creator_actor_id)
  return creator_actor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PlacementGroupSpec::set_allocated_creator_actor_id(std::string* creator_actor_id) {
  if (creator_actor_id != nullptr) {
    
  } else {
    
  }
  creator_actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator_actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.PlacementGroupSpec.creator_actor_id)
}

// bool creator_job_dead = 7;
inline void PlacementGroupSpec::clear_creator_job_dead() {
  creator_job_dead_ = false;
}
inline bool PlacementGroupSpec::_internal_creator_job_dead() const {
  return creator_job_dead_;
}
inline bool PlacementGroupSpec::creator_job_dead() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.creator_job_dead)
  return _internal_creator_job_dead();
}
inline void PlacementGroupSpec::_internal_set_creator_job_dead(bool value) {
  
  creator_job_dead_ = value;
}
inline void PlacementGroupSpec::set_creator_job_dead(bool value) {
  _internal_set_creator_job_dead(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.creator_job_dead)
}

// bool creator_actor_dead = 8;
inline void PlacementGroupSpec::clear_creator_actor_dead() {
  creator_actor_dead_ = false;
}
inline bool PlacementGroupSpec::_internal_creator_actor_dead() const {
  return creator_actor_dead_;
}
inline bool PlacementGroupSpec::creator_actor_dead() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.creator_actor_dead)
  return _internal_creator_actor_dead();
}
inline void PlacementGroupSpec::_internal_set_creator_actor_dead(bool value) {
  
  creator_actor_dead_ = value;
}
inline void PlacementGroupSpec::set_creator_actor_dead(bool value) {
  _internal_set_creator_actor_dead(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.creator_actor_dead)
}

// bool is_detached = 9;
inline void PlacementGroupSpec::clear_is_detached() {
  is_detached_ = false;
}
inline bool PlacementGroupSpec::_internal_is_detached() const {
  return is_detached_;
}
inline bool PlacementGroupSpec::is_detached() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.is_detached)
  return _internal_is_detached();
}
inline void PlacementGroupSpec::_internal_set_is_detached(bool value) {
  
  is_detached_ = value;
}
inline void PlacementGroupSpec::set_is_detached(bool value) {
  _internal_set_is_detached(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.is_detached)
}

// double max_cpu_fraction_per_node = 10;
inline void PlacementGroupSpec::clear_max_cpu_fraction_per_node() {
  max_cpu_fraction_per_node_ = 0;
}
inline double PlacementGroupSpec::_internal_max_cpu_fraction_per_node() const {
  return max_cpu_fraction_per_node_;
}
inline double PlacementGroupSpec::max_cpu_fraction_per_node() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.PlacementGroupSpec.max_cpu_fraction_per_node)
  return _internal_max_cpu_fraction_per_node();
}
inline void PlacementGroupSpec::_internal_set_max_cpu_fraction_per_node(double value) {
  
  max_cpu_fraction_per_node_ = value;
}
inline void PlacementGroupSpec::set_max_cpu_fraction_per_node(double value) {
  _internal_set_max_cpu_fraction_per_node(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.PlacementGroupSpec.max_cpu_fraction_per_node)
}

// -------------------------------------------------------------------

// ObjectReference

// bytes object_id = 1;
inline void ObjectReference::clear_object_id() {
  object_id_.ClearToEmpty();
}
inline const std::string& ObjectReference::object_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReference.object_id)
  return _internal_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectReference::set_object_id(ArgT0&& arg0, ArgT... args) {
 
 object_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectReference.object_id)
}
inline std::string* ObjectReference::mutable_object_id() {
  std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReference.object_id)
  return _s;
}
inline const std::string& ObjectReference::_internal_object_id() const {
  return object_id_.Get();
}
inline void ObjectReference::_internal_set_object_id(const std::string& value) {
  
  object_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectReference::_internal_mutable_object_id() {
  
  return object_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectReference::release_object_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ObjectReference.object_id)
  return object_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectReference::set_allocated_object_id(std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), object_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ObjectReference.object_id)
}

// .mcs.rpc.Address owner_address = 2;
inline bool ObjectReference::_internal_has_owner_address() const {
  return this != internal_default_instance() && owner_address_ != nullptr;
}
inline bool ObjectReference::has_owner_address() const {
  return _internal_has_owner_address();
}
inline void ObjectReference::clear_owner_address() {
  if (GetArenaForAllocation() == nullptr && owner_address_ != nullptr) {
    delete owner_address_;
  }
  owner_address_ = nullptr;
}
inline const ::mcs::rpc::Address& ObjectReference::_internal_owner_address() const {
  const ::mcs::rpc::Address* p = owner_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::Address&>(
      ::mcs::rpc::_Address_default_instance_);
}
inline const ::mcs::rpc::Address& ObjectReference::owner_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReference.owner_address)
  return _internal_owner_address();
}
inline void ObjectReference::unsafe_arena_set_allocated_owner_address(
    ::mcs::rpc::Address* owner_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_address_);
  }
  owner_address_ = owner_address;
  if (owner_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ObjectReference.owner_address)
}
inline ::mcs::rpc::Address* ObjectReference::release_owner_address() {
  
  ::mcs::rpc::Address* temp = owner_address_;
  owner_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::Address* ObjectReference::unsafe_arena_release_owner_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ObjectReference.owner_address)
  
  ::mcs::rpc::Address* temp = owner_address_;
  owner_address_ = nullptr;
  return temp;
}
inline ::mcs::rpc::Address* ObjectReference::_internal_mutable_owner_address() {
  
  if (owner_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::Address>(GetArenaForAllocation());
    owner_address_ = p;
  }
  return owner_address_;
}
inline ::mcs::rpc::Address* ObjectReference::mutable_owner_address() {
  ::mcs::rpc::Address* _msg = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReference.owner_address)
  return _msg;
}
inline void ObjectReference::set_allocated_owner_address(::mcs::rpc::Address* owner_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_address_;
  }
  if (owner_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::Address>::GetOwningArena(owner_address);
    if (message_arena != submessage_arena) {
      owner_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_address, submessage_arena);
    }
    
  } else {
    
  }
  owner_address_ = owner_address;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ObjectReference.owner_address)
}

// string call_site = 3;
inline void ObjectReference::clear_call_site() {
  call_site_.ClearToEmpty();
}
inline const std::string& ObjectReference::call_site() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReference.call_site)
  return _internal_call_site();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectReference::set_call_site(ArgT0&& arg0, ArgT... args) {
 
 call_site_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectReference.call_site)
}
inline std::string* ObjectReference::mutable_call_site() {
  std::string* _s = _internal_mutable_call_site();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReference.call_site)
  return _s;
}
inline const std::string& ObjectReference::_internal_call_site() const {
  return call_site_.Get();
}
inline void ObjectReference::_internal_set_call_site(const std::string& value) {
  
  call_site_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectReference::_internal_mutable_call_site() {
  
  return call_site_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectReference::release_call_site() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ObjectReference.call_site)
  return call_site_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectReference::set_allocated_call_site(std::string* call_site) {
  if (call_site != nullptr) {
    
  } else {
    
  }
  call_site_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), call_site,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ObjectReference.call_site)
}

// -------------------------------------------------------------------

// ObjectReferenceCount

// .mcs.rpc.ObjectReference reference = 1;
inline bool ObjectReferenceCount::_internal_has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline bool ObjectReferenceCount::has_reference() const {
  return _internal_has_reference();
}
inline void ObjectReferenceCount::clear_reference() {
  if (GetArenaForAllocation() == nullptr && reference_ != nullptr) {
    delete reference_;
  }
  reference_ = nullptr;
}
inline const ::mcs::rpc::ObjectReference& ObjectReferenceCount::_internal_reference() const {
  const ::mcs::rpc::ObjectReference* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ObjectReference&>(
      ::mcs::rpc::_ObjectReference_default_instance_);
}
inline const ::mcs::rpc::ObjectReference& ObjectReferenceCount::reference() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReferenceCount.reference)
  return _internal_reference();
}
inline void ObjectReferenceCount::unsafe_arena_set_allocated_reference(
    ::mcs::rpc::ObjectReference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.ObjectReferenceCount.reference)
}
inline ::mcs::rpc::ObjectReference* ObjectReferenceCount::release_reference() {
  
  ::mcs::rpc::ObjectReference* temp = reference_;
  reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ObjectReference* ObjectReferenceCount::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ObjectReferenceCount.reference)
  
  ::mcs::rpc::ObjectReference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ObjectReference* ObjectReferenceCount::_internal_mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ObjectReference>(GetArenaForAllocation());
    reference_ = p;
  }
  return reference_;
}
inline ::mcs::rpc::ObjectReference* ObjectReferenceCount::mutable_reference() {
  ::mcs::rpc::ObjectReference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReferenceCount.reference)
  return _msg;
}
inline void ObjectReferenceCount::set_allocated_reference(::mcs::rpc::ObjectReference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::ObjectReference>::GetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ObjectReferenceCount.reference)
}

// bool has_local_ref = 2;
inline void ObjectReferenceCount::clear_has_local_ref() {
  has_local_ref_ = false;
}
inline bool ObjectReferenceCount::_internal_has_local_ref() const {
  return has_local_ref_;
}
inline bool ObjectReferenceCount::has_local_ref() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReferenceCount.has_local_ref)
  return _internal_has_local_ref();
}
inline void ObjectReferenceCount::_internal_set_has_local_ref(bool value) {
  
  has_local_ref_ = value;
}
inline void ObjectReferenceCount::set_has_local_ref(bool value) {
  _internal_set_has_local_ref(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectReferenceCount.has_local_ref)
}

// repeated .mcs.rpc.Address borrowers = 3;
inline int ObjectReferenceCount::_internal_borrowers_size() const {
  return borrowers_.size();
}
inline int ObjectReferenceCount::borrowers_size() const {
  return _internal_borrowers_size();
}
inline void ObjectReferenceCount::clear_borrowers() {
  borrowers_.Clear();
}
inline ::mcs::rpc::Address* ObjectReferenceCount::mutable_borrowers(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReferenceCount.borrowers)
  return borrowers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Address >*
ObjectReferenceCount::mutable_borrowers() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ObjectReferenceCount.borrowers)
  return &borrowers_;
}
inline const ::mcs::rpc::Address& ObjectReferenceCount::_internal_borrowers(int index) const {
  return borrowers_.Get(index);
}
inline const ::mcs::rpc::Address& ObjectReferenceCount::borrowers(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReferenceCount.borrowers)
  return _internal_borrowers(index);
}
inline ::mcs::rpc::Address* ObjectReferenceCount::_internal_add_borrowers() {
  return borrowers_.Add();
}
inline ::mcs::rpc::Address* ObjectReferenceCount::add_borrowers() {
  ::mcs::rpc::Address* _add = _internal_add_borrowers();
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectReferenceCount.borrowers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::Address >&
ObjectReferenceCount::borrowers() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ObjectReferenceCount.borrowers)
  return borrowers_;
}

// repeated .mcs.rpc.ObjectReference stored_in_objects = 4;
inline int ObjectReferenceCount::_internal_stored_in_objects_size() const {
  return stored_in_objects_.size();
}
inline int ObjectReferenceCount::stored_in_objects_size() const {
  return _internal_stored_in_objects_size();
}
inline void ObjectReferenceCount::clear_stored_in_objects() {
  stored_in_objects_.Clear();
}
inline ::mcs::rpc::ObjectReference* ObjectReferenceCount::mutable_stored_in_objects(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReferenceCount.stored_in_objects)
  return stored_in_objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >*
ObjectReferenceCount::mutable_stored_in_objects() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ObjectReferenceCount.stored_in_objects)
  return &stored_in_objects_;
}
inline const ::mcs::rpc::ObjectReference& ObjectReferenceCount::_internal_stored_in_objects(int index) const {
  return stored_in_objects_.Get(index);
}
inline const ::mcs::rpc::ObjectReference& ObjectReferenceCount::stored_in_objects(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReferenceCount.stored_in_objects)
  return _internal_stored_in_objects(index);
}
inline ::mcs::rpc::ObjectReference* ObjectReferenceCount::_internal_add_stored_in_objects() {
  return stored_in_objects_.Add();
}
inline ::mcs::rpc::ObjectReference* ObjectReferenceCount::add_stored_in_objects() {
  ::mcs::rpc::ObjectReference* _add = _internal_add_stored_in_objects();
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectReferenceCount.stored_in_objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >&
ObjectReferenceCount::stored_in_objects() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ObjectReferenceCount.stored_in_objects)
  return stored_in_objects_;
}

// repeated bytes contained_in_borrowed_ids = 5;
inline int ObjectReferenceCount::_internal_contained_in_borrowed_ids_size() const {
  return contained_in_borrowed_ids_.size();
}
inline int ObjectReferenceCount::contained_in_borrowed_ids_size() const {
  return _internal_contained_in_borrowed_ids_size();
}
inline void ObjectReferenceCount::clear_contained_in_borrowed_ids() {
  contained_in_borrowed_ids_.Clear();
}
inline std::string* ObjectReferenceCount::add_contained_in_borrowed_ids() {
  std::string* _s = _internal_add_contained_in_borrowed_ids();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
  return _s;
}
inline const std::string& ObjectReferenceCount::_internal_contained_in_borrowed_ids(int index) const {
  return contained_in_borrowed_ids_.Get(index);
}
inline const std::string& ObjectReferenceCount::contained_in_borrowed_ids(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
  return _internal_contained_in_borrowed_ids(index);
}
inline std::string* ObjectReferenceCount::mutable_contained_in_borrowed_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
  return contained_in_borrowed_ids_.Mutable(index);
}
inline void ObjectReferenceCount::set_contained_in_borrowed_ids(int index, const std::string& value) {
  contained_in_borrowed_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline void ObjectReferenceCount::set_contained_in_borrowed_ids(int index, std::string&& value) {
  contained_in_borrowed_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline void ObjectReferenceCount::set_contained_in_borrowed_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contained_in_borrowed_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline void ObjectReferenceCount::set_contained_in_borrowed_ids(int index, const void* value, size_t size) {
  contained_in_borrowed_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline std::string* ObjectReferenceCount::_internal_add_contained_in_borrowed_ids() {
  return contained_in_borrowed_ids_.Add();
}
inline void ObjectReferenceCount::add_contained_in_borrowed_ids(const std::string& value) {
  contained_in_borrowed_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline void ObjectReferenceCount::add_contained_in_borrowed_ids(std::string&& value) {
  contained_in_borrowed_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline void ObjectReferenceCount::add_contained_in_borrowed_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contained_in_borrowed_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline void ObjectReferenceCount::add_contained_in_borrowed_ids(const void* value, size_t size) {
  contained_in_borrowed_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectReferenceCount::contained_in_borrowed_ids() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
  return contained_in_borrowed_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectReferenceCount::mutable_contained_in_borrowed_ids() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ObjectReferenceCount.contained_in_borrowed_ids)
  return &contained_in_borrowed_ids_;
}

// repeated bytes contains = 6;
inline int ObjectReferenceCount::_internal_contains_size() const {
  return contains_.size();
}
inline int ObjectReferenceCount::contains_size() const {
  return _internal_contains_size();
}
inline void ObjectReferenceCount::clear_contains() {
  contains_.Clear();
}
inline std::string* ObjectReferenceCount::add_contains() {
  std::string* _s = _internal_add_contains();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.ObjectReferenceCount.contains)
  return _s;
}
inline const std::string& ObjectReferenceCount::_internal_contains(int index) const {
  return contains_.Get(index);
}
inline const std::string& ObjectReferenceCount::contains(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectReferenceCount.contains)
  return _internal_contains(index);
}
inline std::string* ObjectReferenceCount::mutable_contains(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectReferenceCount.contains)
  return contains_.Mutable(index);
}
inline void ObjectReferenceCount::set_contains(int index, const std::string& value) {
  contains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectReferenceCount.contains)
}
inline void ObjectReferenceCount::set_contains(int index, std::string&& value) {
  contains_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectReferenceCount.contains)
}
inline void ObjectReferenceCount::set_contains(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.ObjectReferenceCount.contains)
}
inline void ObjectReferenceCount::set_contains(int index, const void* value, size_t size) {
  contains_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.ObjectReferenceCount.contains)
}
inline std::string* ObjectReferenceCount::_internal_add_contains() {
  return contains_.Add();
}
inline void ObjectReferenceCount::add_contains(const std::string& value) {
  contains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectReferenceCount.contains)
}
inline void ObjectReferenceCount::add_contains(std::string&& value) {
  contains_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectReferenceCount.contains)
}
inline void ObjectReferenceCount::add_contains(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.ObjectReferenceCount.contains)
}
inline void ObjectReferenceCount::add_contains(const void* value, size_t size) {
  contains_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.ObjectReferenceCount.contains)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectReferenceCount::contains() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ObjectReferenceCount.contains)
  return contains_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectReferenceCount::mutable_contains() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ObjectReferenceCount.contains)
  return &contains_;
}

// -------------------------------------------------------------------

// TaskArg

// .mcs.rpc.ObjectReference object_ref = 1;
inline bool TaskArg::_internal_has_object_ref() const {
  return this != internal_default_instance() && object_ref_ != nullptr;
}
inline bool TaskArg::has_object_ref() const {
  return _internal_has_object_ref();
}
inline void TaskArg::clear_object_ref() {
  if (GetArenaForAllocation() == nullptr && object_ref_ != nullptr) {
    delete object_ref_;
  }
  object_ref_ = nullptr;
}
inline const ::mcs::rpc::ObjectReference& TaskArg::_internal_object_ref() const {
  const ::mcs::rpc::ObjectReference* p = object_ref_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::ObjectReference&>(
      ::mcs::rpc::_ObjectReference_default_instance_);
}
inline const ::mcs::rpc::ObjectReference& TaskArg::object_ref() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskArg.object_ref)
  return _internal_object_ref();
}
inline void TaskArg::unsafe_arena_set_allocated_object_ref(
    ::mcs::rpc::ObjectReference* object_ref) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_ref_);
  }
  object_ref_ = object_ref;
  if (object_ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.TaskArg.object_ref)
}
inline ::mcs::rpc::ObjectReference* TaskArg::release_object_ref() {
  
  ::mcs::rpc::ObjectReference* temp = object_ref_;
  object_ref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::ObjectReference* TaskArg::unsafe_arena_release_object_ref() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskArg.object_ref)
  
  ::mcs::rpc::ObjectReference* temp = object_ref_;
  object_ref_ = nullptr;
  return temp;
}
inline ::mcs::rpc::ObjectReference* TaskArg::_internal_mutable_object_ref() {
  
  if (object_ref_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::ObjectReference>(GetArenaForAllocation());
    object_ref_ = p;
  }
  return object_ref_;
}
inline ::mcs::rpc::ObjectReference* TaskArg::mutable_object_ref() {
  ::mcs::rpc::ObjectReference* _msg = _internal_mutable_object_ref();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskArg.object_ref)
  return _msg;
}
inline void TaskArg::set_allocated_object_ref(::mcs::rpc::ObjectReference* object_ref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_ref_;
  }
  if (object_ref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::ObjectReference>::GetOwningArena(object_ref);
    if (message_arena != submessage_arena) {
      object_ref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_ref, submessage_arena);
    }
    
  } else {
    
  }
  object_ref_ = object_ref;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskArg.object_ref)
}

// bytes data = 2;
inline void TaskArg::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& TaskArg::data() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskArg.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskArg::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskArg.data)
}
inline std::string* TaskArg::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskArg.data)
  return _s;
}
inline const std::string& TaskArg::_internal_data() const {
  return data_.Get();
}
inline void TaskArg::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskArg::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskArg::release_data() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskArg.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskArg::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskArg.data)
}

// bytes metadata = 3;
inline void TaskArg::clear_metadata() {
  metadata_.ClearToEmpty();
}
inline const std::string& TaskArg::metadata() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskArg.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskArg::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 metadata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.TaskArg.metadata)
}
inline std::string* TaskArg::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskArg.metadata)
  return _s;
}
inline const std::string& TaskArg::_internal_metadata() const {
  return metadata_.Get();
}
inline void TaskArg::_internal_set_metadata(const std::string& value) {
  
  metadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskArg::_internal_mutable_metadata() {
  
  return metadata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskArg::release_metadata() {
  // @@protoc_insertion_point(field_release:mcs.rpc.TaskArg.metadata)
  return metadata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskArg::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  metadata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.TaskArg.metadata)
}

// repeated .mcs.rpc.ObjectReference nested_inlined_refs = 4;
inline int TaskArg::_internal_nested_inlined_refs_size() const {
  return nested_inlined_refs_.size();
}
inline int TaskArg::nested_inlined_refs_size() const {
  return _internal_nested_inlined_refs_size();
}
inline void TaskArg::clear_nested_inlined_refs() {
  nested_inlined_refs_.Clear();
}
inline ::mcs::rpc::ObjectReference* TaskArg::mutable_nested_inlined_refs(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.TaskArg.nested_inlined_refs)
  return nested_inlined_refs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >*
TaskArg::mutable_nested_inlined_refs() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.TaskArg.nested_inlined_refs)
  return &nested_inlined_refs_;
}
inline const ::mcs::rpc::ObjectReference& TaskArg::_internal_nested_inlined_refs(int index) const {
  return nested_inlined_refs_.Get(index);
}
inline const ::mcs::rpc::ObjectReference& TaskArg::nested_inlined_refs(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.TaskArg.nested_inlined_refs)
  return _internal_nested_inlined_refs(index);
}
inline ::mcs::rpc::ObjectReference* TaskArg::_internal_add_nested_inlined_refs() {
  return nested_inlined_refs_.Add();
}
inline ::mcs::rpc::ObjectReference* TaskArg::add_nested_inlined_refs() {
  ::mcs::rpc::ObjectReference* _add = _internal_add_nested_inlined_refs();
  // @@protoc_insertion_point(field_add:mcs.rpc.TaskArg.nested_inlined_refs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectReference >&
TaskArg::nested_inlined_refs() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.TaskArg.nested_inlined_refs)
  return nested_inlined_refs_;
}

// -------------------------------------------------------------------

// ActorCreationTaskSpec

// bytes actor_id = 2;
inline void ActorCreationTaskSpec::clear_actor_id() {
  actor_id_.ClearToEmpty();
}
inline const std::string& ActorCreationTaskSpec::actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorCreationTaskSpec::set_actor_id(ArgT0&& arg0, ArgT... args) {
 
 actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.actor_id)
}
inline std::string* ActorCreationTaskSpec::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorCreationTaskSpec.actor_id)
  return _s;
}
inline const std::string& ActorCreationTaskSpec::_internal_actor_id() const {
  return actor_id_.Get();
}
inline void ActorCreationTaskSpec::_internal_set_actor_id(const std::string& value) {
  
  actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::_internal_mutable_actor_id() {
  
  return actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::release_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorCreationTaskSpec.actor_id)
  return actor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorCreationTaskSpec::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorCreationTaskSpec.actor_id)
}

// int64 max_actor_restarts = 3;
inline void ActorCreationTaskSpec::clear_max_actor_restarts() {
  max_actor_restarts_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ActorCreationTaskSpec::_internal_max_actor_restarts() const {
  return max_actor_restarts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ActorCreationTaskSpec::max_actor_restarts() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.max_actor_restarts)
  return _internal_max_actor_restarts();
}
inline void ActorCreationTaskSpec::_internal_set_max_actor_restarts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  max_actor_restarts_ = value;
}
inline void ActorCreationTaskSpec::set_max_actor_restarts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_actor_restarts(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.max_actor_restarts)
}

// int64 max_task_retries = 4;
inline void ActorCreationTaskSpec::clear_max_task_retries() {
  max_task_retries_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ActorCreationTaskSpec::_internal_max_task_retries() const {
  return max_task_retries_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ActorCreationTaskSpec::max_task_retries() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.max_task_retries)
  return _internal_max_task_retries();
}
inline void ActorCreationTaskSpec::_internal_set_max_task_retries(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  max_task_retries_ = value;
}
inline void ActorCreationTaskSpec::set_max_task_retries(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_task_retries(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.max_task_retries)
}

// repeated string dynamic_worker_options = 5;
inline int ActorCreationTaskSpec::_internal_dynamic_worker_options_size() const {
  return dynamic_worker_options_.size();
}
inline int ActorCreationTaskSpec::dynamic_worker_options_size() const {
  return _internal_dynamic_worker_options_size();
}
inline void ActorCreationTaskSpec::clear_dynamic_worker_options() {
  dynamic_worker_options_.Clear();
}
inline std::string* ActorCreationTaskSpec::add_dynamic_worker_options() {
  std::string* _s = _internal_add_dynamic_worker_options();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
  return _s;
}
inline const std::string& ActorCreationTaskSpec::_internal_dynamic_worker_options(int index) const {
  return dynamic_worker_options_.Get(index);
}
inline const std::string& ActorCreationTaskSpec::dynamic_worker_options(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
  return _internal_dynamic_worker_options(index);
}
inline std::string* ActorCreationTaskSpec::mutable_dynamic_worker_options(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
  return dynamic_worker_options_.Mutable(index);
}
inline void ActorCreationTaskSpec::set_dynamic_worker_options(int index, const std::string& value) {
  dynamic_worker_options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline void ActorCreationTaskSpec::set_dynamic_worker_options(int index, std::string&& value) {
  dynamic_worker_options_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline void ActorCreationTaskSpec::set_dynamic_worker_options(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dynamic_worker_options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline void ActorCreationTaskSpec::set_dynamic_worker_options(int index, const char* value, size_t size) {
  dynamic_worker_options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline std::string* ActorCreationTaskSpec::_internal_add_dynamic_worker_options() {
  return dynamic_worker_options_.Add();
}
inline void ActorCreationTaskSpec::add_dynamic_worker_options(const std::string& value) {
  dynamic_worker_options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline void ActorCreationTaskSpec::add_dynamic_worker_options(std::string&& value) {
  dynamic_worker_options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline void ActorCreationTaskSpec::add_dynamic_worker_options(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dynamic_worker_options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline void ActorCreationTaskSpec::add_dynamic_worker_options(const char* value, size_t size) {
  dynamic_worker_options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ActorCreationTaskSpec::dynamic_worker_options() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
  return dynamic_worker_options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ActorCreationTaskSpec::mutable_dynamic_worker_options() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ActorCreationTaskSpec.dynamic_worker_options)
  return &dynamic_worker_options_;
}

// int32 max_concurrency = 6;
inline void ActorCreationTaskSpec::clear_max_concurrency() {
  max_concurrency_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActorCreationTaskSpec::_internal_max_concurrency() const {
  return max_concurrency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActorCreationTaskSpec::max_concurrency() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.max_concurrency)
  return _internal_max_concurrency();
}
inline void ActorCreationTaskSpec::_internal_set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_concurrency_ = value;
}
inline void ActorCreationTaskSpec::set_max_concurrency(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_concurrency(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.max_concurrency)
}

// bool is_detached = 7;
inline void ActorCreationTaskSpec::clear_is_detached() {
  is_detached_ = false;
}
inline bool ActorCreationTaskSpec::_internal_is_detached() const {
  return is_detached_;
}
inline bool ActorCreationTaskSpec::is_detached() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.is_detached)
  return _internal_is_detached();
}
inline void ActorCreationTaskSpec::_internal_set_is_detached(bool value) {
  
  is_detached_ = value;
}
inline void ActorCreationTaskSpec::set_is_detached(bool value) {
  _internal_set_is_detached(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.is_detached)
}

// string name = 8;
inline void ActorCreationTaskSpec::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ActorCreationTaskSpec::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorCreationTaskSpec::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.name)
}
inline std::string* ActorCreationTaskSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorCreationTaskSpec.name)
  return _s;
}
inline const std::string& ActorCreationTaskSpec::_internal_name() const {
  return name_.Get();
}
inline void ActorCreationTaskSpec::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorCreationTaskSpec.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorCreationTaskSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorCreationTaskSpec.name)
}

// string mcs_namespace = 9;
inline void ActorCreationTaskSpec::clear_mcs_namespace() {
  mcs_namespace_.ClearToEmpty();
}
inline const std::string& ActorCreationTaskSpec::mcs_namespace() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.mcs_namespace)
  return _internal_mcs_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorCreationTaskSpec::set_mcs_namespace(ArgT0&& arg0, ArgT... args) {
 
 mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.mcs_namespace)
}
inline std::string* ActorCreationTaskSpec::mutable_mcs_namespace() {
  std::string* _s = _internal_mutable_mcs_namespace();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorCreationTaskSpec.mcs_namespace)
  return _s;
}
inline const std::string& ActorCreationTaskSpec::_internal_mcs_namespace() const {
  return mcs_namespace_.Get();
}
inline void ActorCreationTaskSpec::_internal_set_mcs_namespace(const std::string& value) {
  
  mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::_internal_mutable_mcs_namespace() {
  
  return mcs_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::release_mcs_namespace() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorCreationTaskSpec.mcs_namespace)
  return mcs_namespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorCreationTaskSpec::set_allocated_mcs_namespace(std::string* mcs_namespace) {
  if (mcs_namespace != nullptr) {
    
  } else {
    
  }
  mcs_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcs_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorCreationTaskSpec.mcs_namespace)
}

// bool is_asyncio = 10;
inline void ActorCreationTaskSpec::clear_is_asyncio() {
  is_asyncio_ = false;
}
inline bool ActorCreationTaskSpec::_internal_is_asyncio() const {
  return is_asyncio_;
}
inline bool ActorCreationTaskSpec::is_asyncio() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.is_asyncio)
  return _internal_is_asyncio();
}
inline void ActorCreationTaskSpec::_internal_set_is_asyncio(bool value) {
  
  is_asyncio_ = value;
}
inline void ActorCreationTaskSpec::set_is_asyncio(bool value) {
  _internal_set_is_asyncio(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.is_asyncio)
}

// string extension_data = 11;
inline void ActorCreationTaskSpec::clear_extension_data() {
  extension_data_.ClearToEmpty();
}
inline const std::string& ActorCreationTaskSpec::extension_data() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.extension_data)
  return _internal_extension_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorCreationTaskSpec::set_extension_data(ArgT0&& arg0, ArgT... args) {
 
 extension_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.extension_data)
}
inline std::string* ActorCreationTaskSpec::mutable_extension_data() {
  std::string* _s = _internal_mutable_extension_data();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorCreationTaskSpec.extension_data)
  return _s;
}
inline const std::string& ActorCreationTaskSpec::_internal_extension_data() const {
  return extension_data_.Get();
}
inline void ActorCreationTaskSpec::_internal_set_extension_data(const std::string& value) {
  
  extension_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::_internal_mutable_extension_data() {
  
  return extension_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::release_extension_data() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorCreationTaskSpec.extension_data)
  return extension_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorCreationTaskSpec::set_allocated_extension_data(std::string* extension_data) {
  if (extension_data != nullptr) {
    
  } else {
    
  }
  extension_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorCreationTaskSpec.extension_data)
}

// bytes serialized_actor_handle = 12;
inline void ActorCreationTaskSpec::clear_serialized_actor_handle() {
  serialized_actor_handle_.ClearToEmpty();
}
inline const std::string& ActorCreationTaskSpec::serialized_actor_handle() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.serialized_actor_handle)
  return _internal_serialized_actor_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorCreationTaskSpec::set_serialized_actor_handle(ArgT0&& arg0, ArgT... args) {
 
 serialized_actor_handle_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.serialized_actor_handle)
}
inline std::string* ActorCreationTaskSpec::mutable_serialized_actor_handle() {
  std::string* _s = _internal_mutable_serialized_actor_handle();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorCreationTaskSpec.serialized_actor_handle)
  return _s;
}
inline const std::string& ActorCreationTaskSpec::_internal_serialized_actor_handle() const {
  return serialized_actor_handle_.Get();
}
inline void ActorCreationTaskSpec::_internal_set_serialized_actor_handle(const std::string& value) {
  
  serialized_actor_handle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::_internal_mutable_serialized_actor_handle() {
  
  return serialized_actor_handle_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorCreationTaskSpec::release_serialized_actor_handle() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorCreationTaskSpec.serialized_actor_handle)
  return serialized_actor_handle_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorCreationTaskSpec::set_allocated_serialized_actor_handle(std::string* serialized_actor_handle) {
  if (serialized_actor_handle != nullptr) {
    
  } else {
    
  }
  serialized_actor_handle_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_actor_handle,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorCreationTaskSpec.serialized_actor_handle)
}

// repeated .mcs.rpc.ConcurrencyGroup concurrency_groups = 13;
inline int ActorCreationTaskSpec::_internal_concurrency_groups_size() const {
  return concurrency_groups_.size();
}
inline int ActorCreationTaskSpec::concurrency_groups_size() const {
  return _internal_concurrency_groups_size();
}
inline void ActorCreationTaskSpec::clear_concurrency_groups() {
  concurrency_groups_.Clear();
}
inline ::mcs::rpc::ConcurrencyGroup* ActorCreationTaskSpec::mutable_concurrency_groups(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorCreationTaskSpec.concurrency_groups)
  return concurrency_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ConcurrencyGroup >*
ActorCreationTaskSpec::mutable_concurrency_groups() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ActorCreationTaskSpec.concurrency_groups)
  return &concurrency_groups_;
}
inline const ::mcs::rpc::ConcurrencyGroup& ActorCreationTaskSpec::_internal_concurrency_groups(int index) const {
  return concurrency_groups_.Get(index);
}
inline const ::mcs::rpc::ConcurrencyGroup& ActorCreationTaskSpec::concurrency_groups(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.concurrency_groups)
  return _internal_concurrency_groups(index);
}
inline ::mcs::rpc::ConcurrencyGroup* ActorCreationTaskSpec::_internal_add_concurrency_groups() {
  return concurrency_groups_.Add();
}
inline ::mcs::rpc::ConcurrencyGroup* ActorCreationTaskSpec::add_concurrency_groups() {
  ::mcs::rpc::ConcurrencyGroup* _add = _internal_add_concurrency_groups();
  // @@protoc_insertion_point(field_add:mcs.rpc.ActorCreationTaskSpec.concurrency_groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ConcurrencyGroup >&
ActorCreationTaskSpec::concurrency_groups() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ActorCreationTaskSpec.concurrency_groups)
  return concurrency_groups_;
}

// bool execute_out_of_order = 14;
inline void ActorCreationTaskSpec::clear_execute_out_of_order() {
  execute_out_of_order_ = false;
}
inline bool ActorCreationTaskSpec::_internal_execute_out_of_order() const {
  return execute_out_of_order_;
}
inline bool ActorCreationTaskSpec::execute_out_of_order() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.execute_out_of_order)
  return _internal_execute_out_of_order();
}
inline void ActorCreationTaskSpec::_internal_set_execute_out_of_order(bool value) {
  
  execute_out_of_order_ = value;
}
inline void ActorCreationTaskSpec::set_execute_out_of_order(bool value) {
  _internal_set_execute_out_of_order(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.execute_out_of_order)
}

// int32 max_pending_calls = 15;
inline void ActorCreationTaskSpec::clear_max_pending_calls() {
  max_pending_calls_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActorCreationTaskSpec::_internal_max_pending_calls() const {
  return max_pending_calls_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActorCreationTaskSpec::max_pending_calls() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorCreationTaskSpec.max_pending_calls)
  return _internal_max_pending_calls();
}
inline void ActorCreationTaskSpec::_internal_set_max_pending_calls(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_pending_calls_ = value;
}
inline void ActorCreationTaskSpec::set_max_pending_calls(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_pending_calls(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorCreationTaskSpec.max_pending_calls)
}

// -------------------------------------------------------------------

// ActorTaskSpec

// bytes actor_id = 2;
inline void ActorTaskSpec::clear_actor_id() {
  actor_id_.ClearToEmpty();
}
inline const std::string& ActorTaskSpec::actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTaskSpec.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTaskSpec::set_actor_id(ArgT0&& arg0, ArgT... args) {
 
 actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTaskSpec.actor_id)
}
inline std::string* ActorTaskSpec::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTaskSpec.actor_id)
  return _s;
}
inline const std::string& ActorTaskSpec::_internal_actor_id() const {
  return actor_id_.Get();
}
inline void ActorTaskSpec::_internal_set_actor_id(const std::string& value) {
  
  actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTaskSpec::_internal_mutable_actor_id() {
  
  return actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTaskSpec::release_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTaskSpec.actor_id)
  return actor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTaskSpec::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTaskSpec.actor_id)
}

// bytes actor_creation_dummy_object_id = 4;
inline void ActorTaskSpec::clear_actor_creation_dummy_object_id() {
  actor_creation_dummy_object_id_.ClearToEmpty();
}
inline const std::string& ActorTaskSpec::actor_creation_dummy_object_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTaskSpec.actor_creation_dummy_object_id)
  return _internal_actor_creation_dummy_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTaskSpec::set_actor_creation_dummy_object_id(ArgT0&& arg0, ArgT... args) {
 
 actor_creation_dummy_object_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTaskSpec.actor_creation_dummy_object_id)
}
inline std::string* ActorTaskSpec::mutable_actor_creation_dummy_object_id() {
  std::string* _s = _internal_mutable_actor_creation_dummy_object_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTaskSpec.actor_creation_dummy_object_id)
  return _s;
}
inline const std::string& ActorTaskSpec::_internal_actor_creation_dummy_object_id() const {
  return actor_creation_dummy_object_id_.Get();
}
inline void ActorTaskSpec::_internal_set_actor_creation_dummy_object_id(const std::string& value) {
  
  actor_creation_dummy_object_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTaskSpec::_internal_mutable_actor_creation_dummy_object_id() {
  
  return actor_creation_dummy_object_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTaskSpec::release_actor_creation_dummy_object_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTaskSpec.actor_creation_dummy_object_id)
  return actor_creation_dummy_object_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTaskSpec::set_allocated_actor_creation_dummy_object_id(std::string* actor_creation_dummy_object_id) {
  if (actor_creation_dummy_object_id != nullptr) {
    
  } else {
    
  }
  actor_creation_dummy_object_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_creation_dummy_object_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTaskSpec.actor_creation_dummy_object_id)
}

// uint64 actor_counter = 5;
inline void ActorTaskSpec::clear_actor_counter() {
  actor_counter_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTaskSpec::_internal_actor_counter() const {
  return actor_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActorTaskSpec::actor_counter() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTaskSpec.actor_counter)
  return _internal_actor_counter();
}
inline void ActorTaskSpec::_internal_set_actor_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  actor_counter_ = value;
}
inline void ActorTaskSpec::set_actor_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_actor_counter(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTaskSpec.actor_counter)
}

// bytes previous_actor_task_dummy_object_id = 7;
inline void ActorTaskSpec::clear_previous_actor_task_dummy_object_id() {
  previous_actor_task_dummy_object_id_.ClearToEmpty();
}
inline const std::string& ActorTaskSpec::previous_actor_task_dummy_object_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ActorTaskSpec.previous_actor_task_dummy_object_id)
  return _internal_previous_actor_task_dummy_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActorTaskSpec::set_previous_actor_task_dummy_object_id(ArgT0&& arg0, ArgT... args) {
 
 previous_actor_task_dummy_object_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ActorTaskSpec.previous_actor_task_dummy_object_id)
}
inline std::string* ActorTaskSpec::mutable_previous_actor_task_dummy_object_id() {
  std::string* _s = _internal_mutable_previous_actor_task_dummy_object_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ActorTaskSpec.previous_actor_task_dummy_object_id)
  return _s;
}
inline const std::string& ActorTaskSpec::_internal_previous_actor_task_dummy_object_id() const {
  return previous_actor_task_dummy_object_id_.Get();
}
inline void ActorTaskSpec::_internal_set_previous_actor_task_dummy_object_id(const std::string& value) {
  
  previous_actor_task_dummy_object_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActorTaskSpec::_internal_mutable_previous_actor_task_dummy_object_id() {
  
  return previous_actor_task_dummy_object_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActorTaskSpec::release_previous_actor_task_dummy_object_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ActorTaskSpec.previous_actor_task_dummy_object_id)
  return previous_actor_task_dummy_object_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActorTaskSpec::set_allocated_previous_actor_task_dummy_object_id(std::string* previous_actor_task_dummy_object_id) {
  if (previous_actor_task_dummy_object_id != nullptr) {
    
  } else {
    
  }
  previous_actor_task_dummy_object_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_actor_task_dummy_object_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ActorTaskSpec.previous_actor_task_dummy_object_id)
}

// -------------------------------------------------------------------

// Task

// .mcs.rpc.TaskSpec task_spec = 1;
inline bool Task::_internal_has_task_spec() const {
  return this != internal_default_instance() && task_spec_ != nullptr;
}
inline bool Task::has_task_spec() const {
  return _internal_has_task_spec();
}
inline void Task::clear_task_spec() {
  if (GetArenaForAllocation() == nullptr && task_spec_ != nullptr) {
    delete task_spec_;
  }
  task_spec_ = nullptr;
}
inline const ::mcs::rpc::TaskSpec& Task::_internal_task_spec() const {
  const ::mcs::rpc::TaskSpec* p = task_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::mcs::rpc::TaskSpec&>(
      ::mcs::rpc::_TaskSpec_default_instance_);
}
inline const ::mcs::rpc::TaskSpec& Task::task_spec() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.Task.task_spec)
  return _internal_task_spec();
}
inline void Task::unsafe_arena_set_allocated_task_spec(
    ::mcs::rpc::TaskSpec* task_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_spec_);
  }
  task_spec_ = task_spec;
  if (task_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs.rpc.Task.task_spec)
}
inline ::mcs::rpc::TaskSpec* Task::release_task_spec() {
  
  ::mcs::rpc::TaskSpec* temp = task_spec_;
  task_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mcs::rpc::TaskSpec* Task::unsafe_arena_release_task_spec() {
  // @@protoc_insertion_point(field_release:mcs.rpc.Task.task_spec)
  
  ::mcs::rpc::TaskSpec* temp = task_spec_;
  task_spec_ = nullptr;
  return temp;
}
inline ::mcs::rpc::TaskSpec* Task::_internal_mutable_task_spec() {
  
  if (task_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::mcs::rpc::TaskSpec>(GetArenaForAllocation());
    task_spec_ = p;
  }
  return task_spec_;
}
inline ::mcs::rpc::TaskSpec* Task::mutable_task_spec() {
  ::mcs::rpc::TaskSpec* _msg = _internal_mutable_task_spec();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.Task.task_spec)
  return _msg;
}
inline void Task::set_allocated_task_spec(::mcs::rpc::TaskSpec* task_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_spec_;
  }
  if (task_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mcs::rpc::TaskSpec>::GetOwningArena(task_spec);
    if (message_arena != submessage_arena) {
      task_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_spec, submessage_arena);
    }
    
  } else {
    
  }
  task_spec_ = task_spec;
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.Task.task_spec)
}

// -------------------------------------------------------------------

// ResourceId

// int64 index = 1;
inline void ResourceId::clear_index() {
  index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceId::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceId::index() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceId.index)
  return _internal_index();
}
inline void ResourceId::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  index_ = value;
}
inline void ResourceId::set_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceId.index)
}

// double quantity = 2;
inline void ResourceId::clear_quantity() {
  quantity_ = 0;
}
inline double ResourceId::_internal_quantity() const {
  return quantity_;
}
inline double ResourceId::quantity() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceId.quantity)
  return _internal_quantity();
}
inline void ResourceId::_internal_set_quantity(double value) {
  
  quantity_ = value;
}
inline void ResourceId::set_quantity(double value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceId.quantity)
}

// -------------------------------------------------------------------

// ResourceMapEntry

// string name = 1;
inline void ResourceMapEntry::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ResourceMapEntry::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceMapEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceMapEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceMapEntry.name)
}
inline std::string* ResourceMapEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceMapEntry.name)
  return _s;
}
inline const std::string& ResourceMapEntry::_internal_name() const {
  return name_.Get();
}
inline void ResourceMapEntry::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResourceMapEntry::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResourceMapEntry::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ResourceMapEntry.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResourceMapEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ResourceMapEntry.name)
}

// repeated .mcs.rpc.ResourceId resource_ids = 2;
inline int ResourceMapEntry::_internal_resource_ids_size() const {
  return resource_ids_.size();
}
inline int ResourceMapEntry::resource_ids_size() const {
  return _internal_resource_ids_size();
}
inline void ResourceMapEntry::clear_resource_ids() {
  resource_ids_.Clear();
}
inline ::mcs::rpc::ResourceId* ResourceMapEntry::mutable_resource_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceMapEntry.resource_ids)
  return resource_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceId >*
ResourceMapEntry::mutable_resource_ids() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ResourceMapEntry.resource_ids)
  return &resource_ids_;
}
inline const ::mcs::rpc::ResourceId& ResourceMapEntry::_internal_resource_ids(int index) const {
  return resource_ids_.Get(index);
}
inline const ::mcs::rpc::ResourceId& ResourceMapEntry::resource_ids(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceMapEntry.resource_ids)
  return _internal_resource_ids(index);
}
inline ::mcs::rpc::ResourceId* ResourceMapEntry::_internal_add_resource_ids() {
  return resource_ids_.Add();
}
inline ::mcs::rpc::ResourceId* ResourceMapEntry::add_resource_ids() {
  ::mcs::rpc::ResourceId* _add = _internal_add_resource_ids();
  // @@protoc_insertion_point(field_add:mcs.rpc.ResourceMapEntry.resource_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceId >&
ResourceMapEntry::resource_ids() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ResourceMapEntry.resource_ids)
  return resource_ids_;
}

// -------------------------------------------------------------------

// ViewData_Measure

// string tags = 1;
inline void ViewData_Measure::clear_tags() {
  tags_.ClearToEmpty();
}
inline const std::string& ViewData_Measure::tags() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.tags)
  return _internal_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ViewData_Measure::set_tags(ArgT0&& arg0, ArgT... args) {
 
 tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.tags)
}
inline std::string* ViewData_Measure::mutable_tags() {
  std::string* _s = _internal_mutable_tags();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ViewData.Measure.tags)
  return _s;
}
inline const std::string& ViewData_Measure::_internal_tags() const {
  return tags_.Get();
}
inline void ViewData_Measure::_internal_set_tags(const std::string& value) {
  
  tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ViewData_Measure::_internal_mutable_tags() {
  
  return tags_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ViewData_Measure::release_tags() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ViewData.Measure.tags)
  return tags_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ViewData_Measure::set_allocated_tags(std::string* tags) {
  if (tags != nullptr) {
    
  } else {
    
  }
  tags_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tags,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ViewData.Measure.tags)
}

// int64 int_value = 2;
inline void ViewData_Measure::clear_int_value() {
  int_value_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ViewData_Measure::_internal_int_value() const {
  return int_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ViewData_Measure::int_value() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.int_value)
  return _internal_int_value();
}
inline void ViewData_Measure::_internal_set_int_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  int_value_ = value;
}
inline void ViewData_Measure::set_int_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.int_value)
}

// double double_value = 3;
inline void ViewData_Measure::clear_double_value() {
  double_value_ = 0;
}
inline double ViewData_Measure::_internal_double_value() const {
  return double_value_;
}
inline double ViewData_Measure::double_value() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.double_value)
  return _internal_double_value();
}
inline void ViewData_Measure::_internal_set_double_value(double value) {
  
  double_value_ = value;
}
inline void ViewData_Measure::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.double_value)
}

// double distribution_min = 4;
inline void ViewData_Measure::clear_distribution_min() {
  distribution_min_ = 0;
}
inline double ViewData_Measure::_internal_distribution_min() const {
  return distribution_min_;
}
inline double ViewData_Measure::distribution_min() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.distribution_min)
  return _internal_distribution_min();
}
inline void ViewData_Measure::_internal_set_distribution_min(double value) {
  
  distribution_min_ = value;
}
inline void ViewData_Measure::set_distribution_min(double value) {
  _internal_set_distribution_min(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.distribution_min)
}

// double distribution_mean = 5;
inline void ViewData_Measure::clear_distribution_mean() {
  distribution_mean_ = 0;
}
inline double ViewData_Measure::_internal_distribution_mean() const {
  return distribution_mean_;
}
inline double ViewData_Measure::distribution_mean() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.distribution_mean)
  return _internal_distribution_mean();
}
inline void ViewData_Measure::_internal_set_distribution_mean(double value) {
  
  distribution_mean_ = value;
}
inline void ViewData_Measure::set_distribution_mean(double value) {
  _internal_set_distribution_mean(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.distribution_mean)
}

// double distribution_max = 6;
inline void ViewData_Measure::clear_distribution_max() {
  distribution_max_ = 0;
}
inline double ViewData_Measure::_internal_distribution_max() const {
  return distribution_max_;
}
inline double ViewData_Measure::distribution_max() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.distribution_max)
  return _internal_distribution_max();
}
inline void ViewData_Measure::_internal_set_distribution_max(double value) {
  
  distribution_max_ = value;
}
inline void ViewData_Measure::set_distribution_max(double value) {
  _internal_set_distribution_max(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.distribution_max)
}

// double distribution_count = 7;
inline void ViewData_Measure::clear_distribution_count() {
  distribution_count_ = 0;
}
inline double ViewData_Measure::_internal_distribution_count() const {
  return distribution_count_;
}
inline double ViewData_Measure::distribution_count() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.distribution_count)
  return _internal_distribution_count();
}
inline void ViewData_Measure::_internal_set_distribution_count(double value) {
  
  distribution_count_ = value;
}
inline void ViewData_Measure::set_distribution_count(double value) {
  _internal_set_distribution_count(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.distribution_count)
}

// repeated double distribution_bucket_boundaries = 8;
inline int ViewData_Measure::_internal_distribution_bucket_boundaries_size() const {
  return distribution_bucket_boundaries_.size();
}
inline int ViewData_Measure::distribution_bucket_boundaries_size() const {
  return _internal_distribution_bucket_boundaries_size();
}
inline void ViewData_Measure::clear_distribution_bucket_boundaries() {
  distribution_bucket_boundaries_.Clear();
}
inline double ViewData_Measure::_internal_distribution_bucket_boundaries(int index) const {
  return distribution_bucket_boundaries_.Get(index);
}
inline double ViewData_Measure::distribution_bucket_boundaries(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.distribution_bucket_boundaries)
  return _internal_distribution_bucket_boundaries(index);
}
inline void ViewData_Measure::set_distribution_bucket_boundaries(int index, double value) {
  distribution_bucket_boundaries_.Set(index, value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.distribution_bucket_boundaries)
}
inline void ViewData_Measure::_internal_add_distribution_bucket_boundaries(double value) {
  distribution_bucket_boundaries_.Add(value);
}
inline void ViewData_Measure::add_distribution_bucket_boundaries(double value) {
  _internal_add_distribution_bucket_boundaries(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.ViewData.Measure.distribution_bucket_boundaries)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ViewData_Measure::_internal_distribution_bucket_boundaries() const {
  return distribution_bucket_boundaries_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ViewData_Measure::distribution_bucket_boundaries() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ViewData.Measure.distribution_bucket_boundaries)
  return _internal_distribution_bucket_boundaries();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ViewData_Measure::_internal_mutable_distribution_bucket_boundaries() {
  return &distribution_bucket_boundaries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ViewData_Measure::mutable_distribution_bucket_boundaries() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ViewData.Measure.distribution_bucket_boundaries)
  return _internal_mutable_distribution_bucket_boundaries();
}

// repeated double distribution_bucket_counts = 9;
inline int ViewData_Measure::_internal_distribution_bucket_counts_size() const {
  return distribution_bucket_counts_.size();
}
inline int ViewData_Measure::distribution_bucket_counts_size() const {
  return _internal_distribution_bucket_counts_size();
}
inline void ViewData_Measure::clear_distribution_bucket_counts() {
  distribution_bucket_counts_.Clear();
}
inline double ViewData_Measure::_internal_distribution_bucket_counts(int index) const {
  return distribution_bucket_counts_.Get(index);
}
inline double ViewData_Measure::distribution_bucket_counts(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.Measure.distribution_bucket_counts)
  return _internal_distribution_bucket_counts(index);
}
inline void ViewData_Measure::set_distribution_bucket_counts(int index, double value) {
  distribution_bucket_counts_.Set(index, value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.Measure.distribution_bucket_counts)
}
inline void ViewData_Measure::_internal_add_distribution_bucket_counts(double value) {
  distribution_bucket_counts_.Add(value);
}
inline void ViewData_Measure::add_distribution_bucket_counts(double value) {
  _internal_add_distribution_bucket_counts(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.ViewData.Measure.distribution_bucket_counts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ViewData_Measure::_internal_distribution_bucket_counts() const {
  return distribution_bucket_counts_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ViewData_Measure::distribution_bucket_counts() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ViewData.Measure.distribution_bucket_counts)
  return _internal_distribution_bucket_counts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ViewData_Measure::_internal_mutable_distribution_bucket_counts() {
  return &distribution_bucket_counts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ViewData_Measure::mutable_distribution_bucket_counts() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ViewData.Measure.distribution_bucket_counts)
  return _internal_mutable_distribution_bucket_counts();
}

// -------------------------------------------------------------------

// ViewData

// string view_name = 1;
inline void ViewData::clear_view_name() {
  view_name_.ClearToEmpty();
}
inline const std::string& ViewData::view_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.view_name)
  return _internal_view_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ViewData::set_view_name(ArgT0&& arg0, ArgT... args) {
 
 view_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ViewData.view_name)
}
inline std::string* ViewData::mutable_view_name() {
  std::string* _s = _internal_mutable_view_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ViewData.view_name)
  return _s;
}
inline const std::string& ViewData::_internal_view_name() const {
  return view_name_.Get();
}
inline void ViewData::_internal_set_view_name(const std::string& value) {
  
  view_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ViewData::_internal_mutable_view_name() {
  
  return view_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ViewData::release_view_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ViewData.view_name)
  return view_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ViewData::set_allocated_view_name(std::string* view_name) {
  if (view_name != nullptr) {
    
  } else {
    
  }
  view_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), view_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ViewData.view_name)
}

// repeated .mcs.rpc.ViewData.Measure measures = 2;
inline int ViewData::_internal_measures_size() const {
  return measures_.size();
}
inline int ViewData::measures_size() const {
  return _internal_measures_size();
}
inline void ViewData::clear_measures() {
  measures_.Clear();
}
inline ::mcs::rpc::ViewData_Measure* ViewData::mutable_measures(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ViewData.measures)
  return measures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ViewData_Measure >*
ViewData::mutable_measures() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ViewData.measures)
  return &measures_;
}
inline const ::mcs::rpc::ViewData_Measure& ViewData::_internal_measures(int index) const {
  return measures_.Get(index);
}
inline const ::mcs::rpc::ViewData_Measure& ViewData::measures(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ViewData.measures)
  return _internal_measures(index);
}
inline ::mcs::rpc::ViewData_Measure* ViewData::_internal_add_measures() {
  return measures_.Add();
}
inline ::mcs::rpc::ViewData_Measure* ViewData::add_measures() {
  ::mcs::rpc::ViewData_Measure* _add = _internal_add_measures();
  // @@protoc_insertion_point(field_add:mcs.rpc.ViewData.measures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ViewData_Measure >&
ViewData::measures() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ViewData.measures)
  return measures_;
}

// -------------------------------------------------------------------

// ObjectRefInfo

// bytes object_id = 1;
inline void ObjectRefInfo::clear_object_id() {
  object_id_.ClearToEmpty();
}
inline const std::string& ObjectRefInfo::object_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.object_id)
  return _internal_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectRefInfo::set_object_id(ArgT0&& arg0, ArgT... args) {
 
 object_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.object_id)
}
inline std::string* ObjectRefInfo::mutable_object_id() {
  std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectRefInfo.object_id)
  return _s;
}
inline const std::string& ObjectRefInfo::_internal_object_id() const {
  return object_id_.Get();
}
inline void ObjectRefInfo::_internal_set_object_id(const std::string& value) {
  
  object_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectRefInfo::_internal_mutable_object_id() {
  
  return object_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectRefInfo::release_object_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ObjectRefInfo.object_id)
  return object_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectRefInfo::set_allocated_object_id(std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  object_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), object_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ObjectRefInfo.object_id)
}

// string call_site = 2;
inline void ObjectRefInfo::clear_call_site() {
  call_site_.ClearToEmpty();
}
inline const std::string& ObjectRefInfo::call_site() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.call_site)
  return _internal_call_site();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectRefInfo::set_call_site(ArgT0&& arg0, ArgT... args) {
 
 call_site_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.call_site)
}
inline std::string* ObjectRefInfo::mutable_call_site() {
  std::string* _s = _internal_mutable_call_site();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectRefInfo.call_site)
  return _s;
}
inline const std::string& ObjectRefInfo::_internal_call_site() const {
  return call_site_.Get();
}
inline void ObjectRefInfo::_internal_set_call_site(const std::string& value) {
  
  call_site_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectRefInfo::_internal_mutable_call_site() {
  
  return call_site_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectRefInfo::release_call_site() {
  // @@protoc_insertion_point(field_release:mcs.rpc.ObjectRefInfo.call_site)
  return call_site_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectRefInfo::set_allocated_call_site(std::string* call_site) {
  if (call_site != nullptr) {
    
  } else {
    
  }
  call_site_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), call_site,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.ObjectRefInfo.call_site)
}

// int64 object_size = 3;
inline void ObjectRefInfo::clear_object_size() {
  object_size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ObjectRefInfo::_internal_object_size() const {
  return object_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ObjectRefInfo::object_size() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.object_size)
  return _internal_object_size();
}
inline void ObjectRefInfo::_internal_set_object_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  object_size_ = value;
}
inline void ObjectRefInfo::set_object_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_object_size(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.object_size)
}

// int64 local_ref_count = 4;
inline void ObjectRefInfo::clear_local_ref_count() {
  local_ref_count_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ObjectRefInfo::_internal_local_ref_count() const {
  return local_ref_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ObjectRefInfo::local_ref_count() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.local_ref_count)
  return _internal_local_ref_count();
}
inline void ObjectRefInfo::_internal_set_local_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  local_ref_count_ = value;
}
inline void ObjectRefInfo::set_local_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_local_ref_count(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.local_ref_count)
}

// int64 submitted_task_ref_count = 5;
inline void ObjectRefInfo::clear_submitted_task_ref_count() {
  submitted_task_ref_count_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ObjectRefInfo::_internal_submitted_task_ref_count() const {
  return submitted_task_ref_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ObjectRefInfo::submitted_task_ref_count() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.submitted_task_ref_count)
  return _internal_submitted_task_ref_count();
}
inline void ObjectRefInfo::_internal_set_submitted_task_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  submitted_task_ref_count_ = value;
}
inline void ObjectRefInfo::set_submitted_task_ref_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_submitted_task_ref_count(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.submitted_task_ref_count)
}

// repeated bytes contained_in_owned = 6;
inline int ObjectRefInfo::_internal_contained_in_owned_size() const {
  return contained_in_owned_.size();
}
inline int ObjectRefInfo::contained_in_owned_size() const {
  return _internal_contained_in_owned_size();
}
inline void ObjectRefInfo::clear_contained_in_owned() {
  contained_in_owned_.Clear();
}
inline std::string* ObjectRefInfo::add_contained_in_owned() {
  std::string* _s = _internal_add_contained_in_owned();
  // @@protoc_insertion_point(field_add_mutable:mcs.rpc.ObjectRefInfo.contained_in_owned)
  return _s;
}
inline const std::string& ObjectRefInfo::_internal_contained_in_owned(int index) const {
  return contained_in_owned_.Get(index);
}
inline const std::string& ObjectRefInfo::contained_in_owned(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.contained_in_owned)
  return _internal_contained_in_owned(index);
}
inline std::string* ObjectRefInfo::mutable_contained_in_owned(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ObjectRefInfo.contained_in_owned)
  return contained_in_owned_.Mutable(index);
}
inline void ObjectRefInfo::set_contained_in_owned(int index, const std::string& value) {
  contained_in_owned_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline void ObjectRefInfo::set_contained_in_owned(int index, std::string&& value) {
  contained_in_owned_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline void ObjectRefInfo::set_contained_in_owned(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contained_in_owned_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline void ObjectRefInfo::set_contained_in_owned(int index, const void* value, size_t size) {
  contained_in_owned_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline std::string* ObjectRefInfo::_internal_add_contained_in_owned() {
  return contained_in_owned_.Add();
}
inline void ObjectRefInfo::add_contained_in_owned(const std::string& value) {
  contained_in_owned_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline void ObjectRefInfo::add_contained_in_owned(std::string&& value) {
  contained_in_owned_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline void ObjectRefInfo::add_contained_in_owned(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contained_in_owned_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline void ObjectRefInfo::add_contained_in_owned(const void* value, size_t size) {
  contained_in_owned_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs.rpc.ObjectRefInfo.contained_in_owned)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectRefInfo::contained_in_owned() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ObjectRefInfo.contained_in_owned)
  return contained_in_owned_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectRefInfo::mutable_contained_in_owned() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ObjectRefInfo.contained_in_owned)
  return &contained_in_owned_;
}

// bool pinned_in_memory = 7;
inline void ObjectRefInfo::clear_pinned_in_memory() {
  pinned_in_memory_ = false;
}
inline bool ObjectRefInfo::_internal_pinned_in_memory() const {
  return pinned_in_memory_;
}
inline bool ObjectRefInfo::pinned_in_memory() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.pinned_in_memory)
  return _internal_pinned_in_memory();
}
inline void ObjectRefInfo::_internal_set_pinned_in_memory(bool value) {
  
  pinned_in_memory_ = value;
}
inline void ObjectRefInfo::set_pinned_in_memory(bool value) {
  _internal_set_pinned_in_memory(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.pinned_in_memory)
}

// .mcs.rpc.TaskStatus task_status = 8;
inline void ObjectRefInfo::clear_task_status() {
  task_status_ = 0;
}
inline ::mcs::rpc::TaskStatus ObjectRefInfo::_internal_task_status() const {
  return static_cast< ::mcs::rpc::TaskStatus >(task_status_);
}
inline ::mcs::rpc::TaskStatus ObjectRefInfo::task_status() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.task_status)
  return _internal_task_status();
}
inline void ObjectRefInfo::_internal_set_task_status(::mcs::rpc::TaskStatus value) {
  
  task_status_ = value;
}
inline void ObjectRefInfo::set_task_status(::mcs::rpc::TaskStatus value) {
  _internal_set_task_status(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.task_status)
}

// uint64 attempt_number = 9;
inline void ObjectRefInfo::clear_attempt_number() {
  attempt_number_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectRefInfo::_internal_attempt_number() const {
  return attempt_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectRefInfo::attempt_number() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ObjectRefInfo.attempt_number)
  return _internal_attempt_number();
}
inline void ObjectRefInfo::_internal_set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  attempt_number_ = value;
}
inline void ObjectRefInfo::set_attempt_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_attempt_number(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ObjectRefInfo.attempt_number)
}

// -------------------------------------------------------------------

// ResourceAllocations_ResourceSlot

// int64 slot = 1;
inline void ResourceAllocations_ResourceSlot::clear_slot() {
  slot_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceAllocations_ResourceSlot::_internal_slot() const {
  return slot_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ResourceAllocations_ResourceSlot::slot() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceAllocations.ResourceSlot.slot)
  return _internal_slot();
}
inline void ResourceAllocations_ResourceSlot::_internal_set_slot(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  slot_ = value;
}
inline void ResourceAllocations_ResourceSlot::set_slot(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceAllocations.ResourceSlot.slot)
}

// double allocation = 2;
inline void ResourceAllocations_ResourceSlot::clear_allocation() {
  allocation_ = 0;
}
inline double ResourceAllocations_ResourceSlot::_internal_allocation() const {
  return allocation_;
}
inline double ResourceAllocations_ResourceSlot::allocation() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceAllocations.ResourceSlot.allocation)
  return _internal_allocation();
}
inline void ResourceAllocations_ResourceSlot::_internal_set_allocation(double value) {
  
  allocation_ = value;
}
inline void ResourceAllocations_ResourceSlot::set_allocation(double value) {
  _internal_set_allocation(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.ResourceAllocations.ResourceSlot.allocation)
}

// -------------------------------------------------------------------

// ResourceAllocations

// repeated .mcs.rpc.ResourceAllocations.ResourceSlot resource_slots = 1;
inline int ResourceAllocations::_internal_resource_slots_size() const {
  return resource_slots_.size();
}
inline int ResourceAllocations::resource_slots_size() const {
  return _internal_resource_slots_size();
}
inline void ResourceAllocations::clear_resource_slots() {
  resource_slots_.Clear();
}
inline ::mcs::rpc::ResourceAllocations_ResourceSlot* ResourceAllocations::mutable_resource_slots(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.ResourceAllocations.resource_slots)
  return resource_slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceAllocations_ResourceSlot >*
ResourceAllocations::mutable_resource_slots() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.ResourceAllocations.resource_slots)
  return &resource_slots_;
}
inline const ::mcs::rpc::ResourceAllocations_ResourceSlot& ResourceAllocations::_internal_resource_slots(int index) const {
  return resource_slots_.Get(index);
}
inline const ::mcs::rpc::ResourceAllocations_ResourceSlot& ResourceAllocations::resource_slots(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.ResourceAllocations.resource_slots)
  return _internal_resource_slots(index);
}
inline ::mcs::rpc::ResourceAllocations_ResourceSlot* ResourceAllocations::_internal_add_resource_slots() {
  return resource_slots_.Add();
}
inline ::mcs::rpc::ResourceAllocations_ResourceSlot* ResourceAllocations::add_resource_slots() {
  ::mcs::rpc::ResourceAllocations_ResourceSlot* _add = _internal_add_resource_slots();
  // @@protoc_insertion_point(field_add:mcs.rpc.ResourceAllocations.resource_slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ResourceAllocations_ResourceSlot >&
ResourceAllocations::resource_slots() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.ResourceAllocations.resource_slots)
  return resource_slots_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CoreWorkerStats

// string current_task_desc = 1;
inline void CoreWorkerStats::clear_current_task_desc() {
  current_task_desc_.ClearToEmpty();
}
inline const std::string& CoreWorkerStats::current_task_desc() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.current_task_desc)
  return _internal_current_task_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoreWorkerStats::set_current_task_desc(ArgT0&& arg0, ArgT... args) {
 
 current_task_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.current_task_desc)
}
inline std::string* CoreWorkerStats::mutable_current_task_desc() {
  std::string* _s = _internal_mutable_current_task_desc();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CoreWorkerStats.current_task_desc)
  return _s;
}
inline const std::string& CoreWorkerStats::_internal_current_task_desc() const {
  return current_task_desc_.Get();
}
inline void CoreWorkerStats::_internal_set_current_task_desc(const std::string& value) {
  
  current_task_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::_internal_mutable_current_task_desc() {
  
  return current_task_desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::release_current_task_desc() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CoreWorkerStats.current_task_desc)
  return current_task_desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoreWorkerStats::set_allocated_current_task_desc(std::string* current_task_desc) {
  if (current_task_desc != nullptr) {
    
  } else {
    
  }
  current_task_desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_task_desc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CoreWorkerStats.current_task_desc)
}

// int32 num_pending_tasks = 2;
inline void CoreWorkerStats::clear_num_pending_tasks() {
  num_pending_tasks_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::_internal_num_pending_tasks() const {
  return num_pending_tasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::num_pending_tasks() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.num_pending_tasks)
  return _internal_num_pending_tasks();
}
inline void CoreWorkerStats::_internal_set_num_pending_tasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_pending_tasks_ = value;
}
inline void CoreWorkerStats::set_num_pending_tasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_pending_tasks(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.num_pending_tasks)
}

// int32 num_object_refs_in_scope = 3;
inline void CoreWorkerStats::clear_num_object_refs_in_scope() {
  num_object_refs_in_scope_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::_internal_num_object_refs_in_scope() const {
  return num_object_refs_in_scope_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::num_object_refs_in_scope() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.num_object_refs_in_scope)
  return _internal_num_object_refs_in_scope();
}
inline void CoreWorkerStats::_internal_set_num_object_refs_in_scope(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_object_refs_in_scope_ = value;
}
inline void CoreWorkerStats::set_num_object_refs_in_scope(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_object_refs_in_scope(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.num_object_refs_in_scope)
}

// string ip_address = 7;
inline void CoreWorkerStats::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& CoreWorkerStats::ip_address() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoreWorkerStats::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.ip_address)
}
inline std::string* CoreWorkerStats::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CoreWorkerStats.ip_address)
  return _s;
}
inline const std::string& CoreWorkerStats::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void CoreWorkerStats::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::release_ip_address() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CoreWorkerStats.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoreWorkerStats::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CoreWorkerStats.ip_address)
}

// int64 port = 8;
inline void CoreWorkerStats::clear_port() {
  port_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CoreWorkerStats::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CoreWorkerStats::port() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.port)
  return _internal_port();
}
inline void CoreWorkerStats::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  port_ = value;
}
inline void CoreWorkerStats::set_port(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.port)
}

// bytes actor_id = 9;
inline void CoreWorkerStats::clear_actor_id() {
  actor_id_.ClearToEmpty();
}
inline const std::string& CoreWorkerStats::actor_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.actor_id)
  return _internal_actor_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoreWorkerStats::set_actor_id(ArgT0&& arg0, ArgT... args) {
 
 actor_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.actor_id)
}
inline std::string* CoreWorkerStats::mutable_actor_id() {
  std::string* _s = _internal_mutable_actor_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CoreWorkerStats.actor_id)
  return _s;
}
inline const std::string& CoreWorkerStats::_internal_actor_id() const {
  return actor_id_.Get();
}
inline void CoreWorkerStats::_internal_set_actor_id(const std::string& value) {
  
  actor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::_internal_mutable_actor_id() {
  
  return actor_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::release_actor_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CoreWorkerStats.actor_id)
  return actor_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoreWorkerStats::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  actor_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CoreWorkerStats.actor_id)
}

// map<string, .mcs.rpc.ResourceAllocations> used_resources = 10;
inline int CoreWorkerStats::_internal_used_resources_size() const {
  return used_resources_.size();
}
inline int CoreWorkerStats::used_resources_size() const {
  return _internal_used_resources_size();
}
inline void CoreWorkerStats::clear_used_resources() {
  used_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >&
CoreWorkerStats::_internal_used_resources() const {
  return used_resources_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >&
CoreWorkerStats::used_resources() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.CoreWorkerStats.used_resources)
  return _internal_used_resources();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >*
CoreWorkerStats::_internal_mutable_used_resources() {
  return used_resources_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::mcs::rpc::ResourceAllocations >*
CoreWorkerStats::mutable_used_resources() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.CoreWorkerStats.used_resources)
  return _internal_mutable_used_resources();
}

// map<string, string> webui_display = 11;
inline int CoreWorkerStats::_internal_webui_display_size() const {
  return webui_display_.size();
}
inline int CoreWorkerStats::webui_display_size() const {
  return _internal_webui_display_size();
}
inline void CoreWorkerStats::clear_webui_display() {
  webui_display_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CoreWorkerStats::_internal_webui_display() const {
  return webui_display_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CoreWorkerStats::webui_display() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.CoreWorkerStats.webui_display)
  return _internal_webui_display();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CoreWorkerStats::_internal_mutable_webui_display() {
  return webui_display_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CoreWorkerStats::mutable_webui_display() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.CoreWorkerStats.webui_display)
  return _internal_mutable_webui_display();
}

// int32 num_in_plasma = 12;
inline void CoreWorkerStats::clear_num_in_plasma() {
  num_in_plasma_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::_internal_num_in_plasma() const {
  return num_in_plasma_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::num_in_plasma() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.num_in_plasma)
  return _internal_num_in_plasma();
}
inline void CoreWorkerStats::_internal_set_num_in_plasma(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_in_plasma_ = value;
}
inline void CoreWorkerStats::set_num_in_plasma(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_in_plasma(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.num_in_plasma)
}

// int32 num_local_objects = 13;
inline void CoreWorkerStats::clear_num_local_objects() {
  num_local_objects_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::_internal_num_local_objects() const {
  return num_local_objects_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::num_local_objects() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.num_local_objects)
  return _internal_num_local_objects();
}
inline void CoreWorkerStats::_internal_set_num_local_objects(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_local_objects_ = value;
}
inline void CoreWorkerStats::set_num_local_objects(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_local_objects(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.num_local_objects)
}

// int64 used_object_store_memory = 14;
inline void CoreWorkerStats::clear_used_object_store_memory() {
  used_object_store_memory_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CoreWorkerStats::_internal_used_object_store_memory() const {
  return used_object_store_memory_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CoreWorkerStats::used_object_store_memory() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.used_object_store_memory)
  return _internal_used_object_store_memory();
}
inline void CoreWorkerStats::_internal_set_used_object_store_memory(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  used_object_store_memory_ = value;
}
inline void CoreWorkerStats::set_used_object_store_memory(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_object_store_memory(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.used_object_store_memory)
}

// int32 task_queue_length = 15;
inline void CoreWorkerStats::clear_task_queue_length() {
  task_queue_length_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::_internal_task_queue_length() const {
  return task_queue_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::task_queue_length() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.task_queue_length)
  return _internal_task_queue_length();
}
inline void CoreWorkerStats::_internal_set_task_queue_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  task_queue_length_ = value;
}
inline void CoreWorkerStats::set_task_queue_length(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_task_queue_length(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.task_queue_length)
}

// int32 num_executed_tasks = 16;
inline void CoreWorkerStats::clear_num_executed_tasks() {
  num_executed_tasks_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::_internal_num_executed_tasks() const {
  return num_executed_tasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CoreWorkerStats::num_executed_tasks() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.num_executed_tasks)
  return _internal_num_executed_tasks();
}
inline void CoreWorkerStats::_internal_set_num_executed_tasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_executed_tasks_ = value;
}
inline void CoreWorkerStats::set_num_executed_tasks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_executed_tasks(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.num_executed_tasks)
}

// string actor_title = 17;
inline void CoreWorkerStats::clear_actor_title() {
  actor_title_.ClearToEmpty();
}
inline const std::string& CoreWorkerStats::actor_title() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.actor_title)
  return _internal_actor_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoreWorkerStats::set_actor_title(ArgT0&& arg0, ArgT... args) {
 
 actor_title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.actor_title)
}
inline std::string* CoreWorkerStats::mutable_actor_title() {
  std::string* _s = _internal_mutable_actor_title();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CoreWorkerStats.actor_title)
  return _s;
}
inline const std::string& CoreWorkerStats::_internal_actor_title() const {
  return actor_title_.Get();
}
inline void CoreWorkerStats::_internal_set_actor_title(const std::string& value) {
  
  actor_title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::_internal_mutable_actor_title() {
  
  return actor_title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::release_actor_title() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CoreWorkerStats.actor_title)
  return actor_title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoreWorkerStats::set_allocated_actor_title(std::string* actor_title) {
  if (actor_title != nullptr) {
    
  } else {
    
  }
  actor_title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_title,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CoreWorkerStats.actor_title)
}

// repeated .mcs.rpc.ObjectRefInfo object_refs = 18;
inline int CoreWorkerStats::_internal_object_refs_size() const {
  return object_refs_.size();
}
inline int CoreWorkerStats::object_refs_size() const {
  return _internal_object_refs_size();
}
inline void CoreWorkerStats::clear_object_refs() {
  object_refs_.Clear();
}
inline ::mcs::rpc::ObjectRefInfo* CoreWorkerStats::mutable_object_refs(int index) {
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CoreWorkerStats.object_refs)
  return object_refs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectRefInfo >*
CoreWorkerStats::mutable_object_refs() {
  // @@protoc_insertion_point(field_mutable_list:mcs.rpc.CoreWorkerStats.object_refs)
  return &object_refs_;
}
inline const ::mcs::rpc::ObjectRefInfo& CoreWorkerStats::_internal_object_refs(int index) const {
  return object_refs_.Get(index);
}
inline const ::mcs::rpc::ObjectRefInfo& CoreWorkerStats::object_refs(int index) const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.object_refs)
  return _internal_object_refs(index);
}
inline ::mcs::rpc::ObjectRefInfo* CoreWorkerStats::_internal_add_object_refs() {
  return object_refs_.Add();
}
inline ::mcs::rpc::ObjectRefInfo* CoreWorkerStats::add_object_refs() {
  ::mcs::rpc::ObjectRefInfo* _add = _internal_add_object_refs();
  // @@protoc_insertion_point(field_add:mcs.rpc.CoreWorkerStats.object_refs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs::rpc::ObjectRefInfo >&
CoreWorkerStats::object_refs() const {
  // @@protoc_insertion_point(field_list:mcs.rpc.CoreWorkerStats.object_refs)
  return object_refs_;
}

// bytes job_id = 19;
inline void CoreWorkerStats::clear_job_id() {
  job_id_.ClearToEmpty();
}
inline const std::string& CoreWorkerStats::job_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoreWorkerStats::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 job_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.job_id)
}
inline std::string* CoreWorkerStats::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CoreWorkerStats.job_id)
  return _s;
}
inline const std::string& CoreWorkerStats::_internal_job_id() const {
  return job_id_.Get();
}
inline void CoreWorkerStats::_internal_set_job_id(const std::string& value) {
  
  job_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::_internal_mutable_job_id() {
  
  return job_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::release_job_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CoreWorkerStats.job_id)
  return job_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoreWorkerStats::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  job_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), job_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CoreWorkerStats.job_id)
}

// bytes worker_id = 20;
inline void CoreWorkerStats::clear_worker_id() {
  worker_id_.ClearToEmpty();
}
inline const std::string& CoreWorkerStats::worker_id() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoreWorkerStats::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 worker_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.worker_id)
}
inline std::string* CoreWorkerStats::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.CoreWorkerStats.worker_id)
  return _s;
}
inline const std::string& CoreWorkerStats::_internal_worker_id() const {
  return worker_id_.Get();
}
inline void CoreWorkerStats::_internal_set_worker_id(const std::string& value) {
  
  worker_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::_internal_mutable_worker_id() {
  
  return worker_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoreWorkerStats::release_worker_id() {
  // @@protoc_insertion_point(field_release:mcs.rpc.CoreWorkerStats.worker_id)
  return worker_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoreWorkerStats::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  worker_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), worker_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.CoreWorkerStats.worker_id)
}

// .mcs.rpc.Language language = 21;
inline void CoreWorkerStats::clear_language() {
  language_ = 0;
}
inline ::mcs::rpc::Language CoreWorkerStats::_internal_language() const {
  return static_cast< ::mcs::rpc::Language >(language_);
}
inline ::mcs::rpc::Language CoreWorkerStats::language() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.language)
  return _internal_language();
}
inline void CoreWorkerStats::_internal_set_language(::mcs::rpc::Language value) {
  
  language_ = value;
}
inline void CoreWorkerStats::set_language(::mcs::rpc::Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.language)
}

// uint32 pid = 22;
inline void CoreWorkerStats::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CoreWorkerStats::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CoreWorkerStats::pid() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.pid)
  return _internal_pid();
}
inline void CoreWorkerStats::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void CoreWorkerStats::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.pid)
}

// .mcs.rpc.WorkerType worker_type = 23;
inline void CoreWorkerStats::clear_worker_type() {
  worker_type_ = 0;
}
inline ::mcs::rpc::WorkerType CoreWorkerStats::_internal_worker_type() const {
  return static_cast< ::mcs::rpc::WorkerType >(worker_type_);
}
inline ::mcs::rpc::WorkerType CoreWorkerStats::worker_type() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.worker_type)
  return _internal_worker_type();
}
inline void CoreWorkerStats::_internal_set_worker_type(::mcs::rpc::WorkerType value) {
  
  worker_type_ = value;
}
inline void CoreWorkerStats::set_worker_type(::mcs::rpc::WorkerType value) {
  _internal_set_worker_type(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.worker_type)
}

// int64 objects_total = 24;
inline void CoreWorkerStats::clear_objects_total() {
  objects_total_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CoreWorkerStats::_internal_objects_total() const {
  return objects_total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CoreWorkerStats::objects_total() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.CoreWorkerStats.objects_total)
  return _internal_objects_total();
}
inline void CoreWorkerStats::_internal_set_objects_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  objects_total_ = value;
}
inline void CoreWorkerStats::set_objects_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_objects_total(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.CoreWorkerStats.objects_total)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetricPoint

// string metric_name = 1;
inline void MetricPoint::clear_metric_name() {
  metric_name_.ClearToEmpty();
}
inline const std::string& MetricPoint::metric_name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.MetricPoint.metric_name)
  return _internal_metric_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricPoint::set_metric_name(ArgT0&& arg0, ArgT... args) {
 
 metric_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.MetricPoint.metric_name)
}
inline std::string* MetricPoint::mutable_metric_name() {
  std::string* _s = _internal_mutable_metric_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.MetricPoint.metric_name)
  return _s;
}
inline const std::string& MetricPoint::_internal_metric_name() const {
  return metric_name_.Get();
}
inline void MetricPoint::_internal_set_metric_name(const std::string& value) {
  
  metric_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricPoint::_internal_mutable_metric_name() {
  
  return metric_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricPoint::release_metric_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.MetricPoint.metric_name)
  return metric_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricPoint::set_allocated_metric_name(std::string* metric_name) {
  if (metric_name != nullptr) {
    
  } else {
    
  }
  metric_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metric_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.MetricPoint.metric_name)
}

// int64 timestamp = 2;
inline void MetricPoint::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MetricPoint::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MetricPoint::timestamp() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.MetricPoint.timestamp)
  return _internal_timestamp();
}
inline void MetricPoint::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void MetricPoint::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.MetricPoint.timestamp)
}

// double value = 3;
inline void MetricPoint::clear_value() {
  value_ = 0;
}
inline double MetricPoint::_internal_value() const {
  return value_;
}
inline double MetricPoint::value() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.MetricPoint.value)
  return _internal_value();
}
inline void MetricPoint::_internal_set_value(double value) {
  
  value_ = value;
}
inline void MetricPoint::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mcs.rpc.MetricPoint.value)
}

// map<string, string> tags = 4;
inline int MetricPoint::_internal_tags_size() const {
  return tags_.size();
}
inline int MetricPoint::tags_size() const {
  return _internal_tags_size();
}
inline void MetricPoint::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetricPoint::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetricPoint::tags() const {
  // @@protoc_insertion_point(field_map:mcs.rpc.MetricPoint.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetricPoint::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetricPoint::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:mcs.rpc.MetricPoint.tags)
  return _internal_mutable_tags();
}

// string description = 5;
inline void MetricPoint::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& MetricPoint::description() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.MetricPoint.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricPoint::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.MetricPoint.description)
}
inline std::string* MetricPoint::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.MetricPoint.description)
  return _s;
}
inline const std::string& MetricPoint::_internal_description() const {
  return description_.Get();
}
inline void MetricPoint::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricPoint::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricPoint::release_description() {
  // @@protoc_insertion_point(field_release:mcs.rpc.MetricPoint.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricPoint::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.MetricPoint.description)
}

// string units = 6;
inline void MetricPoint::clear_units() {
  units_.ClearToEmpty();
}
inline const std::string& MetricPoint::units() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.MetricPoint.units)
  return _internal_units();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricPoint::set_units(ArgT0&& arg0, ArgT... args) {
 
 units_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.MetricPoint.units)
}
inline std::string* MetricPoint::mutable_units() {
  std::string* _s = _internal_mutable_units();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.MetricPoint.units)
  return _s;
}
inline const std::string& MetricPoint::_internal_units() const {
  return units_.Get();
}
inline void MetricPoint::_internal_set_units(const std::string& value) {
  
  units_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricPoint::_internal_mutable_units() {
  
  return units_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricPoint::release_units() {
  // @@protoc_insertion_point(field_release:mcs.rpc.MetricPoint.units)
  return units_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricPoint::set_allocated_units(std::string* units) {
  if (units != nullptr) {
    
  } else {
    
  }
  units_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), units,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.MetricPoint.units)
}

// -------------------------------------------------------------------

// NamedActorInfo

// string mcs_namespace = 1;
inline void NamedActorInfo::clear_mcs_namespace() {
  mcs_namespace_.ClearToEmpty();
}
inline const std::string& NamedActorInfo::mcs_namespace() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NamedActorInfo.mcs_namespace)
  return _internal_mcs_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedActorInfo::set_mcs_namespace(ArgT0&& arg0, ArgT... args) {
 
 mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.NamedActorInfo.mcs_namespace)
}
inline std::string* NamedActorInfo::mutable_mcs_namespace() {
  std::string* _s = _internal_mutable_mcs_namespace();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.NamedActorInfo.mcs_namespace)
  return _s;
}
inline const std::string& NamedActorInfo::_internal_mcs_namespace() const {
  return mcs_namespace_.Get();
}
inline void NamedActorInfo::_internal_set_mcs_namespace(const std::string& value) {
  
  mcs_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedActorInfo::_internal_mutable_mcs_namespace() {
  
  return mcs_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedActorInfo::release_mcs_namespace() {
  // @@protoc_insertion_point(field_release:mcs.rpc.NamedActorInfo.mcs_namespace)
  return mcs_namespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedActorInfo::set_allocated_mcs_namespace(std::string* mcs_namespace) {
  if (mcs_namespace != nullptr) {
    
  } else {
    
  }
  mcs_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mcs_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.NamedActorInfo.mcs_namespace)
}

// string name = 2;
inline void NamedActorInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NamedActorInfo::name() const {
  // @@protoc_insertion_point(field_get:mcs.rpc.NamedActorInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedActorInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mcs.rpc.NamedActorInfo.name)
}
inline std::string* NamedActorInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mcs.rpc.NamedActorInfo.name)
  return _s;
}
inline const std::string& NamedActorInfo::_internal_name() const {
  return name_.Get();
}
inline void NamedActorInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedActorInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedActorInfo::release_name() {
  // @@protoc_insertion_point(field_release:mcs.rpc.NamedActorInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedActorInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:mcs.rpc.NamedActorInfo.name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace mcs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mcs::rpc::Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::Language>() {
  return ::mcs::rpc::Language_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::WorkerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::WorkerType>() {
  return ::mcs::rpc::WorkerType_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::TaskType>() {
  return ::mcs::rpc::TaskType_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::ErrorType>() {
  return ::mcs::rpc::ErrorType_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::TaskStatus>() {
  return ::mcs::rpc::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::WorkerExitType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::WorkerExitType>() {
  return ::mcs::rpc::WorkerExitType_descriptor();
}
template <> struct is_proto_enum< ::mcs::rpc::PlacementStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mcs::rpc::PlacementStrategy>() {
  return ::mcs::rpc::PlacementStrategy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto
