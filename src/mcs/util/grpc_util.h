//
// Created by lianyu on 2023/1/10.
//
#pragma once

#include <google/protobuf/map.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/util/message_differencer.h>
#include <grpcpp/grpcpp.h>

#include <sstream>

//#include "absl/container/flat_hash_map.h"
#include "mcs/common/status.h"

namespace mcs {

/// Wrap a protobuf message.
  template <class Message>
  class MessageWrapper {
  public:
    /// Construct an empty message wrapper. This should not be used directly.
    MessageWrapper() : message_(std::make_shared<Message>()) {}

    /// Construct from a protobuf message object.
    /// The input message will be **copied** into this object.
    ///
    /// \param message The protobuf message.
    explicit MessageWrapper(const Message &message)
            : message_(std::make_shared<Message>(message)) {}

    explicit MessageWrapper(Message &&message)
            : message_(std::make_shared<Message>(std::move(message))) {}

    /// Construct from a protobuf message shared_ptr.
    ///
    /// \param message The protobuf message.
    explicit MessageWrapper(std::shared_ptr<Message> message) : message_(message) {}

    /// Construct from protobuf-serialized binary.
    ///
    /// \param serialized_binary Protobuf-serialized binary.
    explicit MessageWrapper(const std::string &serialized_binary)
            : message_(std::make_shared<Message>()) {
      message_->ParseFromString(serialized_binary);
    }

    /// Get const reference of the protobuf message.
    const Message &GetMessage() const { return *message_; }

    /// Get reference of the protobuf message.
    Message &GetMutableMessage() { return *message_; }

    /// Serialize the message to a string.
    const std::string Serialize() const { return message_->SerializeAsString(); }

    bool operator==(const MessageWrapper<Message> &rhs) const {
      return google::protobuf::util::MessageDifferencer::Equivalent(GetMessage(),
                                                                    rhs.GetMessage());
    }

  protected:
    /// The wrapped message.
    std::shared_ptr<Message> message_;
  };

/// Helper function that converts a mcs status to gRPC status.
  inline grpc::Status McsStatusToGrpcStatus(const Status &mcs_status) {
    if (mcs_status.ok()) {
      return grpc::Status::OK;
    } else {
      // Unlike `UNKNOWN`, `ABORTED` is never generated by the library, so using it means
      // more robust.
      return grpc::Status(
              grpc::StatusCode::ABORTED, mcs_status.CodeAsString(), mcs_status.message());
    }
  }

  inline std::string GrpcStatusToMcsStatusMessage(const grpc::Status &grpc_status) {
//    return absl::StrCat("RPC Error message: ",
//                        grpc_status.error_message(),
//                        "; RPC Error details: ",
//                        grpc_status.error_details());
      return "";
  }

/// Helper function that converts a gRPC status to mcs status.
  inline Status GrpcStatusToMcsStatus(const grpc::Status &grpc_status) {
    if (grpc_status.ok()) {
      return Status::OK();
    } else if (grpc_status.error_code() == grpc::StatusCode::DEADLINE_EXCEEDED) {
      // DEADLINE_EXCEEDED means the gRPC request has timedout. Convert it to Mcs timeout
      // status code.
      return Status(StatusCode::TimedOut, GrpcStatusToMcsStatusMessage(grpc_status));
    } else if (grpc_status.error_code() == grpc::StatusCode::ABORTED) {
      // This is a status generated by mcs code.
      // See McsStatusToGrpcStatus for details.
      return Status(Status::StringToCode(grpc_status.error_message()),
                    grpc_status.error_details());
    } else if (grpc_status.error_code() == grpc::StatusCode::UNAVAILABLE) {
      return Status::GrpcUnavailable(GrpcStatusToMcsStatusMessage(grpc_status));
    } else {
      // TODO(jjyao) Use GrpcUnknown as the catch-all status for all
      // the unhandled grpc status.
      // If needed, we can define a mcs status for each grpc status in the future.
      return Status::GrpcUnknown(GrpcStatusToMcsStatusMessage(grpc_status));
    }
  }

/// Converts a Protobuf `RepeatedPtrField` to a vector.
  template <class T>
  inline std::vector<T> VectorFromProtobuf(
          const ::google::protobuf::RepeatedPtrField<T> &pb_repeated) {
    return std::vector<T>(pb_repeated.begin(), pb_repeated.end());
  }

/// Converts a Protobuf `RepeatedField` to a vector.
  template <class T>
  inline std::vector<T> VectorFromProtobuf(
          const ::google::protobuf::RepeatedField<T> &pb_repeated) {
    return std::vector<T>(pb_repeated.begin(), pb_repeated.end());
  }

/// Converts a Protobuf `RepeatedField` to a vector of IDs.
  template <class ID>
  inline std::vector<ID> IdVectorFromProtobuf(
          const ::google::protobuf::RepeatedPtrField<::std::string> &pb_repeated) {
    auto str_vec = VectorFromProtobuf(pb_repeated);
    std::vector<ID> ret;
    std::transform(
            str_vec.begin(), str_vec.end(), std::back_inserter(ret), &ID::FromBinary);
    return ret;
  }

/// Converts a Protobuf map to a cpp map
//  template <class K, class V>
//  inline absl::flat_hash_map<K, V> MapFromProtobuf(
//          const ::google::protobuf::Map<K, V> &pb_map) {
//    return absl::flat_hash_map<K, V>(pb_map.begin(), pb_map.end());
//  }

}  // namespace mcs